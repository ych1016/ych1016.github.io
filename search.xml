<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>碎碎念</title>
    <url>/2024/12/01/Life/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p><font size=4>🚩 真正的自由意味着控制你整个生活，学会计划、承诺和决定，为你自己的行为负责！</font><br><br></p>
<blockquote>
<p><font face="楷体"> 没有一种批判比自我批判更强烈，也没有一种法官比我们自己更严苛。  ——《蛤蟆先生去看心理医生》</font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体">  对抗消极的不是积极，而是专注。积极的情绪是无法击退消极情绪的，只有把自己沉浸在某件事件上才能从消极情绪中走出来。 —— 若林正恭 </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体">  生活的不确定性正是我们希望的来源。  ——阿德勒 </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体"> 那些看起来比你勇敢的人也像你一样害怕，他们只是在黑暗中把口哨吹得响亮一些罢了。  ——《为什么长大》 </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体"> 那晚，我点了一把篝火，大地在月亮眼中亮起了一颗星星。   ——弱智吧  </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体"> 这乱糟糟的世上还有人拿着花四处走走    ——李沧东《火与灰》 </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体"> 好在，别人如何分析我，跟我本身是一点关系都没有的。    ——三毛《撒哈拉的故事》  </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体"> 你极目远望，其余的由心去完成。 </font></p>
</blockquote>
<br>

<blockquote>
<p><font face="楷体"> 一个人变好的前提是，允许自己不好。    ——武志红  </font></p>
</blockquote>
<br>
 
<blockquote>
<p><font face="楷体"> 纯粹，就是不要一心要成为高贵或者强大的人，而是成为自己。     ——佩索阿《惶然录》 </font></p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>名言积累</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <url>/2024/12/03/Hexo/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>❗本文针对hexo的Next主题的设置有效，其他主题可以看看有没有相同字段<br>Next默认是会在首页显示全文的，看起来冗长不简洁。要想首页仅展示文章标题或者摘要，请按照以下步骤进行：</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>首先需要在Next主题的<code>_config.yml</code>中把设置打开(默认安装时就打开了): </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="设置展示的内容"><a href="#设置展示的内容" class="headerlink" title="设置展示的内容"></a>设置展示的内容</h3><h4 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h4><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中<code>descriptio</code>n中的内容就会被显示在首页上，其余一律不显示。<br><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/Snipaste_2024-12-04_00-04-00.png"></p>
<p>PS: 这种方法主要是要自己对文章内容进行简单总结，有时候不喜欢写总结介绍的话，可以用下面第二种方法</p>
<h4 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h4><p>在需要截断的地方加入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>
<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p>
<p>这个明显会方便很多，但当然有利有弊，我一般喜欢用方法一，也希望自己写的<code>description</code>能够给读者快速了解文章内容的效果</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题</title>
    <url>/2024/12/01/Java/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h2 id="力扣面试经典-150-题"><a href="#力扣面试经典-150-题" class="headerlink" title="力扣面试经典 150 题"></a>力扣面试经典 150 题</h2><h3 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h3><h5 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">合并两个有序数组</a></h5><p>这道题目主要是利用到归并排序的思路，定义两个数组下标，比较数组对应的值，选择小的值插进新数组。需要注意的是，while 循环后还需要把剩下的数组遍历下去。这里还有一个点需要注意，就是 Java 的函数传参和数组赋值问题，Java 函数传递数组时，传进来的是数组地址，所以如果只是简单的给数组赋值新的数组，实际的数组并不会发生改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) res[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> res[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) res[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) res[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (m + n &gt;= <span class="number">0</span>) System.arraycopy(res, <span class="number">0</span>, nums1, <span class="number">0</span>, m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a><a href="https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150">移除元素</a></h5><p>这个就是一个简单的双指针问题，我们只需要记录不等于给定值的下标，然后遍历数组，只要数值不等于给定值的数字，我们就使用初始定义的下标记录下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除有序数组中的重复元素"><a href="#删除有序数组中的重复元素" class="headerlink" title="删除有序数组中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">删除有序数组中的重复元素</a></h5><p>这道题目跟上面的题目一样，相当于上面是要记录不等于指定值，也就是重复值为 0。这道题目则是允许重复值为 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!record.contains(nums[i])) &#123;</span><br><span class="line">            record.add(nums[i]);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除有序数组中的重复项-Ⅱ"><a href="#删除有序数组中的重复项-Ⅱ" class="headerlink" title="删除有序数组中的重复项 Ⅱ"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150">删除有序数组中的重复项 Ⅱ</a></h5><p>这道题目也是跟上面题目一样的思路。上一道题目是允许重复值为 1，这道题目是允许重复值为 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!record.containsKey(nums[i])) &#123;</span><br><span class="line">            record.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(record.get(nums[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">            record.put(nums[i], <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150">多数元素</a></h5><p>多数元素是出现次数超过数组长度一半的数。这道题目可以用相互抵消的思路来理解。因为它出现的次数多于总体一半，所以它与其他数出现次数相互抵消后，就一定还会存在这个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num) cnt++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                num = nums[i];   cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150">轮转数组</a></h5><p>这道题目的主要思路是利用到数组反转的原理。其实原理很简单，要将数组中的元素整体向右移 k 个单位，只需要将整个数组，整体反转，然后分别反转前 k 位和后 k 位</p>
<p><strong>eg：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;  end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150">买卖股票的最佳时机</a></h5><p>这道题目因为给了全部的天数数据，所以具有预知性，所以，我们可以从后开始遍历数组，记录后面哪一天是出价最高的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length, maxNum = prices[n-<span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res = Math.max(res, maxNum - prices[i]);</span><br><span class="line">        maxNum = Math.max(maxNum, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="买卖股票的最佳时机-Ⅱ"><a href="#买卖股票的最佳时机-Ⅱ" class="headerlink" title="买卖股票的最佳时机 Ⅱ"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150">买卖股票的最佳时机 Ⅱ</a></h5><p>因为可以多次购买，多次出售。这道题目跟前面的题目就不一样了。我们并不需要考虑什么时候出售，我们只需要在有差价，能挣钱的时候出售就可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>]) res += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&envId=top-interview-150">跳跃游戏</a></h5><p>初看题目像是要遍历很多次，其实不用。我们只需要维护一个距离变量。表示从当前所在下标能到达的最远距离即可。若当前下标比最远距离还要大，说明前面的点，没办法到达当前下标的位置，也就是不可能完成这个跳跃任务，我们直接返回 false 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="跳跃游戏-Ⅱ"><a href="#跳跃游戏-Ⅱ" class="headerlink" title="跳跃游戏 Ⅱ"></a><a href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150">跳跃游戏 Ⅱ</a></h5><p>这一道题目的主要思路就是看当前所在位置能到达多远的距离，end 暂存下来，相当于从当前位置跳到 end 只需要一步，然后逐步更新能到达的最远距离。当当前位置到达 end 时，说明这一步能到达的最远距离已经更新完了，也就是需要再跳一次了，这样就能记录下所需要的最少跳数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            res++;   end = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="H-指数"><a href="#H-指数" class="headerlink" title="H 指数"></a><a href="https://leetcode.cn/problems/h-index/?envType=study-plan-v2&envId=top-interview-150">H 指数</a></h5><p>这道题目其实用的是一个桶计数思路，但是这里有一个需要注意的是，当一篇文章的被引用次数超过实际数组长度时，我们只需要把它看成引用次数是数组长度就可以，这样可以减少很大的内存空间。然后桶主要记录的是引用次数对应出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> citation : citations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citation &gt; n) cnt[n]++;</span><br><span class="line">        <span class="keyword">else</span> cnt[citation]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        total += cnt[i];</span><br><span class="line">        <span class="keyword">if</span>(total &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="O-1-时间插入、删除和获取随机元素"><a href="#O-1-时间插入、删除和获取随机元素" class="headerlink" title="O(1)时间插入、删除和获取随机元素"></a><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150">O(1)时间插入、删除和获取随机元素</a></h5><p>这道题目主要用到一个 Hash 映射，通过可变数数组进行实现。但是这里用到 HashMap 集合，会让人感觉不是在 O(1)的时间内完成的操作。其实是 O(1)，因为 HashMap 的插入和删除，都是围绕下标进行，而 hash 获取下标只需要一个函数的映射操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(val);</span><br><span class="line">        map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.set(map.get(val), nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        map.put(nums.get(nums.size() - <span class="number">1</span>), map.get(val));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get(random.nextInt(nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150">除自身以外数组的乘积</a></h5><p>这道题目本来可以用前缀积做，但是题目要求不能使用除法，所以这道题目需要在前缀积的基础上稍加改变一下。我们只需要定义一个中间变量，先将最终答案置为这个中间变量再进行前缀积，实现在当前位置赋值时，是前面变量的乘积。同时由于题目要求，是除当前位置的其他所有变量的乘积，所以需要从左向右走一遍，然后再从右向左走一遍</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> n <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res <span class="operator">=</span> <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="keyword">left</span> <span class="operator">=</span> <span class="number">1</span>, <span class="keyword">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> n; <span class="operator">+</span><span class="operator">+</span>i) &#123;</span><br><span class="line">        res[i] <span class="operator">=</span> <span class="keyword">left</span>;</span><br><span class="line">        <span class="keyword">left</span> <span class="operator">=</span> <span class="keyword">left</span> <span class="operator">*</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> n<span class="number">-1</span>;i<span class="operator">&gt;=</span><span class="number">0</span>;<span class="comment">--i)&#123;</span></span><br><span class="line">        res[i] <span class="operator">*</span><span class="operator">=</span> <span class="keyword">right</span>;</span><br><span class="line">        <span class="keyword">right</span> <span class="operator">=</span> <span class="keyword">right</span> <span class="operator">*</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150">加油站</a></h5><p>这道题目其实并不需要去每一个点进行探索，只需要计算 gas 和 cost 的差值的前缀和就能解决这个问题。<strong>因为只要差值 &gt;&#x3D;0，就一定能绕圈走。</strong>所以我们的解题的最终目标变成了，探索从哪一个点开始出发。探索从哪个点开始出发也比较简单，我们看前缀和在哪里 &lt;0 了，说明在它前面的点出发是走不到当前的点的，所以出发点肯定需要从这个点的下一个点开始。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span> canCompleteCircuit(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost) &#123;</span><br><span class="line">    <span class="type">int</span> n <span class="operator">=</span> gas.length, run <span class="operator">=</span> <span class="number">0</span>, sum <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> n; <span class="operator">+</span><span class="operator">+</span>i) &#123;</span><br><span class="line">        run <span class="operator">+</span><span class="operator">=</span> gas[i] <span class="operator">-</span> cost[i];</span><br><span class="line">        sum <span class="operator">+</span><span class="operator">=</span> gas[i] <span class="operator">-</span> cost[i];</span><br><span class="line">        if (run <span class="operator">&lt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">            run <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">start</span> <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum <span class="operator">&gt;=</span> <span class="number">0</span> ? <span class="keyword">start</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150">分发糖果</a></h5><p>两者兼顾很容易顾此失彼。如果想用一次遍历就解决问题，就必须时刻注意当前数左右两边的数，并且如果从左到右遍历，没发预测右边还未遍历的数字是否还会受到奖励。所以我们需要分开考虑，先走一遍从左到右，考虑左边数字对右边数字的影响，然后再走一遍从右到左，考虑右边数字对左边数字的影响。然后需要满足左边走得通，右边也得走得通，怎么办呢，各个位置上的数取从左到右，从右到左的最大值，就能实现两边都满足。</p>
<table>
<tr>
<td>[1 0 2]<br/>[1 1 1]  <br/>[1 1 2]<br/>[2 1 1]<br/>[2 1 2]     2+1+2 = 5<br/></td></tr>
</table>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span> candy(<span class="type">int</span>[] ratings) &#123;</span><br><span class="line">    <span class="type">int</span> n <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span>[] num1 <span class="operator">=</span> <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] num2 <span class="operator">=</span> <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> n; <span class="operator">+</span><span class="operator">+</span>i) &#123;</span><br><span class="line">        num1[i] <span class="operator">=</span> num2[i] <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">1</span>; i <span class="operator">&lt;</span> n; <span class="operator">+</span><span class="operator">+</span>i) &#123;</span><br><span class="line">        if (ratings[i] <span class="operator">&gt;</span> ratings[i <span class="operator">-</span> <span class="number">1</span>]) &#123;</span><br><span class="line">            num1[i] <span class="operator">=</span> num1[i <span class="operator">-</span> <span class="number">1</span>] <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> n <span class="operator">-</span> <span class="number">2</span>; i <span class="operator">&gt;=</span> <span class="number">0</span>; <span class="comment">--i) &#123;</span></span><br><span class="line">        if (ratings[i] <span class="operator">&gt;</span> ratings[i <span class="operator">+</span> <span class="number">1</span>]) &#123;</span><br><span class="line">            num2[i] <span class="operator">=</span> num2[i <span class="operator">+</span> <span class="number">1</span>] <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> n; <span class="operator">+</span><span class="operator">+</span>i) &#123;</span><br><span class="line">        res <span class="operator">+</span><span class="operator">=</span> Math._max_(num1[i], num2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h5><p>这道题目的求解思路主要是，遍历数组，我们需要当前遍历位置，左边和右边最高的数值，然后对于这两个数值，去它们当中更小的那个数值（木桶效应），取出来之后需要减去当前位置的高度，算出差值。按照这种思路，我们需要多定义两个数组，分别记录当前位置左边的最大高度 leftMax[n]，和当前位置右边最大的高度 rightMax[n]，这样在遍历到当前位置时，当前位置的蓄水值为 min{rightMax[i],leftMax[i]} - heigh[i]。然后我们会发现这种思路其实有一种更简洁的做法，我们不需要多定义两个额外的数组，只需要定义两个变量即可，分别记录 0…i 左边的最大高度 leftMax，和 i+1 … n-1 的最大高度 rightMax，这样当 leftMax &lt; rightMax 时，我们更新左边；当 leftMax &gt; rightMax 时，我们更新右边；当 leftMax &#x3D; rightMax 时，我们两边都更新。因为每次计算蓄水值时，我们都是拿 leftMax 和 rightMax 更小的那个值去更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, res = <span class="number">0</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightMax &lt; leftMax)&#123;</span><br><span class="line">            res += rightMax - height[right--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 两边都更新</span></span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right) &#123;</span><br><span class="line">                res += rightMax - height[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a><a href="https://leetcode.cn/problems/roman-to-integer/submissions/521990974/?envType=study-plan-v2&envId=top-interview-150">罗马数字转整数</a></h5><p>比较简单的模拟题目…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(array[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; map.get(array[i]) &lt; map.get(array[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            temp = map.get(array[i+<span class="number">1</span>]) - map.get(array[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a><a href="https://leetcode.cn/problems/integer-to-roman/?envType=study-plan-v2&envId=top-interview-150">整数转罗马数字</a></h5><p>经典打表问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">            roman.append(symbols[i]);</span><br><span class="line">            num -= values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roman.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a><a href="https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150">最后一个单词的长度</a></h5><p>模拟题，定义一个 StringBuilder，只需要从最后一个字符开始遍历，若不是空格，就开始记录下来，直到再遇到空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] == <span class="string">&#x27; &#x27;</span>) --i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] != <span class="string">&#x27; &#x27;</span>) res.append(charArray[i--]);</span><br><span class="line">    <span class="keyword">return</span> res.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150">最长公共前缀</a></h5><p>模拟问题，只需要算出字符串数组中最短的那个字符串长度，然后遍历这个长度，取出第一个字符串的字符，然后一一比对其他字符，如果一样就记录下来，如果不一样，就直接退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) len = Math.min(len, str.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strs.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != strs[j].charAt(i)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) res.append(ch);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150">反转字符串中的单词</a></h5><p>这是一道简单的模拟题，我们只需要遍历一次给定的字符串，当遇到不是空格的字符时，把它记录下来，当再遇到空字符串时，我们把记录下来的这个字符串用列表记录下来。最后将整个列表反转一下，用 Collections 的 reverse 反转一下列表，就能实现反转单词的效果。然后再用 String 的 join 函数进行拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;String&gt; arr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s.charAt(i)!=<span class="string">&#x27; &#x27;</span> )&#123;</span><br><span class="line">                tmp.append(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections._reverse_(arr);</span><br><span class="line">    <span class="keyword">return</span> String._join_(<span class="string">&quot; &quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a><a href="https://leetcode.cn/problems/zigzag-conversion/description/?envType=study-plan-v2&envId=top-interview-150">Z 字形变换</a></h5><p>这道题目看上去很复杂，其实我们只需要记录原字符串每一个字符应该放在哪一行就可以完成这个任务。比如</p>
<blockquote>
<p>[!TIP]<br>numRows &#x3D; 3<br>PAYPALISHIRING<br>01210121012101</p>
</blockquote>
<p>numRows &#x3D; 4<br>PAYPALISHIRING<br>01232101230210</p>
<p>很明显，下标的规律就是先递增到指定 numRows - 1，然后再减少到 0。我们可以定义一个字符串数组，分别记录每一行需要记录的字符，最终将这些字符串数组拼接起来。这里有一个边界问题需要注意一下，就是当 numRows&#x3D;1 时，实际上就是输出原来的字符串而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) index[i] = idx++;</span><br><span class="line">        <span class="keyword">else</span> index[i] = idx--;</span><br><span class="line">        <span class="keyword">if</span> (idx == numRows) &#123;</span><br><span class="line">            idx -= <span class="number">2</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            idx += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder[] arr = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>[numRows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) arr[i] = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[index[i]].append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) res.append(arr[i]);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h5><p>这道题目是 KMP 的模板题目，抄模板即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> haystack.length(), n = needle.length();</span><br><span class="line">    <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>[] p = <span class="keyword">new</span> <span class="title class_">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) s[i + <span class="number">1</span>] = haystack.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) p[i + <span class="number">1</span>] = needle.charAt(i);</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 求Next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h5 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150">验证回文串</a></h5><p>字符串处理的题目，这里可以直接用正则表达式完成。我们只需要定义需要保留字符的正则表达式，然后将不需要的字符替换成空字符串，然后将字符串整体转成小写，遍历一半字符串，看看另一半对应位置是否匹配即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = s.replaceAll(<span class="string">&quot;[^A-Za-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&envId=top-interview-150">判断子序列</a></h5><p>这个题目直接用双指针就能完成，一层 for 循环遍历给定串，再定义目标串下标，若字符相同，则目标串下标往后移动；若到达目标串最后一位，则直接输出。需要判断的边界是，当两个字符串存在是空字符串的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.charAt(i) == s.charAt(idx)) idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两数之和-Ⅱ-输入有序数组"><a href="#两数之和-Ⅱ-输入有序数组" class="headerlink" title="两数之和 Ⅱ - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和 Ⅱ - 输入有序数组</a></h5><p>这个是经典的双指针问题，因为它是有序数组，所以只需要定义头和尾数组，然后往中间靠就能完成这道题目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] == target) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-interview-150">盛最多水的容器</a></h5><p>木桶效应，我们最终能盛最多水的容器取决于两根柱子中最短的那一根，并且取决于两根柱子之间的距离。使用双指针，定义前后两根柱子的位置，然后通过贪心的方法，取出最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        res = Math.max(Math.min(height[i], height[j]) * (j - i), res);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-interview-150">三数之和</a></h5><p>这道题目我主要用到两数之和的思想，三数之和为 0，只要把第三个数确定了，实际问题就变成了两数之和问题。因为两数之和给的是有序数组，所以，我们在这里需要先进行一个排序操作。然后枚举第一个数，再用两数之和的方法求出第二三个数出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span> - nums[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) ++i;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) --j;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) ++i;</span><br><span class="line">            <span class="keyword">else</span> --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h5 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h5><p>这道题目用到了前后滑动指针和前缀和的原理，设定一个前后指针和一个记录前缀和的变量。前缀和的变量记录前后指针之间的前缀和，当前缀和 &gt;&#x3D;target 时，我们就记录距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE, l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = Math.min(r - l, res);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h5><p>有点像双指针的题目，记录一前一后两个指针，当前面的指针遍历到一个字符重复出现两次时，后面的指针往前移动，同时减少后面指针所指字符出现的次数，知道前面指针所指的字符重复出现次数 &lt;2 后，再移动前面的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">    Arrays.fill(cnts,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i)]++;</span><br><span class="line">        <span class="keyword">while</span> (cnts[s.charAt(i)] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            cnts[s.charAt(j)]--;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h5><p>两种解题思路，一种是利用动态规划，另外一种是利用双指针。我们一一讲解</p>
<ul>
<li>动态规划（五部曲）</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/db927238-7243-42da-b265-cf3c5e695c92.png"><br><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/82efdcc2-127a-476b-ba29-579c97b65486.png"></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">10</span>][s.length() + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; ++j) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i) &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">                res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双指针</li>
</ul>
<p>从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extend(s, i, i);</span><br><span class="line">        extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extend</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; str.length() &amp;&amp; str.charAt(l) == str.charAt(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            len = r - l + <span class="number">1</span>;</span><br><span class="line">            left = l;</span><br><span class="line">            right = r;</span><br><span class="line">        &#125;</span><br><span class="line">        --l;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a></h5><p>双指针直接把题目秒了，从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止。扩散之后如果是回文，结果数就 +1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extendStr(s, i, i);</span><br><span class="line">        extendStr(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendStr</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;str.length() &amp;&amp; str.charAt(l) == str.charAt(r))&#123;</span><br><span class="line">        res++;</span><br><span class="line">        --l;  ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h5><p>滑动窗口题目，在原字符串 s 上进行滑动，滑动窗口的大小是给定字符串 p 的长度，然后设定一个数组，记录滑动窗口中字符出现的个数，再设定一个变量值记录滑动窗口内的字母和给定字符串 p 是否有差别，如果没有差别，则将对应的下标记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length(), differ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30000</span>];</span><br><span class="line">    Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pLen &gt; sLen) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnts[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnts[i] != <span class="number">0</span>) differ++;</span><br><span class="line">    <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnts[ch];</span><br><span class="line">        ch = s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnts[ch];</span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&envId=top-interview-150">串联所有单词的子串</a></h5><p>这道题目跟上面那道题目很像，但又不太一样。上面那道题目是字母，这题目是单词。官方的题解属实没看懂，放一版最后一个样例会超时的版本的，后续再优化一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), listLen = words.length, wordLen = words[<span class="number">0</span>].length(), totalLen = wordLen * listLen;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - totalLen + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; tmpMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + totalLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; totalLen; k += wordLen) &#123;</span><br><span class="line">            tmpMap.put(tmp.substring(k, k + wordLen), tmpMap.getOrDefault(tmp.substring(k, k + wordLen), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmpMap.equals(map)) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h5 id="有效数独"><a href="#有效数独" class="headerlink" title="有效数独"></a><a href="https://leetcode.cn/problems/valid-sudoku/description/?envType=study-plan-v2&envId=top-interview-150">有效数独</a></h5><p>这道题目有点像八皇后，与八皇后的区别是，现在是局限于一个 9<em>9 的矩阵中。所以我们可以定义一个 3</em>3<em>9 的矩阵，把原来 9</em>9 的矩阵分割成这样子，其中每个 9 代表记录一个 3<em>3 矩阵中的数出现的次数。现在问题在于，我们现在有数在 9</em>9 矩阵中的坐标 (i,j)， 怎么定位到自己独立 3*3 矩阵中？我们会发现 (i&#x2F;3,j&#x2F;3)，下面这些坐标</p>
<p>(0,0) (0,1) (0,2) (1,0) (1,1) (1,2)  (2,0)  (2,1)  (2,2)   分别对应我们下面这 9 个矩阵的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span>[][] cols = <span class="keyword">new</span> <span class="title class_">int</span>[n][n], rows = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span>[][][] nine = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">            cols[i][idx]++;</span><br><span class="line">            rows[j][idx]++;</span><br><span class="line">            nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx]++;</span><br><span class="line">            <span class="keyword">if</span> (cols[i][idx] &gt; <span class="number">1</span> || rows[j][idx] &gt; <span class="number">1</span> || nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150">螺旋矩阵</a></h5><p>这个就是一个模拟题，我们根据题目，先往右，再往下，再往左，再往上。需要先定义方向导致的坐标变更，然后定义走到的坐标，我们先将坐标对应位置上的数加入到结果中，然后再试探性的往下走一步，看会不会越界。这里有个问题需要注意一下，我们走过的点不能再走，所以我们需要定义一个访问的 boolean 数组，表示位置是否被访问。当我们试探性的往下走一步发现走不下去的时候，我们就需要变更方向了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>, colIdx = <span class="number">0</span>, rowIdx = <span class="number">0</span>, newCol = <span class="number">0</span>, newRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n * m; ++i) &#123;</span><br><span class="line">        res.add(matrix[colIdx][rowIdx]);</span><br><span class="line">        vis[colIdx][rowIdx] = <span class="literal">true</span>;</span><br><span class="line">        newCol = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        newRow = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newCol &lt; <span class="number">0</span> || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newRow &gt;= m || vis[newCol][newRow]) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colIdx = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        rowIdx = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-interview-150">旋转图像</a></h5><p>这个题目是数字位置变换的题目，我们通过观察可以发现，旋转后的数字位置，其实是原来矩阵先进行上下翻转，然后，再将下三角的数跟其坐标相反的数进行交换。比如 (i,j) 换到 (j,i)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 先上下反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - <span class="number">1</span> - i][j];</span><br><span class="line">            matrix[n - <span class="number">1</span> - i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后再将下三角的数，与横纵坐标相反的位置的数交换位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-interview-150">矩阵置零</a></h5><p>直接记录原矩阵数值为 0 的位置，用列表存储对应的(i,j)，然后遍历记录的列表，就能实现题目要求的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; coordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) coordinates.add(Arrays.asList(i, j));</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; coordinate : coordinates) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> coordinate.get(<span class="number">0</span>), col = coordinate.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) matrix[row][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生命游戏"><a href="#生命游戏" class="headerlink" title="生命游戏"></a><a href="https://leetcode.cn/problems/game-of-life/?envType=study-plan-v2&envId=top-interview-150">生命游戏</a></h5><p>模拟问题，新建一个新地图，然后根据规则在老地图遍历，并对新地图赋值。最后把新地图的数值复制给老地图即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] newBoard = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; direction.length; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[k][<span class="number">0</span>], col = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= n || col &lt; <span class="number">0</span> || col &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &lt; <span class="number">2</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (cnt == <span class="number">2</span> || cnt == <span class="number">3</span> )) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &gt; <span class="number">3</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第四种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; cnt == <span class="number">3</span>) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; n;++i) <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;m;++j) board[i][j] = newBoard[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h5 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150">赎金信</a></h5><p>这道题目只需要用桶的思路，记录 <code>magazine</code> 每个字符出现的次数，然后再遍历 <code>ransomNote</code> 看出现字符次数是否超过 <code>magazine</code> 字符出现的次数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] magazineCharCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(Character ch : magazine.toCharArray()) magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(Character ch: ransomNote.toCharArray()) &#123;</span><br><span class="line">        magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a><a href="https://leetcode.cn/problems/isomorphic-strings/?envType=study-plan-v2&envId=top-interview-150">同构字符串</a></h5><p>定义两个 Hash 映射就能解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Character&gt; lTor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Character&gt; rTol = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lTor.get(s.charAt(i))!=<span class="literal">null</span> &amp;&amp; lTor.get(s.charAt(i)) != t.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rTol.get(t.charAt(i))!= <span class="literal">null</span> &amp;&amp; rTol.get(t.charAt(i)) != s.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lTor.put(s.charAt(i), t.charAt(i));</span><br><span class="line">        rTol.put(t.charAt(i), s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a><a href="https://leetcode.cn/problems/word-pattern/?envType=study-plan-v2&envId=top-interview-150">单词规律</a></h5><p>与上一道题目是一样的，只需要将字符串按照空格切分成单词，再定义两个 Hash 映射就能解决问题。不过这里需要注意一下给定单词的长度应该和切分出来的单词列表的长度一致，不然会出现以下这种情况。</p>
<blockquote>
<p>[!TIP]<br>aaa<br>aa aa aa aa<br>这种样例算法不做特判就会有问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, String&gt; ltoR = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Character&gt; rtoL = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    String[] strList = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(strList.length != pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltoR.get(pattern.charAt(i))!=<span class="literal">null</span> &amp;&amp; !ltoR.get(pattern.charAt(i)).equals(strList[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rtoL.get(strList[i])!=<span class="literal">null</span> &amp;&amp; !rtoL.get(strList[i]).equals(pattern.charAt(i))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ltoR.put(pattern.charAt(i), strList[i]);</span><br><span class="line">        rtoL.put(strList[i], pattern.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有效字母的异位词"><a href="#有效字母的异位词" class="headerlink" title="有效字母的异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150">有效字母的异位词</a></h5><p>这个题目更简单，跟<a href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150">赎金信</a>是一样的，只需要把第一个单词中每个字母出现的次数记录下来，在第二个单词遍历的时候减去对应字母的次数，最后再遍历一下记录数组，看是否全为 0，即可判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (Character ch : t.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (Character ch : s.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-interview-150">字母异位词分组</a></h5><p>这道题目按照以往的做法，需要判断各个字符串出现的字母次数是否一致，才能归为一类。但实际上我们可以将字符串中的字母先进行排序，将不通字母排序的字符串变成统一，然后再用 Hash 记录对应的组别。<em><strong>主要是排序</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);     <span class="comment">// 很关键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(sorted, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(sorted, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&envId=top-interview-150">两数之和</a></h5><p>可以使用双指针做，也可以用 Hash 完成。双指针的话，需要先对给定的数组进行排序，然后指针从最左边和最右边开始移动。Hash 的话会比较快，记录目标值 - 当前值，映射当前值对应的下标，等遇到 目标值 - 当前值时，返回对应 Hash 映射和对应的下标即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">        map.put(target - nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a href="https://leetcode.cn/problems/happy-number/?envType=study-plan-v2&envId=top-interview-150">快乐数</a></h5><p>打表 YYDS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isHappy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        tmp = n;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n += (tmp % <span class="number">10</span>) * (tmp % <span class="number">10</span>);</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>) &#123;</span><br><span class="line">            isHappy = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHappy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a><a href="https://leetcode.cn/problems/contains-duplicate/">存在重复元素</a></h5><p>HashSet 去重，如果不能插入，说明有重复，重复直接返回存在重复元素，返回 True</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) <span class="keyword">if</span>(!set.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="存在重复元素-Ⅱ"><a href="#存在重复元素-Ⅱ" class="headerlink" title="存在重复元素 Ⅱ"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150">存在重复元素 Ⅱ</a></h5><p>用 Hash 记录数的下标，遇到重复的就看与之前存入的下标符不符合要求，不符合就更新下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; i - map.get(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-interview-150">最长连续序列</a></h5><p>排序 + 哈希。如果比当前数字小 1 的数字在 map 映射中存在的话，当前数字的长度就是比他小的数字的长度 +1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            map.put(num, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> map.put(num, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><h5 id="汇总区间"><a href="#汇总区间" class="headerlink" title="汇总区间"></a><a href="https://leetcode.cn/problems/summary-ranges/?envType=study-plan-v2&envId=top-interview-150">汇总区间</a></h5><p>双指针，记录一个能到达最右边的指针，往右走到不再连续。然后判断与原指针是否相等，相等就只新增原来的数；不相等就插入箭头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[high] + <span class="number">1</span> == nums[high + <span class="number">1</span>]) high++;</span><br><span class="line">        <span class="keyword">if</span> (high == i) res.add(String.valueOf(nums[i]));</span><br><span class="line">        <span class="keyword">else</span> res.add(String.valueOf(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + String.valueOf(nums[high]));</span><br><span class="line">        i = high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-interview-150">合并区间</a></h5><p>思路跟上面的题目一样，也是遍历给定的数组，然后设定一个最右边能到达的指针下标，然后等这个指针不能再往右边走时，就把对应的区间加入到最终的结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a><a href="https://leetcode.cn/problems/insert-interval/?envType=study-plan-v2&envId=top-interview-150">插入区间</a></h5><p>这道题目是上面那道题目的扩展，思路很简单，先把要插入的区间插入到给定的数组中，然后再执行一遍上一道题目的那个函数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="comment">// 使用ArrayList创建一个可以修改大小的列表</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intervals));</span><br><span class="line">    tmpList.add(newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将列表转换回数组，并进行排序</span></span><br><span class="line">    intervals = tmpList.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[tmpList.size()][]);</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150">用最少数量的箭引爆气球</a></h5><p>这道题目也是边界判断延续问题，不同点是我们要尽量让区间右端点尽可能的包含更多的区间。所以我们需要按照区间右端点进行升序排序，然后看当前区间的右端点，能包含多少区间的左端点，被包含的区间直接跳过即可。这里会存在一个数的极限问题，就是一个整数减去一个负数，会爆 Integer 边界，所以在排序的时候应该使用 Integer.<em>compare 比较函数</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] != b[<span class="number">1</span>] ? Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]) : Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    <span class="type">long</span> <span class="variable">high</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        high = Math.max(high, points[i][<span class="number">1</span>]);</span><br><span class="line">        right = i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; high &gt;= points[right][<span class="number">0</span>]) right++;</span><br><span class="line">        res++;</span><br><span class="line">        i = right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h5 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150">有效括号</a></h5><p>存入当前括号对应的反括号，为什么呢？因为如果式子有效的话，当前括号的反括号在当前位置后面一定会出现，当我们比对不匹配时，我们便可以得出当前串存在问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.lastElement() != ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a><a href="https://leetcode.cn/problems/simplify-path/?envType=study-plan-v2&envId=top-interview-150">简化路径</a></h5><p>用栈存放路径名称，不存放“&#x2F;”，然后对于 .. 的路径，表示的是返回上一层的路径，所以我们可以把栈顶元素弹出，相当于回到了上一层。最后再用“&#x2F;”将栈中元素进行拼接即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    String[] strList = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(str) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;.&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;..&quot;</span>.equals(str)) stack.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        res.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        res.insert(<span class="number">0</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.isEmpty()) res.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&envId=top-interview-150">最小栈</a></h5><p>存一个普通栈和一个最小栈，当一个新的数来的时候，普通栈直接压入，最小栈则跟栈顶元素比较一下，压入更小的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; xstack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        xstack.push(val);</span><br><span class="line">        minStack.push(Math.min(val,minStack.lastElement()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&envId=top-interview-150">逆波兰表达式求值</a></h5><p>这个已经将表达式转成后缀表达式了，我们并不需要判断运算符的优先级问题。我们只需要定义一个数字栈，遇到数字入栈，遇到符号，取出栈顶的两个元素，根据运算符号进行计算，把计算结果压入栈中，最后栈顶便为最终计算结果，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;+&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;-&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;*&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">            nums.push(Integer.parseInt(token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums.pop(), num2 = nums.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token)) nums.push(num1 + num2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(token)) nums.push(num2 - num1);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(token)) nums.push(num1 * num2);</span><br><span class="line">            <span class="keyword">else</span> nums.push(num2 / num1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a><a href="https://leetcode.cn/problems/basic-calculator/?envType=study-plan-v2&envId=top-interview-150">基本计算器</a></h5><p>这道题目因为只有加减运算，所以可以把它同意看成是加法运算，对于减法运算，我们可以看成是加上减去的那个数的相反数。这样我们只需要定义一个存储符号的栈，遇到(压栈，遇到)弹栈，遇到加号，符号为 1，遇到减号，符号为 0 。遇到数字，加上数字与符号的乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length(), res = <span class="number">0</span>, sign = <span class="number">1</span>;   <span class="comment">// sign 为 1 表示是正数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            sign = stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(sign);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                tmp = tmp * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            res += sign * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h5 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&envId=2cktkvj&page=1">环形链表</a></h5><p>这是一道经典的问题，我们只需要定义一快一慢两个指针，快指针每次走两步，慢指针每次走一步。如果链表中存在环，那么快指针一定跟慢指针相遇。如果链表中不存在环，那么快指针一定会以最快的速度到达尾指针，也就是 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head, high = head;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="literal">null</span>) &#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="keyword">if</span>(high.next!=<span class="literal">null</span> &amp;&amp; high.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                high = high.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(high == low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150">两数相加</a></h5><p>其实跟高精度计算是同一个思路。就是模拟数字笔算相加的过程，定义进位变量，存储最终链表头文件，在加上类似于归并排序的合并两个数组的思路，合并两个链表。最后由 add 是否大于 0，在决定是否添加新的结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> l1, n2 = l2, tmp = <span class="literal">null</span>, res = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span> ,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = (n1.val + n2.val + add);</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n1.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n2.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(add &gt; <span class="number">0</span>) tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(add);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&envId=top-interview-150">合并两个有序链表</a></h5><p>跟归并排序同一个思路，分别记录两个链表的两个指针，哪个链表的指针指向的值小，就记录哪个值，并移动对应的指针。最后，当两个链表有一方遍历完成，则只需将另一方剩余的链表加入到结果链表中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>, tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(list1) &amp;&amp; Objects.nonNull(list2)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(res)) res = tmp.next;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list1)) tmp.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list2)) tmp.next = list2;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(res)? tmp.next : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&envId=top-interview-150">随机链表的复制</a></h5><p>—— 回溯 + 哈希</p>
<p>本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p>
<p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p>
<p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Node, Node&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cacheMap.containsKey(head)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        cacheMap.put(head, newHead);</span><br><span class="line">        newHead.next = copyRandomList(head.next);</span><br><span class="line">        newHead.random = copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheMap.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h5><p>——模拟</p>
<p>我们只需要定义一前一后两个指针，然后保留后一个指针的 next 地址【newNode】，将后一个指针的 next 指向前一个指针，前一个指针再移动到后一个指针的位置，后一个指针移动到 newNode。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="反转链表-Ⅱ"><a href="#反转链表-Ⅱ" class="headerlink" title="反转链表 Ⅱ"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150">反转链表 Ⅱ</a></h5><p>——模拟</p>
<p>这道题目思路不复杂，就是根据函数参数提供的位置，把要反转的那部分链表切出来，同时记录要反转的那部分链表的前后节点（因为把反转后的链表放回原链表需要这两个节点）</p>
<p>具体实现需要注意定义虚拟头指针，因为这道题目的数据中，头指针很有可能也是要被反转的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="K-个一组反转链表"><a href="#K-个一组反转链表" class="headerlink" title="K 个一组反转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-interview-150">K 个一组反转链表</a></h5><p>这道题目第一次看上去跟上面的题目是同个思路，基本就是上面题目加个 for 循环的变体。我们在这里只需要知道链表的长度，然后每 k 个单位长度，调用上一问的函数反转一下，然后把反转后的链表重新赋值给 head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 获得链表总长度</span></span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        head = reverseBetween(head, i+<span class="number">1</span>, i + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-interview-150">删除链表的倒数第 N 个结点</a></h5><p>——模拟</p>
<p>先计算链表总共有几个结点，然后遍历到链表的倒数第 N 个结点的前一个结点，然后将结点的 next 赋值为 next.next 就可以。</p>
<p>实现的时候需要注意一下定义虚拟头结点，因为头结点有可能就是要被删除的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    tmp = dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - n; ++i) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = tmp.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h5><p>——模拟</p>
<p>定义前后两个指针，若后指针的下一个指针的值等于当前指针的值，则将前指针的 next 指向后指针的 next。</p>
<p>实现的时候需要定义一个虚拟头结点，因为可能要删除的结点函数传入的 head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(head)) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head, pre = dummyNode;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(curr.next))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除排序链表中的重复元素-Ⅱ"><a href="#删除排序链表中的重复元素-Ⅱ" class="headerlink" title="删除排序链表中的重复元素 Ⅱ"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?envType=study-plan-v2&envId=top-interview-150">删除排序链表中的重复元素 Ⅱ</a></h5><p>这道题目跟上一道题目不太一样，这道题目是不保留如果存在重复的数值，所以我们要先让当前指针 cur 先跨越所有重复值的值，然后再更新前指针 prev 的 next 的值。需要注意的是，如果存在重复的情况的话，不要移动 prev 指针的位置，因为重复后的数字很肯定再次出现重复的情况，所以我们等真的没有重复再移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur) &amp;&amp; Objects.nonNull(cur.next)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(cur.next) &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev = cur; </span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/?envType=study-plan-v2&envId=top-interview-150">旋转链表</a></h5><p>这道题目考察的是一个链表移动的问题，首先进行链表旋转的本质是给链表新的起始点。我们可以先走到链表尾，同时记录下链表的长度，因为旋转如果是链表的倍数的话，其实可以不用旋转，所以我们应该拿旋转次数 k 对链表长度 len 取余。然后走到链表尾的指针需要再往前走 k &#x3D; len - k%len 步，直到下一次起点的前一个指针，我们记录下当前起点的下一个指针，将当前起点的 next 赋值为 null，表示链表结尾，然后再将刚刚记录的值返回函数，即可实现效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head) || Objects.isNull(head.next) || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp.next)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = head;</span><br><span class="line">    k = len - k % len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) tmp = tmp.next;</span><br><span class="line">    head = tmp.next;</span><br><span class="line">    tmp.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&envId=top-interview-150">分隔链表</a></h5><p>有点分治思想，但也不是分治，就是一个模拟。思路是这样的，新开两条新链，采用尾插的方式往链表中添加元素。对于小于指定值的节点，我们添加到链表一；对于大于等于指定值，我们添加到链表二。我们需要注意的是记录两条链表的起始位置，等遍历结束时，我们可以进行拼接。最后在返回时还需要注意，可能全部节点都加到了链表二中，所以我们不能直接返回链表一，只有当链表一不为空时，才返回链表一，否则应该返回链表二。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l1Head = <span class="literal">null</span>, l2Head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">            l1.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l1Head)) l1Head = l1.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l2Head)) l2Head = l2.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1.next = l2Head;</span><br><span class="line">    l2.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(l1Head)? l2Head : l1Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&envId=top-interview-150">LRU 缓存</a></h5><p>双向链表 + Hash</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/8200f0da-2159-41f1-9fe7-5eb367030884.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h5 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-interview-150">二叉树的最大深度</a></h5><p>递归，土到极致就是潮。求最大深度，当前节点不存在，则为递归出口，直接返回 0。当前节点存在，则返回当前节点左右子树中比较深的那个数，同时，考虑到当前节点也为一层，所以需要在求出左右子树比较深的那个数值后面 + 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Math._max_(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a><a href="https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&envId=top-interview-150">相同的树</a></h5><p>——递归</p>
<p>比较两棵树，可以看作是比较当前的两个节点的递归实现，我们只需要把比较当前两个节点的逻辑处理通顺，比较两棵树就是递归的活。我们对于当前两个节点，两个节点都为 null，则返回 true。如果只有一方为空，则返回 false；如果都不为空，则比较节点的值，如果值不同，则返回 false；值相同，则需满足他们各自的左右子树都应该相同才能返回 true，此时就用上了递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p) &amp;&amp; Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.val == q.val) <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-interview-150">翻转二叉树</a></h5><p>——后递归原理</p>
<p>先翻转左右子树，再反转左右节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-interview-150">对称二叉树</a></h5><p>——递归</p>
<p>单个节点作为函数参数很难解决这道题目，我们直接使用<strong>重载</strong>的方式，将使用传入两个参数的形式，按照上面题目的方法，进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode a, TreeNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a) &amp;&amp; Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.val == b.val) <span class="keyword">return</span> isSymmetric(a.left, b.right) &amp;&amp; isSymmetric(a.right, b.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150">从前序与中序遍历序列构造二叉树</a></h5><p>由前序和中序构造二叉树有个特点，就是因为前序是最开始访问根节点的，所以前序遍历数组的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历，这样讲有点抽象，我们画个图会清晰点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= preorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&envId=top-interview-150">从中序与后序遍历序列构造二叉树</a></h5><p>由后序和中序构造二叉树有个特点，就是因为后序从右往左第一个是最开始访问根节点的，所以后序遍历数组从右往左的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历。需要注意的是，由后序遍历进行构造的数组，我们需要先构造右子树，再构造左子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        root.left = buildTree(postorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">        root.left = buildTree(postorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="填充每个节点的下一个右侧节点指针-Ⅱ"><a href="#填充每个节点的下一个右侧节点指针-Ⅱ" class="headerlink" title="填充每个节点的下一个右侧节点指针 Ⅱ"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/?envType=study-plan-v2&envId=top-interview-150">填充每个节点的下一个右侧节点指针 Ⅱ</a></h5><p>——层序遍历</p>
<p>考察的是二叉树的层序遍历。要使得每一行的二叉树节点的 next 指针都指向它的右边，我们需要对每一层单独做处理。我们通过队列 + 数组来完成。具体实现是先将根节点加入到队列中，然后我们以队列是否为空进行循环，每一次循环都遍历队列中所有元素，因为队列每一次循环弹出的是当前层的节点，每一次插入的是我们下一层的节点。对于当前层的节点，我们需要用一个数组将这些点记录下来，等我们把这一层的节点 next 指针连接完成，即遍历完这一层的节点后，我们再将这一层的孩子节点加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        temp.add(cur);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            cur.next = queue.poll();</span><br><span class="line">            temp.add(cur.next);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node node : temp) <span class="keyword">if</span>(Objects.nonNull(node))&#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.left))&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.right))&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-interview-150">二叉树展开为链表</a></h5><p>第一次看到这道题目想用前序遍历做，但是前序遍历的空间复杂度比较高，就想着能不能边翻遍历边翻转。用递归实在想不出来，看了一下别人题解使用的遍历。大概思路我画个图讲一下。思路主要是下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(root)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(root.left))&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(pre.right)) pre = pre.right;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 考虑下一个节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode.cn/problems/path-sum/?envType=study-plan-v2&envId=top-interview-150">路径总和</a></h5><p>——递归</p>
<p>如果当前节点为空，则无论 targetSum 等不等于 0，都返回 false。如果当前节点左右子树都为空，则说明当前节点为叶子节点，则直接返回当前节点值是否等于 target。若当前节点值不满足，则看看当前节点的左右子树是否满足。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right) ) <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&envId=top-interview-150">求根节点到叶节点数字之和</a></h5><p>——递归</p>
<p>先记录一个临时变量 tmp &#x3D; 上一个节点的值 num * 10 + 当前节点的值 val，如果当前节点为叶子节点，则直接返回临时变量 tmp，即已经到叶子，不用再拼接数字了。若不是叶子节点，则当前节点的左右子树递归结果相加，可作为最终的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getResult(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right)) <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="keyword">return</span> getResult(root.left, temp) + getResult(root.right, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>面试经典150题</tag>
      </tags>
  </entry>
</search>
