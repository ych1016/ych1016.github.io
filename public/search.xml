<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【力扣】热题100</title>
    <url>/2025/03/02/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E7%83%AD%E9%A2%98100/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一力扣热题100">一、力扣热题100</h1>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖倒置原则</title>
    <url>/2025/03/18/DesignPattern/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="依赖倒置原则">依赖倒置原则</h1>
<h2 id="一定义">一、定义</h2>
<p>  依赖倒转原则（Dependency Inversion
Principle，简称DIP）是指将两个模块之间的依赖关系倒置为依赖抽象类或接口。具体有两层含义：</p>
<ul>
<li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。</li>
</ul>
<p>最通俗的理解：<strong>面向接口编程</strong></p>
<h2 id="二问题由来">二、问题由来</h2>
<p>  
类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；
假如修改类A，则容易给程序带来不必要的风险。</p>
<blockquote>
<p>什么是依赖？类A直接依赖类B：类B是类A的某个成员方法的返回值、形参、局部变量或类A调用了类B的静态方法。</p>
</blockquote>
<h2 id="三解决方案">三、解决方案：</h2>
<p>  
将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，会大大降低修改类A的几率</p>
<h2 id="四衍生">四、衍生</h2>
<p>  
依赖倒置原则基于一个事实：相对于细节的多变性，抽象的东西要更稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。
在Java中，抽象指的是接口或抽象类，细节就是具体的实现类。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p>
<h2 id="五代码demo">五、代码demo：</h2>
<p>举个栗子：
现在假如有一个母亲每天晚上都要给孩子讲故事，只要给这位目前一本书，她就能给孩子讲故事。实现代码如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 书本类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;童话说雨后会有彩虹，却不曾说也会转身成空~&quot;</span>;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 母亲类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monther</span> &#123;</span><br><span class="line">    <span class="comment">// 母亲只能读睡前故事，读不了报纸，要想读报纸就得就该母亲这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readContent</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        book.getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInversionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        <span class="type">Monther</span> <span class="variable">monther</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monther</span>();</span><br><span class="line">        monther.readContent(book);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出：</span></span><br><span class="line"><span class="comment">         * 童话说雨后会有彩虹，却不曾说也会转身成空~</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是现在出现了这样一个场景，这个孩子长大了，不喜欢听故事了。想要这位母亲讲新闻给他听。我们此时创建出对应的新闻类
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewPaper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;最新消息，本台记者报道~&quot;</span>;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是发现母亲类实现读的方法无法接收新闻实体，也就是母亲读不了新闻。如果还是执意要执行，那就需要修改母亲类。显然，这在实际开发中是存在很大风险的。那可以怎么修改呢？
第一时间想到了多态，可以让母亲实现读的方法的参数能够接收新闻和故事实体，那就需要将新闻和故事公共的部分进行抽象，抽象成普通父类还不够，因为公共的方法要求都必须有各自的实现，
那就只能抽象成接口或抽象类。这里采用接口的方式实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookRight</span> <span class="keyword">implements</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;童话说雨后会有彩虹，却不曾说也会转身成空~&quot;</span>;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsPaperRight</span> <span class="keyword">implements</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;最新消息，本台记者报道~&quot;</span>;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MontherRight</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readContent</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        reader.getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyInversionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MontherRight</span> <span class="variable">montherRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MontherRight</span>();</span><br><span class="line">        <span class="type">BookRight</span> <span class="variable">bookRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookRight</span>();</span><br><span class="line">        <span class="type">NewsPaperRight</span> <span class="variable">newsPaperRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewsPaperRight</span>();</span><br><span class="line">        montherRight.readContent(bookRight);</span><br><span class="line">        montherRight.readContent(newsPaperRight);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出：</span></span><br><span class="line"><span class="comment">         *  童话说雨后会有彩虹，却不曾说也会转身成空~</span></span><br><span class="line"><span class="comment">         *  最新消息，本台记者报道~</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="六总结">六、总结</h2>
<p>   在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有</li>
<li>变量的声明类型尽量是抽象类或接口</li>
<li>使用继承时遵循里氏替换原则</li>
</ul>
<h2 id="七参考文章">七、参考文章</h2>
<ol type="1">
<li>https://blog.csdn.net/zhengzhb/article/details/7289269</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>依赖倒置</tag>
      </tags>
  </entry>
  <entry>
    <title>单一职责原则</title>
    <url>/2025/03/13/DesignPattern/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="单一职责原则">单一职责原则</h1>
<h2 id="一定义">一、定义</h2>
<p>一个接口或者类只有一个原因引起变化。
也就是说一个接口或者一个类只有一个职责，只负责意见事情。（此原则同样适用于方法）</p>
<h2 id="二问题由来">二、问题由来</h2>
<p>类T负责两个不同的职责：职责P1、职责P2.当由于职责P1需求发生改变而需要求改类T时，有可能会导致原本运行正常的职责P2功能发生故障</p>
<h2 id="三解决方案">三、解决方案：</h2>
<p>遵循单一职责原则，分别建立两个类T1、T2，使T1完成P1功能，T2完成P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险</p>
<h2 id="四代码demo">四、代码demo：</h2>
<h3 id="类单一原则">1、类单一原则</h3>
<h4 id="错误示范">(1) 错误示范</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称判断吃什么，可以看到类中的方法存在 if-else，也就是这个类需要负责两个不一样的功能，违背了单一原则</span></span><br><span class="line"><span class="comment">     * 改进：</span></span><br><span class="line"><span class="comment">     * 1. 可以抽离类，将这个类抽成两个类，各自负责自己的那部分</span></span><br><span class="line"><span class="comment">     * 2. 可以抽离方法，把if的内容写成一个方法，把else写成一个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eating</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;羊&quot;</span>.equals(name))&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;吃草&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;吃肉&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KindDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.eating(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">        animal.eating(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修正">(2) 修正</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修正   用装饰器模式，将动物类抽象成父类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnimalFather</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eating</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MeatAnimal</span> <span class="keyword">extends</span> <span class="title class_">AnimalFather</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eating</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrassAnimal</span> <span class="keyword">extends</span> <span class="title class_">AnimalFather</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eating</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;吃草&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KindDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MeatAnimal</span> <span class="variable">meatAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MeatAnimal</span>();</span><br><span class="line">        meatAnimal.eating(<span class="string">&quot;狼&quot;</span>);</span><br><span class="line">        <span class="type">GrassAnimal</span> <span class="variable">grassAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GrassAnimal</span>();</span><br><span class="line">        grassAnimal.eating(<span class="string">&quot;草&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法的单一原则">2、方法的单一原则</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前方法需要完成两个动作，一个是设置用户名称，另外一个是获取用户年龄并返回</span></span><br><span class="line"><span class="comment">     * 不符合方法的单一原则</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     * 拆分方法，将功能模块化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">setNameAndGetAge</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 设置用户名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取用户年龄</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修正</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置用户名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取年龄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口的单一原则">3、接口的单一原则</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGood</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看到，IGood接口中负责了太多功能，不仅要负责</span></span><br><span class="line"><span class="comment">     * 1. 商品信息管理：获取商品名称 + 获取商品价格</span></span><br><span class="line"><span class="comment">     * 2. 商品售卖管理：购买商品 + 退款</span></span><br><span class="line"><span class="comment">     * 不符合接口的单一原则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取商品名称</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取商品价格</span></span><br><span class="line">    Double <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 购买商品</span></span><br><span class="line">    Boolean <span class="title function_">buyGood</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 退款</span></span><br><span class="line">    Boolean <span class="title function_">refund</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改正</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGoodInfo</span> &#123;</span><br><span class="line">    <span class="comment">// 获取商品名称</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取商品价格</span></span><br><span class="line">    Double <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGoodManage</span>&#123;</span><br><span class="line">    <span class="comment">// 购买商品</span></span><br><span class="line">    Boolean <span class="title function_">buyGood</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 退款</span></span><br><span class="line">    Boolean <span class="title function_">refund</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodImpl</span> <span class="keyword">implements</span> <span class="title class_">IGoodInfo</span>, IGoodManage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">buyGood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">refund</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五优点">五、优点</h2>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h2 id="六实际应用">六、实际应用</h2>
<p>虽然单一原则简单，并且被认为是常识，但在实际开发中还是会存在违背这一原则的存在。为什么呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</p>
<p>举个栗子：
类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2。
这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。
但是在程序已经写好的情况下，这样做简直太费时间了。
所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。
（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p>
<p>就如同上面第四部分的<code>类的单一原则</code>的代码演示，我们为了遵循单一原则，我们把那个动物类抽象成了抽象类，然后再分别新建了吃草动物类和吃肉动物类，理论上满足了单一原则，但实际上的花销很大，如果需求短时间内需要交付，我们可以采取另外的改进措施。
我们看一下下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatMeat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatGrass</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;吃草&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以看出，我并没有去新建吃草动物类和吃肉动物类，而是在动物类上将<code>eating</code>方法修改成两个方法，这样虽然也违背了类的单一职责原则，但在方法级别上却是符合单一职责原则的。所以在实际业务开发中，选择遵循哪一种原则还是需要根据实际情况确定。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>单一职责原则</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2025/03/13/DesignPattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一引言">一、引言</h1>
<p>  在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例，这些应用都或多或少具有资源管理器的功能。
每台计算机可以有若干个打印机，但只能有一个Printer
Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。
总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>
<h1 id="二什么是单例模式">二、什么是单例模式？</h1>
<p>  单例模式可以确保系统中某个类只有一个实例，该类自行实例化并向整个系统提供这个实例的公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>
<blockquote>
<p>延续我们之前的栗子，还是生产MBP电脑的问题，假如现在MBP工厂只有一台光刻机可以生产芯片，那么，此时我们在创建这台光刻机的时候，就应该将它设置为单例模式。
也就是整个工厂中有且只有一台，整个程序中也有且只有一个这样的对象。</p>
<p>但是问题来了，MBPM3要用这台光刻机，MBPM4也要用这台光刻机。那我们该如何保证系统只有一个光刻机对象呢？如果现在都要用，那又该怎么解决呢？</p>
<p>第一个问题，我们下文分析；第二个问题其实现在就可以回答，答案就是等。想象一下，你去打印店打印东西的时候，如果打印店只有一台打印机，那一定是排在你前面的同学先打完才能轮到你打印。</p>
</blockquote>
<p>  那我们就得引入以下单例的几种创建模式了，包括懒汉单例、饿汉单例以及登记式单例</p>
<h1 id="三编写单例的注意事项">三、编写单例的注意事项</h1>
<h2 id="三个必要条件">（1） 三个必要条件</h2>
<p>单例模式的实现需要三个必要的条件：</p>
<ol type="1">
<li>单例类的构造函数必须是私有的，才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例。</li>
<li>单例通过一个私有的静态变量来存储其唯一实例。</li>
<li>单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。</li>
</ol>
<h2 id="考虑三个问题">（2）考虑三个问题</h2>
<p>实现单例类时，还需要考虑三个问题：</p>
<ul>
<li>创建单例对象时，是否线程安全。</li>
<li>单例对象的创建，是否延时加载。</li>
<li>获取单例对象时，是否需要加锁（锁会导致低性能）</li>
</ul>
<h1 id="四单例模式优缺点">四、单例模式优缺点</h1>
<p><strong>（1）优点：</strong></p>
<ol type="1">
<li>可以确保所有的对象都访问同一个实例</li>
<li>可以节约系统资源，避免了频繁创建和销毁的对象</li>
<li>避免对共享资源的多重占用</li>
</ol>
<p><strong>（2）缺点：</strong></p>
<ol type="1">
<li>不适合变化的对象，如果同一类型的对象总是要在不同场景发生变化，单例就会造成数据错误</li>
<li>职责过重，一定程度上违背了”单一职责原则“</li>
<li>如果实例化的对象长时间不被利用，系统可能会认为是垃圾而被挥手</li>
</ol>
<h1 id="五懒汉单例">五、懒汉单例</h1>
<h2 id="定义">（1）定义</h2>
<p>  
所谓懒汉单例，其实跟字面意思一样，就是“懒”，得等到需要的时候才回去创建，项目启动不会主动去创建对象，等程序运行到需要这个对象的时候才去创建。</p>
<blockquote>
<p>贴合我们的栗子：最开始生产电脑的时候，MBPM3和MBPM4都不知道没有制造芯片的光刻机，然后各自去生产各自的显示器、键盘等，等到要用的时候才发现该去买了，那要怎么保证不会买重复呢？</p>
</blockquote>
<h2 id="代码demo">（2）代码demo</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是懒汉，恭喜你启动我的创建功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法，提供唯一公共访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(singleton))&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新的问题">（3）新的问题</h2>
<p>  
假如现在在一个高并发的场景下，线程1和线程2都需要这个单例对象，此时恰好系统对这个对象的创建使用了懒汉单例，那么就会存在如下图的问题。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313191948.png" style="zoom: 67%;">
  
线程1调用了获取单例对象的静态方法，线程2也调用了获取单例的方法，如果线程1和线程2在同一时刻判断单例是否存在，那给它们的回答必然都会是不存在，那么就会导致线程1走创建单例的代码，线程2也会走创建单例的代码。
这样一下子就创建了两个对象，不符合单例的定义。并且现在的考虑是在两个线程下，要是现在是100个线程，那很有可能会创建出100个对象，这是非常危险的。</p>
<p>  
那可以怎么改进呢？线程存在高并发问题，第一时间想到了锁，可以把获取单例对象的方法锁起来，每次只允许一个线程进入。于是有了如下的代码：</p>
<h3 id="线程同步机制">【1】线程同步机制</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加同步机制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonV2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonV2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是懒汉，恭喜你启动我的创建功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonV2</span> <span class="variable">singletonV2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法，提供唯一公共访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonV2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(singletonV2)) &#123;</span><br><span class="line">            singletonV2 = <span class="keyword">new</span> <span class="title class_">SingletonV2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonV2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  
但是现在又存在一个问题，所有线程每次获取这个单例对象，就得同步（被加锁，排队获取）。但是我们的需求只是在单例创建的时候，为了保证只创建出一个单例对象才加的锁。现在每次用到都得加锁，效率太差。
说明我们锁的粒度太大了，应该把锁的粒度延迟到创建对象的时候，于是我们有了第三版的代码。</p>
<h3 id="双重判断">【2】双重判断</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonV3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonV3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是懒汉，恭喜你启动我的创建功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonV3</span> <span class="variable">singletonV3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法，提供唯一公共访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonV3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(singletonV3)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonV3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.isNull(singletonV3)) &#123;</span><br><span class="line">                    singletonV3 = <span class="keyword">new</span> <span class="title class_">SingletonV3</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonV3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）为什么 getInstance() 方法需要使用两个 if
(Objects.isNull(singletonV3)) 进行判断?</p>
<p>不加的代码如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingletonV3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(singletonV3)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonV3.class) &#123;</span><br><span class="line">            singletonV3 = <span class="keyword">new</span> <span class="title class_">SingletonV3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonV3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   
假设高并发下，线程1和线程2都通过了第一个if条件。若线程1先抢到了锁，new了一个对象，释放锁。在这个时候，线程2也抢到了锁，现在没有做第二个if判断，那么线程2就会再new出一个对象。这样便不符合单例的定义。
所以使用两个if判断，确保只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗。</p>
<p>（2）volatile关键字的作用是什么？</p>
<p>   volatile的作用主要是禁止指令重排序。假设在不使用 volatile
的情况下，两个线程1、2，都是第一次调用该单例方法，线程1先执行 singleton
= new Singleton()，
但由于构造方法不是一个原子操作，编译后会生成多条字节码指令，由于 JAVA的
指令重排序，可能会先执行 singleton
的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，
之后 singleton
便不为空了，但是实际的初始化操作却还没有执行。如果此时线程2进入，就会拿到一个不为空的但是没有完成初始化的singleton
对象，
所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。</p>
<h3 id="静态内部类">【3】 静态内部类</h3>
<p>  
前面的两种都是靠加锁才实现了单例创建的唯一性。对于高并发的系统来说，加锁会对系统的效率产生很大影响，那有没有一种方法能不加锁实现单例的创建呢？</p>
<p>  
在讲解之前，我们需要明白关于静态内部类的一个点，那就是：<strong>在Java中，外部类被加载时，静态内部类不会被初始化，只有首次访问静态内部类时（如创建实例，访问静态成员等），才会触发初始化。</strong></p>
<p>  
这不就是我们懒汉单例所需要的吗，不访问不初始化，访问了才创建。那么我们就可以很快的想出，在单例类中定义一个静态内部类，静态内部类定义单例对象作为静态成员，
然后在 getInstance() 方法中，返回静态内部类中静态成员。代码如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonV4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonV4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是懒汉，恭喜你启动我的创建功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LayHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonV4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonV4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态工厂方法，提供唯一公共访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonV4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LayHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="六饿汉单例">六、饿汉单例</h1>
<h2 id="定义-1">（1）定义</h2>
<p>  
所谓饿汉单例，就是预防饥饿，即在项目启动时，就把所定义的单例对象创建好，这样就不用考虑多线程高并发问题。</p>
<blockquote>
<p>贴合我们的栗子：最开始生产电脑的时候，MBP公司就先买好了光刻机，MBPM3和MBPM4要使用的话，就直接排队使用，不用考虑是谁去买的问题。</p>
</blockquote>
<h2 id="实现代码">（2）实现代码：</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line">    Single() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是饿汉，不用调用我，我也会帮你创建好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Single</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Single</span>();</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七懒汉单例和饿汉单例对比">七、懒汉单例和饿汉单例对比</h1>
<p><strong>1、 初始化和首次调用</strong></p>
<ul>
<li>饿汉式是在类加载时，就将单例初始化完成，保证获取实例的时候，单例是已经存在的了。所以在第一次调用时速度也会更快，因为其资源已经初始化完成。</li>
<li>懒汉式会延迟加载，只有在首次调用时才会实例化单例，如果初始化所需要的工作比较多，那么首次访问性能上会有些延迟，不过之后就和饿汉式一样了。</li>
</ul>
<p><strong>2、线程安全方面</strong></p>
<ul>
<li>饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题；</li>
<li>懒汉式本身是非线程安全的，需要通过额外的机制保证线程安全。</li>
</ul>
<h1 id="五登记式单例">五、登记式单例</h1>
<h2 id="定义-2">（1）定义</h2>
<p>  登记式单例又称注册式单例，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。
注册单例有两种：① 枚举登记； ② 容器缓存（Spring源码常用）</p>
<h2 id="枚举登记">（2）枚举登记</h2>
<h3 id="引言">【1】 引言</h3>
<p>在Java中，除了可以使用 new 和 工厂
方式创建对象外，还可以使用克隆、反序列化和反射创建对象，但这些方式在创建对象时有可能导致单例对象的不唯一性，如何解决呢？</p>
<p>（1）为了防止客户端使用克隆方法创建对象，单例类不能使用 Cloneable
接口，即不能支持 clone() 方法</p>
<p>（2）由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象，这个除了枚举基本没法避开</p>
<p>（3）在原型模式中，我们可以通过反序列化实现克隆，反序列化也会生成新的对象。具体操作是：每次调用
readObject()
方法，都将会返回一个新建的实例对象，这个实例对象不同于类在初始化时创建的实例对象。</p>
<blockquote>
<p>那反序列化如何避免？<br> ① 单例类不能实现
Serializable接口，即不允许该类支持序列化；<br> ② 枚举</p>
</blockquote>
<p>因为Java虚拟机会保证枚举对象的唯一性，因此每一个枚举类型和定义的枚举变量在JVM中都是唯一的。并且通过枚举实现的单例，既可以避免多线程同步问题；还可以防止通过反射和反序列化来重新创建新的对象。</p>
<h3 id="实现代码-1">【2】实现代码：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器缓存">（3）容器缓存</h2>
<h3 id="实现原理">【1】实现原理</h3>
<p>登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。</p>
<h3 id="代码实现">【2】 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登记型单例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CashSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CashSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是登记型单例，我已经帮你登记好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, CashSingleton&gt; singletonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 在类加载时执行，且只能执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">CashSingleton</span> <span class="variable">cashSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CashSingleton</span>();</span><br><span class="line">        singletonMap.put(cashSingleton.getClass().getName(), cashSingleton);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态工厂，返回此类唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> CashSingleton <span class="title function_">getInstance</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(name)) &#123;</span><br><span class="line">            name = CashSingleton.class.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot; name == null &quot;</span> + <span class="string">&quot;----&gt;name=&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(singletonMap.get(name))) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonMap.put(name, (CashSingleton) Class.forName(name).newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonMap.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六总结">六、总结</h1>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2025/03/13/DesignPattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="工厂模式">工厂模式</h1>
<h2 id="引言">1、引言</h2>
<p>  在面向对象编程中，创建对象实例最常用的方式就是通过 new
操作符构造一个对象实例，但在某些情况下，new
操作符直接生成对象会存在一些问题。举例来说，对象的创建需要一系列的步骤：可能需要计算或取得对象的初始位置、选择生成哪个子对象实例、或在生成之前必须先生成一些辅助对象。
在这些情况，新对象的建立就是一个
“过程”，而不仅仅是一个操作，就像一部大机器中的一个齿轮传动。</p>
<p>  针对上面这种情况，我们如何轻松方便地构造对象实例，而不必关心构造对象示例的细节和复杂过程？解决方案就是使用一个<strong>工厂类来创建对象</strong>。</p>
<h2 id="什么是工厂模式">2、什么是工厂模式</h2>
<p>  工厂模式的主要目的是将创建对象的具体过程屏蔽隔离起来，从而达到更高的灵活性。工厂模式可以分为三类：</p>
<ul>
<li><strong>简单工厂模式（Simple
Factory）：</strong>只有唯一工厂（简单工厂），一个产品接口/抽象类，根据简单工厂中的静态方法来创建具体产品对象。适用于产品较少，几乎不扩展的情景</li>
<li><strong>工厂方法模式（Factory
Method）：</strong>有多个工厂（抽象工厂+多个具体工厂），一个产品接口/抽象类，根据继承抽象工厂中的方法来多态创建具体产品对象。适用于一个类型的多个产品</li>
<li><strong>抽象工厂模式（Abstract
Factory）：</strong>有多个工厂（抽象工厂+多个具体工厂），多个产品接口/抽象类，对产品子类进行分组，根据继承抽象工厂中的方法多态创建同组的不同具体产品对象。适用于多个类型的多个产品</li>
</ul>
<p>举个生产电脑的栗子介绍一下这几个工厂模式：</p>
<p>（1）在没有工厂的时代，如果客户需要一款MBP电脑，那么就需要客户去创建一款MBP电脑，然后拿来用。</p>
<p>（2）简单工厂模式：后来出现了工厂，用户不再需要去创建MBP电脑，由工厂进行创建，想要什么MBP电脑，直接通过工厂创建就可以了。比如想要M3系列的MBP电脑，工厂就创建这个系列的电脑。</p>
<p>（3）工厂方法模式：为了满足客户，MBP系列越来越多，如M3、M4等等系列，一个工厂无法创建所有的MBP系列，于是又单独分出来多个具体的工厂，每个具体工厂创建一种系列，即具体工厂类只能创建一个具体产品。但是MBP电脑工厂还是个抽象，你需要指定某个具体的工厂才能生产电脑出来。</p>
<p>（4）抽象工厂模式：随着客户要求越来越高，MBP电脑车必须配置鼠标，于是这个工厂开始生产MBP电脑和需要的鼠标。最终是客户只要对MBP的销售员说：我要M3的带有鼠标的MBP电脑，销售员就直接给他M3的带有鼠标的MBP电脑了。而不用自己去创建M3的带有鼠标的MBP电脑。</p>
<h2 id="无工厂模式实现">3、无工厂模式实现</h2>
<p>  如果没有工厂模式，那么用户要获得MBP电脑就得自己去创建，想要什么型号，就得找到对应的型号去new。以下是对应类图以及实现。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312203232.png" style="zoom: 33%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">        customer.createMBPM3();</span><br><span class="line">        customer.createMBPM4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MBPM3 <span class="title function_">createMBPM3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MBPM4 <span class="title function_">createMBPM4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产---&gt; MBPM3电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产MBPM4电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单工厂模式">4、简单工厂模式</h2>
<p>  简单工厂模式有叫做静态工厂方法模式（static Factory Method
pattern），它时通过使用静态方法接受不同的参数来返回不同的实例对象。简单工厂模式的核心是定义一个创建对象的接口，将对象的创建和本身的业务逻辑分离，降低系统的耦合度，使得以后需要改变时，只需要修改工厂类即可。</p>
<h3 id="简单工厂实现原理及uml图">（1）简单工厂实现原理及UML图</h3>
<p>  其实实现的主要原理还是利用到了多态的概念，可以用父类去接子类的对象，这就非常方便我们将创建对象的方法进行抽象，我们只需要定义一个公共的MBP父类，用不同型号的子类去继承它。对于创建子类对象的过程交给工厂完成，最后用父类去接创建出来的子类对象即可。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312205351.png" style="zoom:50%;" /></p>
<h3 id="实现代码">（2）实现代码</h3>
<p>产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBP</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBPM3</span> <span class="keyword">extends</span> <span class="title class_">MBP</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产M-----&gt;MBP3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBPM4</span> <span class="keyword">extends</span> <span class="title class_">MBP</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产M-----&gt;MBP4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MBP <span class="title function_">createMBP</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M3&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M4&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MBP <span class="title function_">createMBPStatic</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M3&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M4&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m3</span> <span class="operator">=</span> factory.createMBP(<span class="string">&quot;M3&quot;</span>);</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m4</span> <span class="operator">=</span> factory.createMBP(<span class="string">&quot;M4&quot;</span>);</span><br><span class="line">		<span class="comment">// 静态工厂</span></span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m31</span> <span class="operator">=</span> Factory.createMBPStatic(<span class="string">&quot;M3&quot;</span>);</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m41</span> <span class="operator">=</span> Factory.createMBPStatic(<span class="string">&quot;M4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优缺点">（3）优缺点</h3>
<ul>
<li>优点：简单工厂可以使客户端免除直接创建对象的职责，能够根据需要创建出对应的产品。实现客户端可产品类的代码分离。此外，可以通过配置文件来实现不修改客户端代码的情况下添加新的具体产品类</li>
<li>缺点：<strong>违背了开闭原则</strong>，如果需要新增其他产品类，就必须在工厂类中新增类似<code>if-else</code>的条件判断（上面的演示代码用了<code>switch</code>），虽然可以用配置文件来改进，但是整体上而言，系统扩展相对于其他工厂模式要困难很多。
<ul>
<li>关于如何使用配置文件改进简单工厂，在这里描述一下：其实就是将创建工厂的条件，上述代码中的<code>String type</code>，改成是根据类路径来创建对象。再详细点就是，将类路径写在配置文件中，然后工厂在创建对象的时候，根据获取到的类路径，用反射创建出对象。这样，即使有了新的产品，我们也只需要在新建产品类并继承产品父类，然后在配置文件中添加新建产品类的类路径。</li>
</ul></li>
</ul>
<h3 id="简单工厂和静态工厂">（4）简单工厂和静态工厂</h3>
<p>可以看到上面用户类中使用了两种方法创建实例对象，一种是类方法，一种是类的静态方法。那使用类的静态方法有什么好处呢？</p>
<ul>
<li>使用静态方法可以不需要使用<code>new</code>的方法创建对象，方便调用</li>
<li>控制实例的创建，如缓存实例，延迟初始化</li>
<li>减少客户端对具体类的依赖</li>
</ul>
<h3 id="简单工厂在实际中的应用">（5）简单工厂在实际中的应用</h3>
<p>【1】如<code>DataFormat</code>中这个方法就使用了简单工厂</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312212636.png" style="zoom: 67%;" /></p>
<p>【2】对于数据库连接池，如业务需要连接数据库时，需要支持不同的数据库，如<code>dbcp</code>、<code>c3p0</code>、<code>druid</code>等等，这个时候数据库连接方式有限，而且比较固定不容易更改，所以可以尝试采用简单工厂模式来进行管理数据库连接对象。</p>
<p>【3】在<code>spring</code>源码中以Factory为后缀的方法或者类都用到工厂模式</p>
<h2 id="工厂方法模式">5、 工厂方法模式</h2>
<p>  工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个？将对象的创建与实例化延迟到子类，这样工厂的设计就符合”开闭原则“了，扩展时不必去修改原来的代码。</p>
<h3
id="工厂方法模式实现原理及uml图">（1）工厂方法模式实现原理及UML图</h3>
<p>  其实也很好理解，就是在简单工厂模式中，会存在判断语句（<code>if-else</code>或<code>switch</code>）的情况，相当于在工厂类中，一个生产类的方法实现了多个不同的功能，不符合类的单一职责原则；另外，如果现在产品出了M5系列的MBP电脑，那就需要再修改工厂的代码，不符合开闭原则。</p>
<p>  所以我们的解决方法也就呼之欲出。首先是想到把判断语句修改成功能方法，但对于一个工厂而言，即使把我的生产功能模块化，我还是需要知道，我应该生产哪个种类的产品，需要提示。</p>
<p>  所以我们进一步改造，将原来的工厂抽象成接口，然后为每一个系列构建各自的工厂子类，继承该接口。将对象的创建与实例化延迟到各自的工厂子类。</p>
<p>  最后，在使用时，我们可以利用多态的特性，用统一的工厂接口接收不同系列的工厂子类，然后用统一的接口方法创建出不同的系列。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313105034.png" style="zoom: 67%;" /></p>
<h3 id="实现代码demo">（2）实现代码demo：</h3>
<p>产品类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBP</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3</span> <span class="keyword">extends</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产 ----- &gt; MBPM3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4</span> <span class="keyword">extends</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产 ----- &gt; MBPM4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 工厂类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    MBP <span class="title function_">createMBP</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3Factory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MBP <span class="title function_">createMBP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4Factory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MBP <span class="title function_">createMBP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 用户类：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryFunctionCustomer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBPM3Factory</span>();</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m3</span> <span class="operator">=</span> factory.createMBP();</span><br><span class="line">        factory = <span class="keyword">new</span> <span class="title class_">MBPM4Factory</span>();</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m4</span> <span class="operator">=</span> factory.createMBP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优缺点-1">（3）优缺点</h3>
<p>其中，最主要的是 <code>Factory</code>
接口，以及接口中的<code>createMBP</code>抽象方法，通过这个方法来创建具体产品，这也是为什么叫工厂方法的原因。和简单工厂的静态方法不同，这里使用的非静态调用方式。而且可以发现没有简单工厂的条件判断逻辑。扩展性相对较好</p>
<ul>
<li>优点：完全实现开闭原则和类的单一职责原则，实现了可扩展和更复杂的层次接口。明确了职责，具有多态性，适用于任何实体类</li>
<li>缺点：如果业务增加，会使得系统中的类的个数成倍增加，提高了代码的复杂度。</li>
</ul>
<h3 id="工厂方法在实际中的应用">（4）工厂方法在实际中的应用</h3>
<p>如<code>Slf4j</code>中这个方法就使用了工厂方法模式</p>
<p>（1）Slf4j 的产品类 定义了一个抽象产品Logger： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
SubstituteLogger就是一种具体的产品
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313131210.png" style="zoom: 67%;" /></p>
<p>（2）Slf4j定义一个抽象工厂ILoggerFactory <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoggerFactory</span> &#123;</span><br><span class="line">    Logger <span class="title function_">getLogger</span><span class="params">(String var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
（3）具体工厂有很多，都实现了抽象工厂，这里展示其中一个SubstituteLoggerFactory
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313130552.png" style="zoom: 67%;" /></p>
<p>（4）SubstituteLoggerFactory工厂在生产SubstituteLogger具体产品时，做了一定的处理。而真正使用时，只需要通过getLogger方法就可以得到具体产品，这就是工厂方法模式的魅力。</p>
<h2 id="抽象工厂模式">6、 抽象工厂模式</h2>
<p>  在工厂方法模式中，我们使用一个工厂创建一个产品，一个具体工厂对应一个具体产品，但有时候我们需要一个工厂能有提供多个产品对象，而不是单一的对象，这个时候我们就需要使用抽象工厂模式。</p>
<blockquote>
<p>  代入到我们上面的栗子可以很好理解：现在的场景就是MBPM3它有自己的显示器和键盘、MBPM4它也有自己的显示器和键盘，但是我们之前的工厂方法，只给出了生产电脑的细节，但是生产电脑组件的细节却没给出。</p>
<p>  所以我们要优化我们的代码，让它拥有生产电脑组件的细节。怎么优化呢？其实我们会发现，MBPM3和MBPM4都需要显示器和键盘，只是型号不一样，
那按照工厂方法的角度来看，我们就可以把显示器和键盘先抽象成产品接口，
然后再创建对应产品类型。</p>
<p>  对于具体工厂而言，我们也只需要将原本生产电脑的接口，改成生产显示器和生产键盘。</p>
</blockquote>
<p>但在讲解抽象工厂模式之前，我们还需要先认识几个概念：</p>
<p>（1）产品等级结构：产品等级结构指的是产品的继承机构。例如一个空调抽象类，它有海尔空调、格力空调、美的空调等一系列的子类，那么这个空调抽象类和他的子类就构成了一个产品等级结构。</p>
<blockquote>
<p>放到上面的栗子，可以看成是
一个键盘抽象类，它有MBPM3键盘、MBPM4键盘等一系列子类，那么这个键盘抽象类和它的子类就构成了一个产品等级结构。</p>
</blockquote>
<p>（2）产品族：产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如，海尔工厂生产海尔空调、海尔冰箱，那么海尔空调则位于海尔产品族中。</p>
<blockquote>
<p>放到上面的栗子，可以看成 MBPM3工厂能生产 MBPM3键盘、MBPM3显示器，那么
MBPM3键盘和MBPM3显示器就位于 MBPM3 的产品族中。</p>
</blockquote>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313134033.png" style="zoom: 67%;" /></p>
<h3 id="抽象工厂模式实现原理及uml图">（1）
抽象工厂模式实现原理及UML图</h3>
<p>  抽象工厂模式主要用于创建相关对象的家族。当一个产品族中需要被设计在一起工作时，通过抽象工厂模式，能够保证客户端始终只使用同一个产品族中的对象；
并且通过隔离具体类的生成，使得客户端不需要明确指定具体生成类；所有具体工厂都实现了抽象工厂中定义的公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313163859.png" style="zoom: 67%;" /></p>
<h3 id="实现代码demo-1">（2）实现代码demo</h3>
<p>产品类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键盘</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">KeyBoard</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MBPM3键盘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3KB</span> <span class="keyword">implements</span> <span class="title class_">KeyBoard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3KB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产 ---------&gt; MBPM3键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MBPM4键盘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4KB</span> <span class="keyword">implements</span> <span class="title class_">KeyBoard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4KB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产 ---------&gt; MBPM4键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MBPM3显示器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3MT</span> <span class="keyword">implements</span> <span class="title class_">Monitor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3MT</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产 ---------&gt;  MBPM3显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MBPM4显示器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4MT</span> <span class="keyword">implements</span> <span class="title class_">Monitor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4MT</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产 ---------&gt;  MBPM4显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    Monitor <span class="title function_">createMonitor</span><span class="params">()</span>;</span><br><span class="line">    KeyBoard <span class="title function_">createKeyBoard</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3Factory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Monitor <span class="title function_">createMonitor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3MT</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> KeyBoard <span class="title function_">createKeyBoard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3KB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4Factory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Monitor <span class="title function_">createMonitor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4MT</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> KeyBoard <span class="title function_">createKeyBoard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4KB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryCustomer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">m3Factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBPM3Factory</span>();</span><br><span class="line">        m3Factory.createKeyBoard();</span><br><span class="line">        m3Factory.createMonitor();</span><br><span class="line"></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">m4Factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBPM4Factory</span>();</span><br><span class="line">        m4Factory.createMonitor();</span><br><span class="line">        m4Factory.createKeyBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象工厂和工厂方法">（3）抽象工厂和工厂方法</h3>
<p>【1】
工厂方法只有一个抽象产品类和一个抽象工厂类，但是可以派生出多个具体产品类和具体工厂类，每个具体工厂类只能创建一个具体产品类的实例。</p>
<p>【2】抽象工厂模式拥有多个抽象产品类（产品族）和一个抽象工厂类，每个抽象产品类可以派生出多个具体产品类；抽象工厂类也可以派生出多个具体工厂类，同时每个具体工厂类可以创建多个具体产品类的实例。</p>
<h3 id="优缺点-2">（4）优缺点</h3>
<ul>
<li>增加分组比较容易，并且能大大减少工厂类的数量</li>
<li>因为分组，所有分组中的产品扩展比较困难，比如新增鼠标，那么需要动的类就有
<code>Factory</code>、<code>MBPM3Factory</code>、<code>MBPM4Factory</code>，几乎所有工厂类</li>
</ul>
<h3 id="抽象工厂在实际中的应用">（5）抽象工厂在实际中的应用</h3>
<p>  抽象工厂在 <code>spring</code> 中的应用，我们查看
<code>spring</code> 源码可以看到，BeanFactory 是用于管理 Bean
的一个工厂，所有工厂都是 BeanFactory 的子类。 这样我们可以通过 IOC
容器来管理访问 Bean，根据不同的策略调用 getBean()
方法，从而获得具体对象。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313163510.png" style="zoom: 67%;" /></p>
<p>   BeanFactory 的子类主要有
ClassPathXmlApplicationContext、XmlWebApplicationContext、StaticWebApplicationContext、StaticApplicationContext。在
Spring 中，DefaultListableBeanFactory 实现了所有工厂的公共逻辑。</p>
<h2 id="总结">7、总结</h2>
<p>  无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p>
<p>  所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到即可。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2025/03/14/DesignPattern/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一引言">一、引言</h1>
<p>  在软件开发中，也会存在一些构造非常复杂的对象，这些对象拥有一系列的成员属性，这些成员属性有些是基本数据类型，有些是引用类型，总之就是一句话，这个对象的构建比较复杂。
对于用户而言，用户总是希望在使用对象时足够简单。另外，除了这个构建的过程，可能用户会忘记某些成员属性。所以我们希望能用有这样一个对象；直接告诉它需要的对象名或对象类型。它自动返回一个完成对象实例。
这也是我们今天要将的建造者模式的设计动机：返回给客户端一个完整的产品对象，而客户端无需关心该对象所包含的额外属性和组建方式。</p>
<h1 id="二什么是建造者模式">二、什么是建造者模式？</h1>
<p>  建造者模式将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，从而更精确控制复杂对象的产生过程；
通过隔离复杂对象的构建与使用，也就是将产品的创建与产品本身分离开来，使得同样的构建过程可以创建不同的对象；并且每个具体建造者都相互独立，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</p>
<blockquote>
<p>延续我们之前的栗子，还是生产MBP电脑的问题，但是会多一个MBP前台角色。场景是这样的：</p>
<p>现在旺仔去MBP门店买一台MBP电脑，在门店下好订单后，旺仔会把订单交给MBP前台，而MBP前台的角色如何通过订单与MBP公司配合生产出对应的产品就是今天要将的建造者模式。</p>
<p>这里大概简单描述一下：首先MBP前台会拿到旺仔的订单，订单上会有相关的电脑品牌信息，以及电脑所需的配件，然后MBP前台就会去指挥对应品牌的建造者，先生产什么配件，再生产什么配件，
最后把MBP前台会拿到完整的MBP电脑，交付到旺仔手上。</p>
</blockquote>
<p>  再以一个抽象类图讲一下整个实现原理： <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314112839.png" /></p>
<blockquote>
<p>产品角色 Product: 被构造的复杂对象。
不限于用类进行声明，当一个产品有多个系列时，可以将产品抽象成基类，分别创建不同系列的类去继承它</p>
<p>抽象创建者 Builder: 相当于建筑蓝图，声明了创建 Product
对象的各个部件指定的抽象接口</p>
<p>具体创建者 ConcreteBuilder:
实现Bulider抽象接口，构造和装配各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。</p>
<p>指挥者 Director： 构建一个使用 Builder
接口的对象。主要有两个作用，一个是隔离用户与对象的生产过程，二是负责控制产品对象的生成过程。</p>
</blockquote>
<h1 id="三建造者优缺点">三、建造者优缺点</h1>
<p><strong>（1）优点：</strong></p>
<ol type="1">
<li><strong>封装性好</strong> : 创建 和 使用 分离;</li>
<li><strong>扩展性好</strong> : 建造类之间 相互独立 , 在
一定程度上解耦;</li>
</ol>
<p><strong>（2）缺点：</strong></p>
<ol type="1">
<li><strong>增加类数量</strong> : 产生多余的 Builder 对象 ;</li>
<li><strong>内部修改困难</strong> : 如果 产品内部发生变化 ,
建造者也要相应修改 ;</li>
</ol>
<h1 id="四代码实现">四、代码实现</h1>
<h2 id="uml图">（1）UML图</h2>
<p>  
这里的代码实现还是延续之前将工厂模式的MBP电脑生产的栗子。现在的场景是这样的，MBP公司有不同系列的MBP电脑，MBP公司前台可以根据客户订购的订单，在后台生产这些电脑，返回给客户一个完成的电脑。
其中MBP电脑的组件主要包含键盘和显示器。程序的UML图如下所示： <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314114220.png" /></p>
<h2 id="代码demo">（2）代码demo</h2>
<p><strong>产品类：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="comment">// 1. 抽象产品</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String keyBoard;</span><br><span class="line">    <span class="keyword">private</span> String monitor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 具体产品：MBPM3</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3</span> <span class="keyword">extends</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4</span> <span class="keyword">extends</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>建造者：</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建者</span></span><br><span class="line"><span class="comment">// 1. 抽象构建者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBulider</span> &#123;</span><br><span class="line">    <span class="type">MBP</span> <span class="variable">mbp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBP</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildKeyBoard</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildMonitor</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> MBP <span class="title function_">getMbp</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mbp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 具体构建者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3Builder</span> <span class="keyword">extends</span> <span class="title class_">AbstractBulider</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildKeyBoard</span><span class="params">()</span> &#123;</span><br><span class="line">        mbp.setKeyBoard(<span class="string">&quot;MBPM3键盘&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;构建 ---------&gt;   MBPM3键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMonitor</span><span class="params">()</span> &#123;</span><br><span class="line">        mbp.setKeyBoard(<span class="string">&quot;MBPM3显示器&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;构建 ---------&gt;   MBPM3显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4Builder</span> <span class="keyword">extends</span> <span class="title class_">AbstractBulider</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildKeyBoard</span><span class="params">()</span> &#123;</span><br><span class="line">        mbp.setKeyBoard(<span class="string">&quot;MBPM4键盘&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;构建 ---------&gt;   MBPM4键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMonitor</span><span class="params">()</span> &#123;</span><br><span class="line">        mbp.setKeyBoard(<span class="string">&quot;MBPM4显示器&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;构建 ---------&gt;   MBPM4显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>指挥者：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractBulider abstractBulider;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAbstractBulider</span><span class="params">(AbstractBulider abstractBulider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.abstractBulider = abstractBulider;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MBP <span class="title function_">construct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.abstractBulider.buildKeyBoard();</span><br><span class="line">        <span class="built_in">this</span>.abstractBulider.buildMonitor();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.abstractBulider.getMbp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>客户端：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指挥者</span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line">        <span class="comment">// 还得有订单</span></span><br><span class="line">        <span class="type">MBPM3Builder</span> <span class="variable">mbpm3Builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBPM3Builder</span>();</span><br><span class="line">        <span class="comment">// 把订单给指挥者</span></span><br><span class="line">        director.setAbstractBulider(mbpm3Builder);</span><br><span class="line">        <span class="comment">// 构建订单</span></span><br><span class="line">        director.construct();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出：</span></span><br><span class="line"><span class="comment">         * 构建 ---------&gt;   MBPM3键盘</span></span><br><span class="line"><span class="comment">         * 构建 ---------&gt;   MBPM3显示器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1
id="五建造者模式和工厂模式的区别">五、建造者模式和工厂模式的区别</h1>
<ul>
<li>注意点不同： 建造者模式更注重于 方法的调用顺序； 工厂模式注重于
创建产品，不关心方法的调用顺序</li>
<li>创建对象粒度不同：
建造者模式可以创建复杂的产品，由各种复杂的部件组成；
工厂模式创建出来的都是部件相同的实例对象。</li>
</ul>
<h1 id="六总结">六、总结</h1>
<p>1、建造者模式是将一个复杂对象的创建过程给封装起来，客户只需要知道可以利用对象名或者类型就能够得到一个完整的对象实例，而不需要关心对象的具体创建过程。</p>
<p>2、建造者模式将对象的创建过程与对象本身隔离开了，使得细节依赖于抽象，符合依赖倒置原则。可以使用相同的创建过程来创建不同的产品对象。</p>
<h2 id="建造者模式的应用场景">建造者模式的应用场景</h2>
<p>1、需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p>
<p>2、隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>
<p>但建造者模式的缺陷是要求创建的产品具有较多的共同点、组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式。
同时如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing基础算法板子</title>
    <url>/2024/12/14/Algorithm/Acwing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="第一讲-基础算法">第一讲 基础算法</h1>
<h2 id="快速排序">1. 快速排序</h2>
<h3 id="快速排序-1">1.1 <a
href="https://www.acwing.com/problem/content/787/">快速排序</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">do</span> ++i; <span class="keyword">while</span> (arr[i] &lt; base);</span><br><span class="line">		<span class="keyword">do</span> --j; <span class="keyword">while</span> (arr[j] &gt; base);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, l, j);</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第k个数">1.2 <a
href="https://www.acwing.com/problem/content/788/">第K个数</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> arr[l];</span><br><span class="line">	<span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">do</span> ++i; <span class="keyword">while</span> (arr[i] &lt; base);</span><br><span class="line">		<span class="keyword">do</span> --j; <span class="keyword">while</span> (arr[j] &gt; base);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= j) <span class="keyword">return</span> <span class="built_in">quickSort</span>(arr, l, j, k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickSort</span>(arr, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">2.归并排序</h2>
<h3 id="归并排序-1">2.1 <a
href="https://www.acwing.com/problem/content/789/">归并排序</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, temp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid<span class="number">+1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[j]) temp[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) temp[k++] = arr[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = l, m = <span class="number">0</span>; t &lt;= r; ++t, ++m) arr[t] = temp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆序对的数量">2.1 <a
href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, temp[N];</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			res += mid - i + <span class="number">1</span>;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) temp[k++] = arr[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = l, m = <span class="number">0</span>; t &lt;= r; ++t, ++m) arr[t] = temp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分">3. 二分</h2>
<h3 id="数的范围">3.1 <a
href="https://www.acwing.com/problem/content/791/">数的范围</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, q, num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &gt;= num) r = mid;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (num != arr[l]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, l);</span><br><span class="line">		l = <span class="number">0</span>;   r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &lt;= num) l = mid;</span><br><span class="line">			<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数的三次方根">3.2 <a
href="https://www.acwing.com/problem/content/792/">数的三次方根</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">	<span class="type">double</span> l = <span class="number">-100000</span>, r = <span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">while</span> (r-l&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">		<span class="type">double</span> num = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (num * num * num &gt; n) r = num;</span><br><span class="line">		<span class="keyword">else</span> l = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度">4.高精度</h2>
<h3 id="高精度加法">4.1 <a
href="https://www.acwing.com/problem/content/793/">高精度加法</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> A[N], B[N], C[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		t += A[i] + B[i];</span><br><span class="line">		C[++len] = t % <span class="number">10</span>;</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t) C[++len] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)A[++cnt1] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)B[++cnt2] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">add</span>(<span class="built_in">max</span>(cnt1, cnt2));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; --i)cout &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度减法">4.2 <a
href="https://www.acwing.com/problem/content/794/">高精度减法</a></h3>
<p>待补充~~~ ### 4.3 <a
href="https://www.acwing.com/problem/content/795/">高精度乘法</a>
待补充~~~ ### 4.4 <a
href="https://www.acwing.com/problem/content/796/">高精度除法</a>
待补充~~~</p>
<h2 id="前缀和与差分">5. 前缀和与差分</h2>
<h3 id="前缀和">5.1 <a
href="https://www.acwing.com/problem/content/797/">前缀和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);     arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[r] - arr[l - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子矩阵的和">5.2 <a
href="https://www.acwing.com/problem/content/798/">子矩阵的和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N], n, m, q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i][j]);</span><br><span class="line">			arr[i][j] = arr[i][j] + arr[i - <span class="number">1</span>][j] + arr[i][j - <span class="number">1</span>] - arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[x2][y2] - arr[x1 - <span class="number">1</span>][y2] - arr[x2][y1 - <span class="number">1</span>] + arr[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分">5.3 <a
href="https://www.acwing.com/problem/content/799/">差分</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, m, num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	arr[l] += c;</span><br><span class="line">	arr[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);   <span class="built_in">add</span>(i, i, num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		<span class="built_in">add</span>(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分矩阵">5.4 <a
href="https://www.acwing.com/problem/content/description/800/">差分矩阵</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N], n, m, q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	arr[x1][y1] += c;</span><br><span class="line">	arr[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">	arr[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">	arr[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num, x1, y1, x2, y2;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">			<span class="built_in">add</span>(i, j, i, j, num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;num);</span><br><span class="line">		<span class="built_in">add</span>(x1, y1, x2, y2, num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			arr[i][j] = arr[i][j] + arr[i - <span class="number">1</span>][j] + arr[i][j - <span class="number">1</span>] - arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针算法">6. 双指针算法</h2>
<h3 id="最长连续不重复子序列">6.1 <a
href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, s[N], res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">		s[arr[i]]++;</span><br><span class="line">		<span class="keyword">while</span> (s[arr[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			s[arr[j]]--;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的目标和">6.2 <a
href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, x, A[N], B[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[j]);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] + B[j] == x) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (A[i] + B[j] &gt; x) j--;</span><br><span class="line">		<span class="keyword">else</span> i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">6.3 <a
href="https://www.acwing.com/problem/content/2818/">判断子序列</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, A[N], B[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[j]);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] == B[j]) ++i;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == n) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位运算">7. 位运算</h2>
<h3 id="二进制中1的个数">7.1 二进制中1的个数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNumber</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num &amp; <span class="number">1</span>) res++;</span><br><span class="line">		num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">		<span class="type">int</span> ans = <span class="built_in">getNumber</span>(num);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化">8.离散化</h2>
<h3 id="区间和">8.1 <a
href="https://www.acwing.com/problem/content/804/">区间和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m,s[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;</span><br><span class="line">vector&lt;PII&gt;add,query;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x)r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();++i)s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间合并">9.区间合并</h2>
<h3 id="区间合并-1">9.1 <a
href="https://www.acwing.com/problem/content/805/">区间合并</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt;segs;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp; segs)</span> </span>&#123;</span><br><span class="line">	vector&lt;PII&gt;res;</span><br><span class="line">	<span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item : segs) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ed &lt; item.first) &#123;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="number">-2e9</span>)res.<span class="built_in">push_back</span>(&#123; st,ed &#125;);</span><br><span class="line">			st = item.first;   ed = item.second;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, item.second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st != <span class="number">-2e9</span>)res.<span class="built_in">push_back</span>(&#123; st,ed &#125;);</span><br><span class="line">	segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		segs.<span class="built_in">push_back</span>(&#123; l,r &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge</span>(segs);</span><br><span class="line">	cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="第二讲-数据结构">第二讲 数据结构</h1>
<h2 id="单链表">1. 单链表</h2>
<h3 id="单链表-1">1.1 <a
href="https://www.acwing.com/problem/content/828/">单链表</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], h = <span class="number">-1</span>, ne[N], idx = <span class="number">0</span>, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">headInsert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = h;</span><br><span class="line">	h = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNum</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	ne[k - <span class="number">1</span>] = ne[ne[k - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addk</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	e[idx] = num;  ne[idx] = ne[k - <span class="number">1</span>];</span><br><span class="line">	ne[k - <span class="number">1</span>] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="type">int</span> x, k;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;H&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">headInsert</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) h = ne[h];</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">deleteNum</span>(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			<span class="built_in">addk</span>(k, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = h; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双链表">2.双链表</h2>
<h3 id="双链表-1">2.1 <a
href="https://www.acwing.com/problem/content/829/">双链表</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> l[N], r[N], e[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	idx = <span class="number">2</span>;</span><br><span class="line">	l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert_right</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	r[idx] = r[k];</span><br><span class="line">	l[idx] = k;</span><br><span class="line">	l[r[k]] = idx;</span><br><span class="line">	r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	r[l[k]] = r[k];</span><br><span class="line">	l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Inite</span>();</span><br><span class="line">	string op;</span><br><span class="line">	<span class="type">int</span> m, k, x;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(<span class="number">0</span>, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(l[<span class="number">1</span>], x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			<span class="built_in">remove</span>(k<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">&quot;IL&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(l[k<span class="number">+1</span>], x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IR&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(k<span class="number">+1</span>, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈">3. 栈</h2>
<h3 id="模拟栈">3.1 <a
href="https://www.acwing.com/problem/content/830/">模拟栈</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tt &lt; hh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	arr[++tt] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">	tt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m, num;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="built_in">push</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; arr[tt] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表达式求值">3.2 <a
href="https://www.acwing.com/problem/content/3305/">表达式求值</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = num.<span class="built_in">top</span>();  num.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="type">int</span> b = num.<span class="built_in">top</span>();  num.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="type">char</span> c = op.<span class="built_in">top</span>();   op.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)num.<span class="built_in">push</span>(a + b);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)num.<span class="built_in">push</span>(b - a);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)num.<span class="built_in">push</span>(b * a);</span><br><span class="line">	<span class="keyword">else</span> num.<span class="built_in">push</span>(b / a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123; &#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">auto</span> c = str[i];</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">			<span class="type">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j])) &#123;</span><br><span class="line">				x = x * <span class="number">10</span> + str[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i = j - <span class="number">1</span>;</span><br><span class="line">			num.<span class="built_in">push</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)<span class="built_in">eval</span>();</span><br><span class="line">			op.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c])<span class="built_in">eval</span>();</span><br><span class="line">			op.<span class="built_in">push</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (op.<span class="built_in">size</span>())<span class="built_in">eval</span>();</span><br><span class="line">	cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">4. 队列</h2>
<h3 id="模拟队列">4.1 <a
href="https://www.acwing.com/problem/content/831/">模拟队列</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hh &gt; tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	arr[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">	hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string op;   <span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">push</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; arr[hh] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈">5. 单调栈</h2>
<h3 id="单调栈-1">5.1 <a
href="https://www.acwing.com/problem/content/832/">单调栈</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, st[N], tt = <span class="number">-1</span>, num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		<span class="keyword">while</span> (tt &gt;= <span class="number">0</span> &amp;&amp; num &lt;= st[tt]) --tt;</span><br><span class="line">		<span class="keyword">if</span> (tt &gt;= <span class="number">0</span>) cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		st[++tt] = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列">6. 单调队列</h2>
<h3 id="滑动窗口">6.1 <a
href="https://www.acwing.com/problem/content/156/">滑动窗口</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], q[N], n, k, hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">		<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; arr[q[tt]] &gt;= arr[i]) tt--;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[q[hh]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	hh = <span class="number">0</span>;  tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; arr[q[tt]] &lt;= arr[i]) tt--;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[q[hh]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp">7. KMP</h2>
<h3 id="kmp字符串">7.1 <a
href="https://www.acwing.com/problem/content/833/">KMP字符串</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> n, m, ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d %s&quot;</span>, &amp;n, p + <span class="number">1</span>, &amp;m, s + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 求next 数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (p[j + <span class="number">1</span>] == p[i]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// KMP</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">			j = ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="trie">8. Trie</h2>
<h3 id="trie字符串统计">8.1 Trie字符串统计</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], idx = <span class="number">0</span>, cnt[N], x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> s = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][s]) son[p][s] = ++idx;</span><br><span class="line">		p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> s = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][s]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	string str, op;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; str;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) <span class="built_in">Insert</span>(str);</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="built_in">Query</span>(str) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大异或对">8.2 <a
href="https://www.acwing.com/problem/content/145/">最大异或对</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], idx = <span class="number">0</span>, arr[N], res = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">		<span class="type">int</span> s = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][s]) son[p][s] = ++idx;</span><br><span class="line">		p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">		<span class="type">int</span> s = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (son[p][!s]) &#123;</span><br><span class="line">			ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">			p = son[p][!s];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">		<span class="built_in">Insert</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(arr[i]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集">9. 并查集</h2>
<h3 id="合并集合">9.1 <a
href="https://www.acwing.com/problem/content/838/">合并集合</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, a, b, path[N];</span><br><span class="line">string op;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> path[x] = <span class="built_in">find</span>(path[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tx = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> ty = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (tx != ty) path[tx] = ty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) path[i] = i;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;M&quot;</span>)<span class="built_in">merge</span>(a, b);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> ta = <span class="built_in">find</span>(a), tb = <span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span> (ta == tb) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连通块中点的数量">9.2 <a
href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> path[a] = <span class="built_in">find</span>(path[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ta = <span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> tb = <span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span> (ta == tb) <span class="keyword">return</span>;</span><br><span class="line">	path[ta] = tb;</span><br><span class="line">	cnt[tb] = cnt[ta] + cnt[tb];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		path[i] = i;   cnt[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="built_in">merge</span>(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Q1&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="type">int</span> ta = <span class="built_in">find</span>(a);</span><br><span class="line">			<span class="type">int</span> tb = <span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span> (ta == tb) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; a;</span><br><span class="line">			<span class="type">int</span> ta = <span class="built_in">find</span>(a);</span><br><span class="line">			cout &lt;&lt; cnt[ta] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="食物链">9.3 <a
href="https://www.acwing.com/problem/content/242/">食物链</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pre[N], dis[N], n, m, res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x != pre[x]) &#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">find</span>(pre[x]);</span><br><span class="line">		dis[x] += dis[pre[x]];</span><br><span class="line">		pre[x] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = i;</span><br><span class="line">	<span class="type">int</span> d, x, y;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;</span><br><span class="line">			res++;  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> tx = <span class="built_in">find</span>(x), ty = <span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tx == ty &amp;&amp; (dis[x] - dis[y]) % <span class="number">3</span>) res++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tx != ty) &#123;</span><br><span class="line">				pre[tx] = ty;</span><br><span class="line">				dis[tx] = dis[y] - dis[x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (tx == ty &amp;&amp; (dis[x] - dis[y] - <span class="number">1</span>) % <span class="number">3</span>) res++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tx != ty) &#123;</span><br><span class="line">				pre[tx] = ty;</span><br><span class="line">				dis[tx] = dis[y] - dis[x] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆">10. 堆</h2>
<h3 id="堆排序">10.1 <a
href="https://www.acwing.com/problem/content/840/">堆排序</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> h[N],len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=len&amp;&amp;h[t]&gt;h[u*<span class="number">2</span>])t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=len&amp;&amp;h[t]&gt;h[u*<span class="number">2</span><span class="number">+1</span>])t = u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t],h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    len = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i;--i)<span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[len];</span><br><span class="line">        len--;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟堆">10.2 <a
href="https://www.acwing.com/problem/content/841/">模拟堆</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> h[N];   <span class="comment">//堆</span></span><br><span class="line"><span class="type">int</span> ph[N];  <span class="comment">//存放第k个插入点的下标</span></span><br><span class="line"><span class="type">int</span> hp[N];  <span class="comment">//存放堆中点的插入次序</span></span><br><span class="line"><span class="type">int</span> cur_size;   <span class="comment">//size 记录的是堆当前的数据多少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系</span></span><br><span class="line"><span class="comment">//之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序</span></span><br><span class="line"><span class="comment">//从而我们需要对应到原先第K个堆中元素</span></span><br><span class="line"><span class="comment">//如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 </span></span><br><span class="line"><span class="comment">//h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">swap</span>(h[u],h[v]); </span><br><span class="line">     <span class="built_in">swap</span>(hp[u],hp[v]);     </span><br><span class="line">     <span class="built_in">swap</span>(ph[hp[u]],ph[hp[v]]);            </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=cur_size&amp;&amp;h[t]&gt;h[u*<span class="number">2</span>]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=cur_size&amp;&amp;h[t]&gt;h[u*<span class="number">2</span><span class="number">+1</span>])  t=u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u/<span class="number">2</span>&gt;<span class="number">0</span>&amp;&amp;h[u]&lt;h[u/<span class="number">2</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,u/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">up</span>(u&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;      <span class="comment">//m用来记录插入的数的个数</span></span><br><span class="line">                <span class="comment">//注意m的意义与cur_size是不同的 cur_size是记录堆中当前数据的多少</span></span><br><span class="line">                <span class="comment">//对应上文 m即是hp中应该存的值</span></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            m++;</span><br><span class="line">            h[++cur_size]=x;</span><br><span class="line">            ph[m]=cur_size;</span><br><span class="line">            hp[cur_size]=m;</span><br><span class="line">            <span class="comment">//down(size);</span></span><br><span class="line">            <span class="built_in">up</span>(cur_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;PM&quot;</span>)    cout&lt;&lt;h[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;DM&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cur_size);</span><br><span class="line">            cur_size--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="type">int</span> u=ph[k];                <span class="comment">//这里一定要用u=ph[k]保存第k个插入点的下标</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(u,cur_size);          <span class="comment">//因为在此处heap_swap操作后ph[k]的值已经发生 </span></span><br><span class="line">            cur_size--;                    <span class="comment">//如果在up,down操作中仍然使用ph[k]作为参数就会发生错误</span></span><br><span class="line">            <span class="built_in">up</span>(u);</span><br><span class="line">           <span class="built_in">down</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            h[ph[k]]=x;                 <span class="comment">//此处由于未涉及heap_swap操作且下面的up、down操作只会发生一个所以</span></span><br><span class="line">            <span class="built_in">down</span>(ph[k]);                <span class="comment">//所以可直接传入ph[k]作为参数</span></span><br><span class="line">            <span class="built_in">up</span>(ph[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表">11. 哈希表</h2>
<h3 id="模拟散列表">11.1 <a
href="https://www.acwing.com/problem/content/842/">模拟散列表</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+3</span>;</span><br><span class="line"><span class="type">int</span> e[N],idx = <span class="number">0</span>,ne[N],h[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N+N)%N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k];i!=<span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> x, n;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>( n-- )&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;I&#x27;</span>)<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(x))cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串哈希">11.2 <a
href="https://www.acwing.com/problem/content/843/">字符串哈希</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ull h[N],p[N];</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,str<span class="number">+1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">        h[i] = h[i<span class="number">-1</span>]*P+str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2))<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>C++</tag>
        <tag>算法板子</tag>
      </tags>
  </entry>
  <entry>
    <title>开闭原则</title>
    <url>/2025/03/13/DesignPattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="开闭原则">开闭原则</h1>
<h2 id="一定义">一、定义</h2>
<p>软件实体对扩展开放，对修改关闭。也就是说，在实际业务开发中，应该通过扩展来实现业务需求和变化，而不是修改已有代码来实现变化。</p>
<h2 id="二问题由来">二、问题由来</h2>
<p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<h2 id="三解决方案">三、解决方案：</h2>
<p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</p>
<blockquote>
<p>举个栗子：
假如现在有一个普通商品类，继承了商品的接口，然后实现了一些普通商品方法。这时候业务提出新的需求，需要为商品打折扣，但是折扣不是每个商品都会有。我们现在要实现这个业务需求，应该怎么完成？<br>
1. 在商品接口添加折扣功能<br> 2.
新建折扣商品类，继承普通商品类，再新建折扣方法。<br>
毫无疑问，肯定选择第二种方案。为什么？因为如果使用了第一种方案，那么所有继承了商品接口的类都得实现新增的折扣功能，这就需要修改原来的代码，这是非常不妥的。
而第二种，我们只需要在新定义的折扣方法上接收折扣力度的参数，就能实现折扣商品具备获得原始价格和折扣价格的能力</p>
</blockquote>
<h2 id="四代码demo">四、代码demo：</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGood</span> &#123;</span><br><span class="line">    String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    Double <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通商品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NormalGood</span> <span class="keyword">implements</span> <span class="title class_">IGood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NormalGood</span><span class="params">(String id, String name, Double price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折扣商品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiscountGood</span> <span class="keyword">extends</span> <span class="title class_">NormalGood</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscountGood</span><span class="params">(String id, String name, Double price)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得商品折扣价格</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getDisCountPrice</span><span class="params">(Double discount)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() * discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五优点">五、优点</h2>
<p>提高软件系统的可复用性及可维护性;</p>
<h2 id="六实际应用">六、实际应用</h2>
<p>开闭原则是面向对象设计中，最基础的设计原则，开闭原则的核心思想是面向抽象编程，而不是面向实现编程。换句话说，开闭原则无非想表达的是：<strong>用抽象构建框架，用实现扩展细节</strong>。
因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>开闭原则</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2025/03/14/Java/JUC/</url>
    <content><![CDATA[<h1 id="一进程与线程">一、进程与线程</h1>
<h2 id="本章内容">1、本章内容</h2>
<p>本章主要描述JUC编程的基础知识，即计算机操作系统的一些基础概念，包括进程、线程等
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314133118.png" /></p>
<h2 id="进程与线程">2、进程与线程</h2>
<h3 id="进程">【1】进程</h3>
<h4 id="引言">（1）引言</h4>
<p>  在计算机中，程序是由指令和数据组成的。但是指令要运行，数据要读写，就必须将指令加载到CPU，数据加载到内存。在指令运行期间还需要用到磁盘、网络设备。
这些操作都是由进程来完成，进程就是用来加载指令、管理内存、管理IO的实例。当一个程序被运行，需要开启一个进程，将程序的代码从磁盘加载至内存。</p>
<h4 id="定义">（2）定义</h4>
<p>  进程是一个具有一定独立功能的程序，关于某个数据集合的一次运动活动。简单点来说，进程就是一段程序的执行过程。
它是操作系统动态执行的基本单元，在传统的操作系统中，进程是操作系统资源分配的基本单元，</p>
<h4 id="进程的组成">（3）进程的组成</h4>
<p>进程（进程实体）是由程序段、数据段、进程控制块（PCB）三部分组成。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314141759.png" />
##### 程序段 程序代码存放在这里 ##### 数据段
程序运行时，使用、产生的运算数据。如全局变量、局部变量、宏定义的常量等就存放在数据段内
##### 进程控制块PCB
操作系统通过进程控制块PCB来管理进程，因此进程控制块PCB中应该包含操作系统对其管理所需的各种信息。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314142517.png" /></p>
<h4 id="进程的特征">（4）进程的特征</h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314143046.png" /></p>
<h3 id="线程">【2】线程</h3>
<h4 id="引言-1">（1）引言</h4>
<p>  在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。
任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p>
<p>  后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p>
<h4 id="定义-1">（2）定义</h4>
<p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。</p>
<h4 id="线程的组成">（3）线程的组成</h4>
<p>线程由线程ID（TID）、线程名称、线程优先级、线程状态等属性组成。</p>
<h2 id="并发与并行">3、并发与并行</h2>
<h2 id="应用">4、应用</h2>
<h2 id="本章小结">5、本章小结</h2>
<h1 id="二java线程">二、Java线程</h1>
<h2 id="本章内容-1">1、本章内容</h2>
<p>本章主要描述在Java中，创建和运行线程等相关知识 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314133602.png" /></p>
<h2 id="创建与运行线程">2、创建与运行线程</h2>
<h2 id="查看线程">3、查看线程</h2>
<h2 id="线程api">4、线程API</h2>
<h2 id="线程状态">5、线程状态</h2>
<h2 id="本章小结-1">6、本章小结</h2>
<h1 id="三共享模型之管程">三、共享模型之管程</h1>
<h2 id="本章内容-2">1、本章内容</h2>
<p>本章主要描述管程的相关知识 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314134024.png" /></p>
<h2 id="共享问题">2、共享问题</h2>
<h2 id="synchronized">3、synchronized</h2>
<h2 id="线程安全分析">4、线程安全分析</h2>
<h2 id="monitor">5、Monitor</h2>
<h2 id="waitnotify">6、wait/notify</h2>
<h2 id="线程状态转换">7、线程状态转换</h2>
<h2 id="活跃性">8、活跃性</h2>
<h2 id="lock">9、Lock</h2>
<h2 id="本章小结-2">10、本章小结</h2>
<h1 id="四共享模型之内存">四、共享模型之内存</h1>
<h2 id="本章内容-3">1、本章内容</h2>
<p>本章主要介绍 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314134611.png" /></p>
<h2 id="java内存模型">2、Java内存模型</h2>
<h2 id="可见性">3、可见性</h2>
<h2 id="有序性">4、有序性</h2>
<h2 id="本章小结-3">5、本章小结</h2>
<h1 id="五共享模型之无锁">五、共享模型之无锁</h1>
<h2 id="本章内容-4">1、本章内容</h2>
<p>本章主要介绍 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314134934.png" /></p>
<h2 id="cas与volatile">2、CAS与volatile</h2>
<h2 id="原子整数">3、原子整数</h2>
<h2 id="原子引用">4、原子引用</h2>
<h2 id="原子累加器">5、原子累加器</h2>
<h2 id="unsafe">6、Unsafe</h2>
<h2 id="本章小结-4">7、本章小结</h2>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JUC</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试</title>
    <url>/2025/01/04/Java/Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="一美团">一、美团</h1>
<h1 id="二字节">二、字节</h1>
<h1 id="三momenta">三、Momenta</h1>
<h2 id="一http请求报文解析的过程">一、HTTP请求报文解析的过程</h2>
<h3 id="http基本概念">1. HTTP基本概念</h3>
<p>HTTP是指超文本传输协议，全称HyperText Transfer
Protocol，它的名称由三部分组成</p>
<p>超文本：指的不仅仅限于文本的多样性，还包括视频、图片等</p>
<p>传输：表示数据的传输</p>
<p>协议：表示通信双方的在传输过程中约定俗成的规范</p>
<h3 id="http请求位于计算机网络的哪一层呢">2.
HTTP请求位于计算机网络的哪一层呢？</h3>
<p>应用层。
在网络通信中，应用层是最接近用户的一层，它负责为特定的网络应用提供服务和功能。应用层协议定义了数据交换的规则和格式，以便不同的应用程序能够相互通信和交换信息。</p>
<h3 id="http请求的整个流程">3. HTTP请求的整个流程</h3>
<h4 id="总体流程"><strong>（1）总体流程</strong></h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250104142003.png" /></p>
<h4 id="实际例子"><strong>（2）实际例子</strong></h4>
<p>以一个实际的案例，来深入探讨一下HTTP的请求响应过程，假设我们访问的网址是：https://baidu.com</p>
<p>当我们在浏览器地址栏输入该网址并按下回车键后，浏览器会进行如下操作：</p>
<ol type="1">
<li>首先浏览器会使用DNS域名解析协议，解析输入的网站域名，然后获取实际服务器的ip地址返回给浏览器。</li>
<li>浏览器接收到实际的服务器ip地址后，会随机选择一个可用的客户端端口，与服务器默认的80端口建立TCP连接（3次握手）。在客户端和服务器之间会建立一个套接字用于通信。</li>
<li>接着浏览器会通过套接字向服务器发送一个HTTP请求，该请求会携带客户端想要的对象的相关信息。</li>
<li>服务器通过套接字接收到这个请求报文后，会对请求进行解析，并从存储器(RAM或磁盘)中检索出请求的对象。然后，服务器会将检索到的对象封装到HTTP响应报文中，并通过套接字发送给客户端。</li>
<li>客户端会从响应报文中提取出响应的文件，并对HTML文件进行检查。然后，客户端会循环检查报文中的其他内部对象。在检查完成后，HTTP客户端会将相应的资源通过显示器呈现给用户。</li>
<li>当服务器响应完客户端请求后，会主动通知TCP断开连接，跟浏览器进行4次挥手最终断开TCP连接。</li>
</ol>
<h3 id="双向连接">4. 双向连接</h3>
<p>​ 从上面的流程描述可以看到，HTTP
协议是一种单向无状态协议，这意味着只有客户端向服务器端发送请求时，服务器才会响应并返回数据给客户端。然而，服务器并不会主动发送HTTP请求返回给客户端。因此，单向通信有对应的双向通信方式，通过某些技术和扩展，HTTP协议也可以实现类似于双向通信的效果。例如，通过长轮询（Long
Polling），客户端可以发送一个请求并保持连接打开，直到服务器有新的数据可用时才返回响应。这种方式使得服务器能够向客户端推送数据，从而实现了类似于双向通信的效果。</p>
<p>​
WebSockets是一种全双工通信协议，它允许客户端和服务器之间进行双向通信。通过建立持久的连接，WebSockets实现了更实时的双向通信。</p>
<h2 id="二redis">二、Redis</h2>
<h3 id="基本数据类型">1. 基本数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">String</td>
<td style="text-align: center;">hello world</td>
</tr>
<tr>
<td style="text-align: center;">Hash</td>
<td style="text-align: center;">{name:"jack", age:21}</td>
</tr>
<tr>
<td style="text-align: center;">List</td>
<td style="text-align: center;">[A-&gt;B-&gt;B-&gt;C]</td>
</tr>
<tr>
<td style="text-align: center;">Set</td>
<td style="text-align: center;">{A,C,B}</td>
</tr>
<tr>
<td style="text-align: center;">SortSet</td>
<td style="text-align: center;">{A:1,B:2,C:3}</td>
</tr>
</tbody>
</table>
<h3 id="特殊数据类型">2. 特殊数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">GEO</td>
<td style="text-align: center;">{A:(120.3, 30.5)}</td>
</tr>
<tr>
<td style="text-align: center;">BitMap</td>
<td style="text-align: center;">0111001000101010101</td>
</tr>
<tr>
<td style="text-align: center;">HyperLog</td>
<td style="text-align: center;">101001010110101</td>
</tr>
</tbody>
</table>
<h3 id="redis和mysql保持数据一致性">3. Redis和MySQL保持数据一致性</h3>
<h4 id="一缓存先后删除问题"><strong>（一）缓存先后删除问题</strong></h4>
<blockquote>
<p>不管是先写<a
href="https://cloud.tencent.com/product/cdb?from_column=20065&amp;from=20065">MySQL数据库</a>，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。</p>
</blockquote>
<h5 id="先删除缓存">1.1 先删除缓存</h5>
<ul>
<li>如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取</li>
<li>这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据。</li>
<li>然后数据库更新后发现Redis和Mysql出现了数据不一致的问题</li>
</ul>
<h5 id="后删除缓存">1.2 后删除缓存</h5>
<ul>
<li>如果先写了库，然后再删除缓存，不幸的写库的线程挂了，导致了缓存没有删除</li>
<li>这个时候就会直接读取旧缓存，最终也导致了数据不一致情况</li>
<li>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题</li>
</ul>
<h4 id="二解决办法">（二）解决办法</h4>
<h5 id="延时双删策略">2.1 延时双删策略</h5>
<ul>
<li>1.先删除缓存</li>
<li>2.再写数据库</li>
<li>3.休眠500毫秒</li>
<li>4.再次删除缓存</li>
</ul>
<h5 id="异步更新缓存基于mysql-binlog的同步机制">2.2
异步更新缓存（基于Mysql binlog的同步机制）</h5>
<ul>
<li>1.涉及到更新的数据操作，利用Mysql binlog 进行增量订阅消费</li>
<li>2.将消息发送到消息队列</li>
<li>3.通过消息队列消费将增量数据更新到Redis上</li>
<li>4.操作情况</li>
<li>读取Redis缓存：热数据都在Redis上</li>
<li>写Mysql：增删改都是在Mysql进行操作</li>
<li>更新Redis数据：Mysql的数据操作都记录到binlog，通过消息队列及时更新到Redis上</li>
</ul>
<h3 id="缓存穿透">4. 缓存穿透</h3>
<h4 id="概念">（1）概念</h4>
<p>指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会直接打到数据库</p>
<h4 id="解决方案">（2）解决方案</h4>
<ul>
<li>缓存空对象</li>
<li>布隆过滤器</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩">5. 缓存雪崩</h3>
<h4 id="概念-1">（1）概念</h4>
<p>指同一时段，大量的缓存key同时失效，或者Redis服务宕机，导致大量的请求直接打到数据库，带来巨大的压力</p>
<h4 id="解决方案-1">（2）解决方案</h4>
<ul>
<li>给不同key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿">6. 缓存击穿</h3>
<h4 id="概念-2">（1）概念</h4>
<p>也叫热点Key问题，就是被一个高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的压力。</p>
<h4 id="解决方案-2">（2）解决方案</h4>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<h3 id="redis持久化">7. Redis持久化</h3>
<h4 id="一rdb持久化">（一）RDB持久化</h4>
<h5 id="概念-3">1. 概念</h5>
<p>​ RDB全称Redis Database Backup
file（Redis数据备份文件），也被叫做Redis数据快照。（快照文件称为RDB文件，默认是保存在当前运行目录。）简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。Redis停机时会执行一次RDB。</p>
<h5 id="过程">2. 过程</h5>
<p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入
RDB 文件。 fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<h4 id="二aof持久化">（二）AOF持久化</h4>
<h5 id="概念-4">1. 概念</h5>
<p>AOF全称为Append Only
File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<h5 id="过程-1">2. 过程</h5>
<p>其实就是一个执行日志文件，每次进行操作都写入日志中。</p>
<h3 id="redis主从">8. Redis主从</h3>
<h4 id="一数据同步">（一）数据同步</h4>
<h5 id="全量同步">1. 全量同步</h5>
<ul>
<li>slave节点请求增量同步</li>
<li>master节点判断replid，发现不一致，拒绝增量同步</li>
<li>master将完整内存数据生成RDB，发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li>
<li>slave执行接收到的命令，保持与master之间的同步</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250104163740.png" style="zoom: 33%;" /></p>
<h5 id="增量同步">2. 增量同步</h5>
<h2 id="java性能优化">Java性能优化</h2>
<h2 id="transactional-注解失效"><span class="citation"
data-cites="Transactional">@Transactional</span> 注解失效</h2>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2025/03/12/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一设计模式总述">一、设计模式总述</h1>
<h2 id="什么是设计模式">1、什么是设计模式</h2>
<p>  
设计模式是一套经过反复使用的代码设计经验，目的是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<p>  项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相对应的原理与之对应，每种模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p>
<p>  总体而言，设计模式分为三大类：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312144024.png" style="zoom:60%;" /></p>
<h2 id="设计模式的六大原则">2、设计模式的六大原则</h2>
<p>设计模式主要有六大设计原则，分别是：单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特原则。<br><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312193040.png" style="zoom:67%;" /></p>
<h3
id="单一职责原则single-responsibility-principle">（1）单一职责原则（Single
Responsibility Principle）</h3>
<ol type="1">
<li>定义：一个接口或者类只有一个原因引起变化。</li>
<li>定义解释：即一个接口或者一个类只有一个职责，负责一件事情。（此原则同样适用于方法）</li>
<li>好处：① 复杂性降低 ② 可读性提高 ③可维护性提高 ④变更风险降低</li>
</ol>
<p><strong>详细描述和代码demo:</strong> <a href="/2025/03/13/DesignPattern/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" title="单一职责原则">[单一职责原则]</a></p>
<h3 id="开闭原则-open-close-principle">（2）开闭原则 <strong>(Open Close
Principle)</strong></h3>
<ol type="1">
<li>定义：软件实体对扩展开放，对修改关闭。</li>
<li>定义解释：也就是应该通过扩展来实现业务需求和变化，而不是通过修改已有的代码来实现变化。</li>
<li>好处：① 强系统的稳定性和可扩展性 ②减少对现有代码的影响</li>
</ol>
<p><strong>详细描述和代码demo:</strong> <a href="/2025/03/13/DesignPattern/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" title="开闭原则">[开闭原则]</a></p>
<h3 id="里氏替换原则-liskov-substitution-principle">（3）里氏替换原则
<strong>(Liskov Substitution Principle)</strong></h3>
<ol type="1">
<li>定义：任何基类可以出现的地方，子类一定可以出现。</li>
<li>定义解释：
<ul>
<li>子类必须完全实现弗雷的方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或者实现父类方法时，输入参数可以被放大</li>
<li>覆盖或者实现父类方法时，输出结果可以被缩小</li>
</ul></li>
<li>好处：① 提升代码的可靠性和复用性 ②减少继承带来的问题</li>
</ol>
<h3 id="依赖倒置原则-dependence-inversion-principle">（4）依赖倒置原则
<strong>(Dependence Inversion Principle)</strong></h3>
<ol type="1">
<li>定义：高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。</li>
<li>定义解释：简单点来说，就是面向接口编程。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系时通过接口或者抽象类产生。</li>
<li>好处：① 降低模块间的耦合 ②提升系统的可扩展性和可维护性</li>
</ol>
<h3 id="接口隔离原则-interface-segregation-principle">（5）接口隔离原则
<strong>(Interface Segregation Principle)</strong></h3>
<ol type="1">
<li>定义：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li>
<li>定义解释：应该为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</li>
<li>好处：① 提高系统的灵活性和可维护性 ② 减少接口间的耦合。</li>
</ol>
<h3 id="迪米特原则-demeter-principle">（6）迪米特原则 <strong>(Demeter
Principle)</strong></h3>
<ol type="1">
<li>定义：<strong>只与直接的朋友通信。</strong>一个类应该对其他类保持最少的了解</li>
<li>定义解释：也就是说一个类对自己依赖的类知道的越少越好。即对于被依赖的类，无论逻辑多复杂，都尽量地讲逻辑封装在类的内部，对外除了提供的public方法，不对外泄露任何信息。</li>
<li>好处：① 提高模块的独立性 ② 减少依赖 ③
增强系统的可维护性和可复用性。</li>
</ol>
<p>关于本站设计模式学习的所有相关代码demo都在这个仓库：【<a
href="https://github.com/ych1016/DesignPattern">设计模式</a>】</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中@Autowired和@Resource的区别</title>
    <url>/2025/03/18/Java/Spring%E4%B8%AD@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一是什么">一、是什么？</h1>
<p><span class="citation"
data-cites="Autowired和">@Autowired和</span><span class="citation"
data-cites="Resource">@Resource</span>
都是Java中用于进行依赖注入的注解，它们可以用于将一个对象引用注入到另一个对象中，从而实现对象之间的协作。</p>
<h1 id="二区别">二、区别</h1>
<h2 id="一来源不同">（一）来源不同</h2>
<ul>
<li><span class="citation" data-cites="Autowired">@Autowired</span> 是
Spring 框架提供的注解，所以@Autowired只能在Spring框架下使用</li>
<li><span class="citation" data-cites="Resource">@Resource</span> 是
JavaEE 提供的注解，<span class="citation"
data-cites="Resource则可以与其他框架一起使用">@Resource则可以与其他框架一起使用</span>。</li>
</ul>
<h2 id="二属性不同">（二）属性不同</h2>
<ul>
<li><span class="citation"
data-cites="Autowired只包含一个参数">@Autowired只包含一个参数</span>：required，表示是否开启自动注入，默认是true。</li>
<li><span class="citation"
data-cites="Resource包含七个参数">@Resource包含七个参数</span>，其中最重要的两个参数是：name
和 type。</li>
</ul>
<h2 id="三默认装配方式不同">（三）默认装配方式不同</h2>
<ul>
<li><span class="citation"
data-cites="Autowired默认按byType自动装配">@Autowired默认按byType自动装配</span>。<span
class="citation"
data-cites="Autowired如果要使用byName">@Autowired如果要使用byName</span>，需要使用@Qualifier一起配合。</li>
<li><span class="citation"
data-cites="Resource如果指定了name">@Resource如果指定了name</span>，则用byName自动装配，如果指定了type，则用byType自动装配。</li>
</ul>
<h2 id="四注解应用的地方不同">（四）注解应用的地方不同</h2>
<ul>
<li><span class="citation"
data-cites="Autowired能够用在">@Autowired能够用在</span>：构造器、方法、参数、成员变量和注解上；</li>
<li><span class="citation"
data-cites="Resource能用在">@Resource能用在</span>：类、成员变量和方法上。</li>
</ul>
<h2 id="五装配顺序不同">（五）装配顺序不同</h2>
<ul>
<li><span class="citation"
data-cites="Autowired默认先按byType进行匹配">@Autowired默认先按byType进行匹配</span>，如果发现找到多个bean，则又按照byName方式进行匹配，如果还有多个，则报出异常。</li>
<li><span class="citation"
data-cites="Resource的装配顺序">@Resource的装配顺序</span>：
<ul>
<li>如果同时指定了name和type，则会查找name和type唯一匹配的Bean，找到了自动装配，找不到抛异常</li>
<li>只是指定了@Resource注解的name，则按name后的名字去bean元素里查找有与之相等的name属性的bean。</li>
<li>只指定@Resource注解的type属性，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常。</li>
<li>如果既没有指定name，也没有指定type，则自动按byName方式进行查找。如果没有找到符合的bean，则回退为一个原始类型进行进行查找，如果找到就注入。</li>
</ul></li>
</ul>
<h1 id="参考文章">参考文章</h1>
<ol type="1">
<li>https://blog.csdn.net/Weixiaohuai/article/details/120853683</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>里氏替换原则</title>
    <url>/2025/03/13/DesignPattern/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="里氏替换原则">里氏替换原则</h1>
<h2 id="一定义">一、定义</h2>
<p>  任何基类可以出现的地方，子类一定可以出现。子类应该可以替换其基类，而不会影响程序的正确性。也就是说子类不能重写父类的实现好的方法（非抽象方法）
最通俗的理解：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p>
<p>  如果子类需要重载父类方法，那也需要遵循下面这四个原则 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314094515.png" /></p>
<h2 id="二问题由来">二、问题由来</h2>
<p>  有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<h2 id="三解决方案">三、解决方案：</h2>
<p>  当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<h2 id="四衍生">四、衍生</h2>
<p>  里氏替换原则主要应用在类继承的场景。在所有编程语言的继承中，包含了这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是载设定一系列的规定和契约，虽然它不是强制要求锁的子类必须遵守这些契约，
但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p>
<p>  继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。
比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
<h2 id="五代码demo">五、代码demo：</h2>
<h3 id="不重写非抽象方法">1、不重写非抽象方法</h3>
<blockquote>
<p>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</p>
</blockquote>
<h4 id="错误示范">（1） 错误示范</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;两数的运算结果为：&quot;</span> + (a + b));</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在子类要实现两数相减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son01</span> <span class="keyword">extends</span> <span class="title class_">Base01</span> &#123;</span><br><span class="line">    <span class="comment">// 子类重写了父类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;两数的运算结果为：&quot;</span> + (a - b));</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiskovSubstitutionDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 父类应用</span></span><br><span class="line">        <span class="type">Base01</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base01</span>();</span><br><span class="line">        System.out.println(base.cal(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将用到父类的地方替换成子类</span></span><br><span class="line">        <span class="type">Son01</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son01</span>();</span><br><span class="line">        System.out.println(son.cal(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出</span></span><br><span class="line"><span class="comment">         * 两数的运算结果为：3</span></span><br><span class="line"><span class="comment">         * 3</span></span><br><span class="line"><span class="comment">         * 两数的运算结果为：-1</span></span><br><span class="line"><span class="comment">         * -1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修正">（2）修正</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修正</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son01Correct</span> <span class="keyword">extends</span> <span class="title class_">Base01</span> &#123;</span><br><span class="line">    <span class="comment">// 新增一个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载时参数范围应更宽松">2、重载时，参数范围应更宽松</h3>
<blockquote>
<p>当子类需要重载父类中的方法的时候，子类方法的形参（入参）要比父类方法输入的参数更宽松（范围更广）。</p>
</blockquote>
<h4 id="错误示范-1">（1） 错误示范</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范，子类参数范围比父类小</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">(List list)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法执行了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son02</span> <span class="keyword">extends</span> <span class="title class_">Base02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法执行了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修正-1">（2）修正</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修正</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base02Correct</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">(ArrayList list)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法执行了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son02Correct</span> <span class="keyword">extends</span> <span class="title class_">Base02Correct</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法执行了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出">（3） 输出</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiskovSubstitutionDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Base02</span> <span class="variable">base02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base02</span>();</span><br><span class="line">        base02.method(list);</span><br><span class="line">        <span class="comment">// 将父类的位置换成子类</span></span><br><span class="line">        <span class="type">Son02</span> <span class="variable">son02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son02</span>();</span><br><span class="line">        son02.method(list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Base02Correct</span> <span class="variable">base02Correct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base02Correct</span>();</span><br><span class="line">        base02Correct.method(list);</span><br><span class="line">        <span class="comment">// 将子类替换成父类</span></span><br><span class="line">        <span class="type">Son02Correct</span> <span class="variable">son02Correct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son02Correct</span>();</span><br><span class="line">        son02Correct.method(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出：</span></span><br><span class="line"><span class="comment">         * 父类方法执行了~</span></span><br><span class="line"><span class="comment">         * 子类方法执行了~</span></span><br><span class="line"><span class="comment">         * ==============================</span></span><br><span class="line"><span class="comment">         * 父类方法执行了~</span></span><br><span class="line"><span class="comment">         * 父类方法执行了~</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写时返回值范围缩小">3、重写时，返回值范围缩小</h3>
<blockquote>
<p>重写或者实现父类方法的时候，方法的返回值可以被缩小，但是不能放大。</p>
</blockquote>
<h4 id="错误示范-2">（1） 错误示范</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">getList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son03</span> <span class="keyword">extends</span> <span class="title class_">Base03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">getList</span><span class="params">()</span> &#123;     <span class="comment">// 编译器直接不通过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修正-2">（2）修正</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修正</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base03Correct</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">getList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son03Correct</span> <span class="keyword">extends</span> <span class="title class_">Base03Correct</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子类可以有自己独特的方法">3、子类可以有自己独特的方法</h3>
<blockquote>
<p>子类可以拥有自己独特的方法或属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类中定义自己的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son04</span> <span class="keyword">extends</span> <span class="title class_">Base04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六总结">六、总结</h2>
<p>  在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用堕胎比较频繁时，程序圆形出错的几率非常大。
如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更抽象的基类，原来的继承关系去掉，采用依赖、聚合、组合等关系替代。</p>
<h2 id="七参考文章">七、参考文章</h2>
<ol type="1">
<li>https://cloud.tencent.com/developer/article/1673476</li>
<li>https://blog.csdn.net/zhengzhb/article/details/7281833</li>
<li>https://blog.csdn.net/HongZeng_CSDN/article/details/130409363</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>里氏替换</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2025/02/24/Java/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一基础知识复习">一、基础知识复习</h1>
<h2 id="从start一个线程说起">1、 从start一个线程说起</h2>
<p>​ Java的线程启动是调用了线程变量start函数，而在源码中 start
函数调用的是 start0() （native修饰）的系统函数，start0
的系统函数是结合了Java的JVM和主机系统的线程函数是实现的。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309202911.png" style="zoom:50%;" /></p>
<h2 id="java多线程相关概念">2、Java多线程相关概念</h2>
<h3 id="概念">（1）概念</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309202950.png" style="zoom: 67%;" /></p>
<h3
id="java线程分为用户线程和守护线程">（2）Java线程分为用户线程和守护线程</h3>
<ol type="1">
<li><p>一般情况下，不做任何配置都是用户线程。</p></li>
<li><p>用户线程（User Thread）
是系统的工作线程，它会完成这个程序需要完成的业务操作。</p></li>
<li><p>守护线程（Daemon
Thread）是一种特殊的线程，是为其它线程服务的，在后台默默完成一些系统性的服务，比如垃圾回收线程就是一种典型的守护线程。当系统只剩下守护线程时，Java虚拟机会自动退出。</p></li>
</ol>
<h3 id="daemon属性">（3）Daemon属性</h3>
<p>线程中会存在Daemon属性，调用isDaemon函数可以判断当前线程是否为守护线程，调用setDaemon可以设置当前线程为守护线程。</p>
<h3 id="小总结">（4）小总结</h3>
<p>​
如果用户线程全部结束意味着程序需要完成的业务操作已经结束了，守护线程随着JVM一同结束工作。setDaemon(true)方法必须在start()之前设置，否则报IIIegalThreadStateException异常</p>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程正在运行~~~~&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().isDaemon()? <span class="string">&quot;守护线程&quot;</span>:<span class="string">&quot;用户线程&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 系统线程正在运行~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="二completablefuture">二、CompletableFuture</h1>
<h2 id="future理论知识复习">1、Future理论知识复习</h2>
<p>​
Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p>
<p>多线程需要满足三个特点：多线程/有返回/异步任务</p>
<h3 id="futuretask实现类">（1）FutureTask实现类</h3>
<p>​
Future实现了RunnableFutur接口，而RunnableFutur又继承了Runnable和Future接口，满足了多线程和异步任务的特性，同时采用构造注入的方式，使得FutureTask实现类具备有返回的特性，只要这个实现类构造注入Callable就能有返回值。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203019.png" style="zoom:67%;" /></p>
<p>代码示范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Mythread</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;come in call ~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="future编码实战和优缺点">（2）Future编码实战和优缺点</h3>
<ol type="1">
<li>优点：
<ul>
<li>future + 线程池异步多线程任务配合，能显著提高程序的执行效率。</li>
</ul></li>
<li>缺点：
<ul>
<li>get方法阻塞</li>
<li>isDone() 轮询更容易导致CPU中断。
isDone函数可以返回当前线程是否执行完成</li>
</ul></li>
</ol>
<h2 id="completablefuture">2、CompletableFuture</h2>
<h3
id="completablefuture对future的改进">（1）CompletableFuture对Future的改进</h3>
<p>主要内容：CompletableFuture提供了一种观察者模式类似的机制，可以让任务完成后通知监听的一方</p>
<ol type="1">
<li>继承关系</li>
</ol>
<p>CompletableFuture继承了Future和CompletionStage接口，所以Future拥有的功能，它也有。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203030.png" style="zoom:80%;" /></p>
<ol start="2" type="1">
<li>CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。有点类似Linux系统的管道分隔符传参数</li>
<li>CompletableFuture不需要再另外创造新的线程变量或者线程池执行异步任务。FutureTask并没有内置线程池，所以在进行声明后，需要使用线程对象去执行这个异步编程，但是CompletableFuture在没有为它传入线程池时，它会调用自身内置的ForkJoinPool.commonPool()线程池完成异步任务，但是需要注意的是，ForkJoinPool执行任务的线程是守护线程，所以在main函数执行结束时，还没有完成的线程会被强制中断。对于这种情况，解决方法是，使用自己的线程池，在程序末尾，添加线程池关闭动作。</li>
</ol>
<h3
id="completablefuture之四大静态方法">（2）CompletableFuture之四大静态方法</h3>
<ol type="1">
<li><p>runAsync 无返回值</p>
<ol type="1">
<li>```java public static CompletableFuture<Void> runAsync(Runnable
runnable, Executor executor) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```java</span><br><span class="line">   public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>supplyAsync 有返回值</p>
<pre><code>1. ```java
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,
                                                   Executor executor)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	2. ```java</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li>
</ol>
<p>如果没有传入线程池，那么会默认使用ForkJoinPool.commonPool()
作为它的线程池执行异步代码。如果调用了需要传入线程池的构造函数，则会使用我们传入的线程池来执行对应的异步代码。</p>
<p>demo代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName() + &quot; ========= &quot;);</span></span><br><span class="line"><span class="comment">//            try &#123;  TimeUnit.SECONDS.sleep(2);  &#125; catch (InterruptedException e) &#123;  throw new RuntimeException(e);  &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println(completableFuture.get());</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ========= &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;今天是个好日子！&quot;</span>;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3
id="completablefuture之通用异步编程">（3）CompletableFuture之通用异步编程</h3>
<p>​
会有返回值，并且可以分阶段完成，为了调用whenComplete监听线程完成，异步任务完成后将调用该方法，该方法可以使用lambda函数获取异步任务的返回值。</p>
<p>优点：</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法</li>
<li>主线程设置好回调后，不需要关心异步任务的执行，异步任务之间可以顺序执行</li>
<li>异步任务出错时，会自动回调某个对象的方法</li>
</ul>
<p>demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 使用自己的线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结束啦，计算后最终的结果是：&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;, executorService).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;终于计算结束了？ 恭喜啦&quot;</span>);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;异常情况是&quot;</span> + e.getCause() + <span class="string">&quot;异常信息为 ： &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展">（4）拓展</h3>
<ol type="1">
<li>通用函数接口</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;">函数式接口名称</th>
<th style="text-align: center;">方法名称</th>
<th style="text-align: center;">参数</th>
<th style="text-align: center;">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Runnable</td>
<td style="text-align: center;">run</td>
<td style="text-align: center;">无参数</td>
<td style="text-align: center;">无返回值</td>
</tr>
<tr>
<td style="text-align: center;">Function</td>
<td style="text-align: center;">apply</td>
<td style="text-align: center;">1个参数</td>
<td style="text-align: center;">有返回值</td>
</tr>
<tr>
<td style="text-align: center;">Consume</td>
<td style="text-align: center;">accept</td>
<td style="text-align: center;">1个参数</td>
<td style="text-align: center;">无返回值</td>
</tr>
<tr>
<td style="text-align: center;">Supplier</td>
<td style="text-align: center;">get</td>
<td style="text-align: center;">没有参数</td>
<td style="text-align: center;">有返回值</td>
</tr>
<tr>
<td style="text-align: center;">BiSummer</td>
<td style="text-align: center;">accept</td>
<td style="text-align: center;">2个参数</td>
<td style="text-align: center;">没有返回值</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li><p>get函数和join函数的区别</p>
<p>get函数会抛出异常，join函数不会抛出异常</p></li>
</ol>
<h2 id="实际案例">3、实际案例</h2>
<p>电商获取对应价格案例，使用stream和chain还有CompletableFuture进行实现</p>
<p>demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureMallDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;NetMall&gt; netMallList = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;京东&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;淘宝&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;当当&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; netMallList, String productName, ExecutorService executorService)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> netMallList.stream().map(netMall -&gt; CompletableFuture.supplyAsync(() -&gt;</span><br><span class="line">                String.format(productName + <span class="string">&quot; in %s price is %.2f &quot;</span>, netMall.getNetMallName(), netMall.calcPrice(productName), executorService)</span><br><span class="line">        )).collect(Collectors.toList()).stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; prices = getPriceByCompletableFuture(netMallList, <span class="string">&quot;mysql&quot;</span>, executorService);</span><br><span class="line">        <span class="keyword">for</span> (String price : prices) &#123;</span><br><span class="line">            System.out.println(price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="completablefuture常用方法">4、 CompletableFuture常用方法</h2>
<h3 id="获得结果和触发计算">（1）获得结果和触发计算</h3>
<ol type="1">
<li>获得结果
<ol type="1">
<li>get 不见不散</li>
<li>定时get 过时不候</li>
<li>join 不见不散但不抛异常</li>
<li>getNew 没有计算完成，给一个提前设定的结果</li>
</ol></li>
<li>主动触发计算
<ol type="1">
<li>complete 是否打算get方法，立即返回括号值</li>
</ol></li>
</ol>
<h3 id="对计算结果进行处理">（2）对计算结果进行处理</h3>
<ol type="1">
<li><p>thenApply</p>
<p>计算结果存在依赖关系，这两个线程串行化</p>
<p>异常相关：由于存在依赖（当前步错，不走下一步），当前步骤有异常的话就叫停</p></li>
<li><p>handle</p>
<p>计算结果存在依赖关系，这两个线程串行化</p>
<p>异常相关：有异常也可以往下一步走，根据带的异常参数可以进一步处理</p></li>
</ol>
<h3 id="对计算结果进行消费">（3）对计算结果进行消费</h3>
<ol type="1">
<li><p>接收任务的处理结果，并消费处理，无返回结果。</p></li>
<li><p>thenAccept 可以接收上一步的结果，但是不用返回</p></li>
<li><p>对比补充</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203046.png" style="zoom:80%;" /></p></li>
</ol>
<h3 id="对计算速度进行选用">（4）对计算速度进行选用</h3>
<p>通过调用applyToEither()
函数比较两个线程之间哪一个线程的执行所需要的时间更少，得到的返回结果就是那个用时比较少的线程所返回的结果。</p>
<h3 id="对计算结果进行合并">（5）对计算结果进行合并</h3>
<p>​
两个CompletionStage任务都完成后，最终能把两个任务的结果一起交给thenCombine进行处理，先完成等后完成，一起完成后再进行合并。</p>
<h2 id="completablefuture和线程池">5、CompletableFuture和线程池</h2>
<ol type="1">
<li><p>没有传入自定义线程池，都用默认线程池ForkJoinPool</p></li>
<li><p>传入了一个自定义线程池</p>
<p>如果执行第一个任务的时候，传入了一个自定义线程池</p>
<p>调用thenRun方法执行第二个任务时，则第二个任务和第一个任务是共同使用同一个线程池</p>
<p>调用thenRunAsync执行第二个任务时，则第一个任务使用的是自定义线程池，第二个任务使用的是ForkJoin线程池</p></li>
<li><p>备注</p>
<p>有可能处理太快，系统优化切换原则，直接使用main线程处理</p></li>
</ol>
<p>其他如：thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，他们之间的区别也是同理。</p>
<h1 id="三java的锁事">三、Java的“锁”事</h1>
<h2 id="乐观锁和悲观锁">1、 乐观锁和悲观锁</h2>
<h3 id="悲观锁">（1）悲观锁</h3>
<p>synchronized关键字和Lock的实现类都是悲观锁，认为当前线程在使用数据时，一定有别的线程来修改数据，因此在获取数据时会先加锁，确保数据不会被别的线程修改</p>
<p>应用：</p>
<ul>
<li>适合写操作多的场景，先加锁可以保证写操作时数据正确</li>
<li>显式的锁定之后再操作同步资源</li>
<li>狼性锁</li>
</ul>
<h3 id="悲观锁-1">（2）悲观锁</h3>
<p>认为当前线程在使用数据时不会有其他线程修改数据或资源，所以不加锁，Java是通过使用无锁编程来实现，只在更新时判断有没有别的线程更新过数据。若数据没有被更新，则直接写入；若数据被更新了，则根据不同的实现方式执行不同的操作，比如放弃修改和重试抢锁等</p>
<p>实现方法：</p>
<ol type="1">
<li>版本号机制Vision</li>
<li>最常采用的是CAS算法，Java原子类中的递增操作就是通过CAS自旋来实现的</li>
</ol>
<p>应用：</p>
<ul>
<li>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
<li>佛系锁</li>
</ul>
<h2 id="八种加锁情况">2、八种加锁情况</h2>
<p>（1）【1-2】一个类存在多个synchronized方法，多线程调用同一对象的不同synchronized方法</p>
<p>一个对象里面如果有多个synchronized方法，某一时刻内，只要一个线程去调用其中的一个synchronized方法了，其他线程都只能等待。简而言之，只能有唯一一个线程去访问这些synchronized方法。锁的是当前对象this，被锁定后，其他线程都不需要进入到当前对象的其他的synchronized方法。</p>
<p>（2）【3-4】一个类存在synchronized方法，也存在非synchronized方法</p>
<p>加个普通方法后发现同步锁失效；换成两个对象，不是同一把锁，情况立刻变化。</p>
<p>（3）【5-6】把synchronized方法都换成静态方法</p>
<p>三种synchronized锁的内容有一些差别：</p>
<ul>
<li>对象锁：对于普通同步方法，锁的是当前实例对象，通常指this，所有的普通同步方法用的都是同一把锁--》实例对象本身</li>
<li>类锁：对于静态同步方法，锁的是当前类的class对象，锁的是唯一模板</li>
<li>对于同步方法块，锁的是synchronized括号内的对象</li>
</ul>
<p>（4 ）【7-8】 静态锁和普通锁不会有竞争关系</p>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，正常退出或抛出异常时必须释放锁。</p>
<p>所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身，本类this。即如果一个实例对象的普通同步方法获得锁后，该实例对象的其他普通同步方法必须等待获得锁的方法释放锁后才能获得锁。</p>
<p>所有的静态同步方法用的也是同一把锁——类对象本身，即唯一模板class。具体实例对象this和唯一模板class，这两把锁时两个不同的对象，所有静态同步方法和普通同步方法之间不会有竞争关系。但是一旦一个静态同步方法获取锁后，其他静态同步方法都必须等待该方法释放锁后才能获得锁</p>
<h2 id="synchronized三种应用方式">3、synchronized三种应用方式</h2>
<h3
id="种锁的案例实际体现在3个地方">（1）8种锁的案例实际体现在3个地方</h3>
<ul>
<li>作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>作用于代码块，对括号里配置的对象加锁</li>
<li>作用于静态方法，当前类对象加锁，进去同步代码前要获得当前类对象的锁</li>
</ul>
<h3
id="字节码角度分析synchronized实现">（2）字节码角度分析synchronized实现</h3>
<ul>
<li><p>synchronized同步代码块</p>
<p>实现使用的时monitorenter和monitorexit指令</p></li>
<li><p>synchronized普通同步方法</p>
<p>调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会将先持有monitor锁，然后在执行方法，最后在方法完成（无论是否正常完成）时释放monitor</p></li>
<li><p>synchronized静态同步方法</p>
<p>ACC_STATIC，ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法</p></li>
</ul>
<h3 id="反编译synchronized锁">（3）反编译synchronized锁</h3>
<p>为什么任何一个对象都可以成为一个锁？每个对象在创建时都会初始化一个ObjectMonitor对象。ObjectMonitor里面可以记录占有锁的线程，阻塞队列，重入次数等信息</p>
<h2 id="公平锁和非公平锁">4、公平锁和非公平锁</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th>锁类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平锁</td>
<td>指多个线程按照申请锁的顺序来获取锁，Lock lock = new
ReentrantLock(true)</td>
</tr>
<tr>
<td>非公平锁</td>
<td>指多个线程获得锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获得锁，在高并发环境下造成优先级翻转或者饥饿的状态，Lock
lock = new ReentrantLock(false)</td>
</tr>
</tbody>
</table>
<p>非公平优点：</p>
<ul>
<li>非公平锁能更充分的利用时间片，尽量减少CPU空闲状态时间</li>
<li>当使用非公平锁时，1个线程请求锁获取同步状态，然后释放同步状态，刚释放锁的线程在此刻再次获取锁的概率会变得很大，这样可以减少线程的开销。</li>
</ul>
<p>应用：</p>
<p>为了更高吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁。</p>
<h2 id="可重入锁递归锁">5、可重入锁（递归锁）</h2>
<h3 id="概念-1">（1）概念</h3>
<p>​
是指在同一个线程在外层方法获取锁的时候，再进入线程的内层方法会自动获取锁（前提，锁对象是同一个对象），不会因为之前已经获取过还没释放而阻塞。简而言之，就是自己可以获取自己的内部锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203102.png" style="zoom:80%;" /></p>
<p>在Java中ReentrantLock和synchronized都是可重入锁，优点是可以一定程度上避免死锁。</p>
<h3 id="可重入锁种类">（2）可重入锁种类</h3>
<ul>
<li><p>隐式锁（即synchronized关键字修饰的锁）默认是可重入锁</p>
<p>一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</p></li>
<li><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是第一层！&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是第二层！&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;这是第三层！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是第一次进入！&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是第二次进入！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized的重入实现机制</p>
<p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。当执行monitorenter时，如果目标锁对象的计数器为0，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1</p>
<p>在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitorexit时，Java虚拟机则需要将锁对象的计数器减1.计数器为0代表锁已被释放。</p>
<h2 id="死锁及排查">6、死锁及排查</h2>
<h3 id="概念-2">（1）概念</h3>
<p>​
是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203113.png" style="zoom:67%;" /></p>
<p>死锁实现Demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lockA.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我线程A已经启动了，让我运行几秒钟&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">            lockB.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我需要B锁的支持！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lockB.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockA.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lockB.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我线程B也启动了！让我运行几秒钟！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">3</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">            lockA.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我需要A锁的支持！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lockA.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockB.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    threadA.start();  threadB.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁产生原因">（2）死锁产生原因</h3>
<ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ul>
<h3 id="排查死锁">（3）排查死锁</h3>
<p>使用命令，显示当前所有Java进程pid的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">17540 </span><br><span class="line">1500 com.ych.lock.DeadLockDemo</span><br><span class="line">25180 jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line">26284 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure>
<p>得到我们想要查询的目标运行程序的pid之后，再使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jstack 1500</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
<p>即可排除出是哪个程序出现了死锁。</p>
<p>另外也可以使用 jconsole，调出Java性能分析器，分析是否存在死锁。</p>
<h1 id="四locksupport与线程中断">四、LockSupport与线程中断</h1>
<h2 id="线程中断">1、线程中断</h2>
<h3 id="概念-3">（1）概念</h3>
<p>线程中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现，若要中断一个线程，需要手动调用interrupt方法，该方法也仅仅是将该线程对象的中断标识设成true</p>
<h3 id="中断的三大api方法说明">（2）中断的三大API方法说明</h3>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr>
<th>中断函数</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void interrupt()</td>
<td>// Just to set the interrupt flag
仅仅设置线程中断状态为true，发起一个协商而不会停止线程</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断线程是否被中断，并清除当前中断状态。
返回当前线程的中断状态，并将当前线程的中断状态重新设置为false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被中断（通过检查中断标志位）</td>
</tr>
</tbody>
</table>
<h2 id="中断机制考点">2、中断机制考点</h2>
<h3 id="如何停止中断运行中的线程">（1）如何停止中断运行中的线程</h3>
<ul>
<li>通过一个volatile变量来实现</li>
<li>通过AtomicBoolean</li>
<li>通过Thread类自带的中断api实例方法实现
<ul>
<li>再需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。</li>
</ul></li>
</ul>
<p>实现demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3_interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是t1，我现在没有被中断~~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被中断了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是t2 我是来中断t1的&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2_atomicBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是t1，我现在没有被中断~~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(atomicBoolean.get())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被中断了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是t2 我是来中断t1的&quot;</span>);</span><br><span class="line">        atomicBoolean.set(<span class="literal">true</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1_volatile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我跳出来了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 ------------&gt; 我没有被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="关于interruptedexception异常处理方式">（2）关于InterruptedException异常处理方式</h3>
<p>​
我们需要注意的是，当当前线程处于阻塞状态时（如wait或sleep），如果有其他线程调用了当前线程的interrupt函数，尝试更改当前线程的中断标识，会导致当前线程抛出InterruptedException异常，然后设置自己的中断标识为false。简而言之：<strong>当阻塞方法收到中断请求的时候就会抛出InterruptedException异常</strong>。</p>
<p>结论：interrupt方法本质上不会进行线程的终止操作的，它不过是改变了线程的中断状态。而改变了此状态带来的影响是，部分可中断的线程方法（比如Object.wait,
Thread.sleep）会定期执行isInterrupted方法，检测到此变化，JVM会将线程的中断标志重新设置为false，随后会停止阻塞并抛出InterruptedException异常。总之，interrupt的作用就是需要用户自己去监视线程的状态位并做处理。但InterruptedException异常的抛出并不是意味着线程必须得终止，它只是提醒当前线程有中断操作发生了，接下来怎么处理完全取决于线程本身，一般有3种处理方式：</p>
<ol type="1">
<li><p>"吞并"异常，当做什么事都没发生过。</p></li>
<li><p>继续往外抛出异常。</p></li>
<li><p>其它方式处理异常(其它处理异常的方式就有很多种了，停止当前线程或者输出异常信息等等)。</p></li>
</ol>
<h3 id="静态方法-thread.interrupted">（3）静态方法
Thread.interrupted()</h3>
<p>方法实际功能：</p>
<ol type="1">
<li>返回当前线程的中断状态，测试当前线程是否被中断</li>
<li>将当前线程的中断状态清零并重置为false</li>
</ol>
<h2 id="locksupport">3、 LockSupport</h2>
<h3 id="概念-4">（1）概念</h3>
<p>是一个线程阻塞的工具类，所有方法都是静态方法，用于创建锁和其他同步类的基本线程阻塞原语。可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。</p>
<h3 id="线程等待唤醒机制">（2）线程等待唤醒机制</h3>
<h4 id="种让线程等待和唤醒的方法">【1】3种让线程等待和唤醒的方法</h4>
<ul>
<li>方法一：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li>
<li>方法二：使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程</li>
<li>方法三：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li>
</ul>
<h4
id="object类中的wait和notify方法实现线程等待和唤醒">【2】Object类中的wait和notify方法实现线程等待和唤醒</h4>
<ul>
<li><p>wait和notify方法必须要在同步块或者方法里面，且成对出现使用</p></li>
<li><p>先wait后notify，顺序不能颠倒</p></li>
</ul>
<h4
id="condition接口中的await和signal方法实现线程的等待和唤醒">【3】Condition接口中的await和signal方法实现线程的等待和唤醒</h4>
<ul>
<li>Condition中的线程等待和唤醒方法，需要先获取锁</li>
<li>一定要先await后signal，顺序不能颠倒</li>
</ul>
<p>​
其实上面两种情况都在说明一件事情，就是如果你想对一个线程进行阻塞操作，如wait操作，就必须先获得当前这个线程锁的权限，也就是Object的wait和notify都需要在同步块或同步方法中；Condition的await和signal也需要在lock.lock()和
lock.unlock()之间。另外等待和唤醒的顺序不能颠倒</p>
<h4
id="locksupport类中的park等待和unpark唤醒">【4】LockSupport类中的park等待和unpark唤醒</h4>
<ul>
<li>LockSupport类使用了一种名为Permit（许可证）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可(permit)，但与Semaphore不同的是，<strong>许可的累加上限是1</strong></li>
<li>LockSupport
和每个使用它的线程都有一个许可关联。每个线程都有一个相关的permit，permit最多只有一个，重复调用unpark也不会积累凭证</li>
</ul>
<h1 id="五java内存模型-jmm">五、Java内存模型 JMM</h1>
<h2 id="计算机硬件存储体系">1、计算机硬件存储体系</h2>
<p>硬盘 ---&gt; 内存 ----&gt; 高速缓存 ----&gt; CPU</p>
<h2 id="java的内存模型">2、Java的内存模型</h2>
<p>​
本身是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范，通过这组规范定义了程序中（尤其是多线程）每个变量的读写访问方式并决定一个线程对共享变量的写入合适以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</p>
<h2 id="jmm规范下的三大特性">3、JMM规范下的三大特性</h2>
<h3 id="可见性">（1）可见性</h3>
<p>​
指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有变量都存储在主内存中。</p>
<p>​
系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能够直接读写主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要通过主内存来完成。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203128.png" style="zoom:80%;" /></p>
<h3 id="原子性">（2）原子性</h3>
<p>指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰</p>
<h3 id="有序性">（3）有序性</h3>
<p>对于一个线程的执行代码而言，为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p>
<h2 id="多线程对变量的读写过程">4、多线程对变量的读写过程</h2>
<p>​
线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本的拷贝。</p>
<p>总结：</p>
<ul>
<li>定义的所有共享变量都储存在物理主内存中</li>
<li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li>
<li>线程对共享变量所有的操作都必须现在自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）</li>
<li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）</li>
</ul>
<h2 id="多线程先行发生原则-happens-before">5、多线程先行发生原则
happens-before</h2>
<h3 id="定义">（1）定义</h3>
<p>​
在JMM中，如果一个操作执行的结果需要对另一个操作可加性或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则。逻辑上的先后关系。本质上是一种可见性。</p>
<h3 id="总原则">（2）总原则</h3>
<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见。而且第一个操作的执行顺序排在第二个操作之前</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则指定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来<strong>执行的结果一致</strong>，那么这种重排序<strong>并不非法</strong>。</li>
</ul>
<h3 id="条原则">（3）8条原则</h3>
<h4 id="次序规则">【1】次序规则</h4>
<p>一个线程内，按照代码顺序，卸载前面的操作先行发生于写在后面的操作</p>
<h4 id="锁定规则">【2】锁定规则</h4>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作</p>
<h4 id="volatile变量规则">【3】volatile变量规则</h4>
<p>对一个volatile变量的写操作，先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样指时间上的先后。</p>
<h4 id="传递规则">【4】传递规则</h4>
<p>如果操作A先发生于操作B，操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
<h4 id="线程启动规则thread-start-rule">【5】线程启动规则（Thread Start
Rule）</h4>
<p>Thread对象的start() 方法先行发生于此线程的每一个动作。</p>
<h4 id="线程中断规则thread-interruption-rule">【6】线程中断规则（Thread
Interruption Rule）</h4>
<p>对于线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。简而言之，要先调用interrupt()方法设置过中断标志位，才能检测到中断发生</p>
<h4 id="线程终止规则thread-termination-rule">【7】线程终止规则（Thread
Termination Rule）</h4>
<p>线程中的所有操作都先行发生于对此线程的终止检测，可以通过调用isAlive()等手段检测线程是否已经终止执行。</p>
<h4 id="对象终结原则finalizer-rule">【8】对象终结原则（Finalizer
Rule）</h4>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</p>
<h1 id="六volatile与jmm">六、volatile与JMM</h1>
<h2
id="被volatile修饰的变量的两大特点">1、被volatile修饰的变量的两大特点</h2>
<h3 id="特点">（1）特点</h3>
<ul>
<li>可见性</li>
<li>有序性</li>
</ul>
<h3 id="volatile的内存语义">（2）volatile的内存语义</h3>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新回主内存</strong>中</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</li>
<li>所有volatile的写内存语义是直接刷新到主内存中，读内存的语义是直接从主内存中读取。</li>
</ul>
<h2 id="内存屏障">2、内存屏障</h2>
<h3 id="栗子">（1）栗子</h3>
<ul>
<li>可见：写完后立即刷新会主内存，并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见</li>
<li>有序性：存在数据依赖关系，禁止重排序</li>
</ul>
<h3 id="概念-5">（2）概念</h3>
<p>​
内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作）。避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成VM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性（禁重排），但<strong>volatile无法保证原子性</strong>。</p>
<ul>
<li>内存屏障<strong>之前</strong>的所有<strong>写操作</strong>都要会<strong>写到主内存</strong></li>
<li>内存屏障<strong>之后</strong>的所有<strong>读操作</strong>都能获得<strong>内存屏障之前的所有写操作的最新结果</strong>（实现可见性）</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203143.png" style="zoom:67%;" /></p>
<h4 id="写屏障store-memory-barrier">【1】写屏障（Store Memory
Barrier）</h4>
<p>告诉处理器在写屏障之前将所有存储在缓存（store
bufferes）中的数据同步到主内存。即看到Store屏障指令，必须把该指令之前所有写入指令执行完毕才能继续往下执行</p>
<h4 id="读屏障load-memory-barrier">【2】读屏障（Load Memory
Barrier）</h4>
<p>处理器在读屏障之后的读操作，都在读屏障之后执行，即在Load屏障指令之后就能保证后面的读取数据指令一定能够读取到最新的数据</p>
<h3 id="内存屏障的分类">（3）内存屏障的分类</h3>
<figure>
<img
src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250226100314936.png"
alt="image-20250226100314936" />
<figcaption aria-hidden="true">image-20250226100314936</figcaption>
</figure>
<h2
id="happens-before之volatile变量规则">3、happens-before之volatile变量规则</h2>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 27%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr>
<th>第一个操作</th>
<th>第二个操作：普通读写</th>
<th>第二个操作：volatile读</th>
<th>第二个操作：volatile写</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通读写</td>
<td>可以重排</td>
<td>可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile读</td>
<td>不可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile写</td>
<td>可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
</tbody>
</table>
<h2 id="内存屏障插入策略的4种规则">4、内存屏障插入策略的4种规则</h2>
<h3 id="读屏障">（1）读屏障</h3>
<ul>
<li>在每一个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每一个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203153.png" style="zoom:67%;" /></p>
<h3 id="写屏障">（2）写屏障</h3>
<ul>
<li>在每一个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每一个volatile写操作的后面插入一个StoreLoad屏障</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203204.png" style="zoom:80%;" /></p>
<h2 id="volatile特性">5、volatile特性</h2>
<h3 id="保证可见性">（1）保证可见性</h3>
<p>代码demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不加volatile会陷入死循环</span></span><br><span class="line"><span class="comment">// 需要注意的是while循环里面不要添加 print 语句， 因为Java的print语句加了synchronized，修改变量也会导致线程终止</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被终止了！&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 我终止了 &quot;</span> + thread.getName() + <span class="string">&quot; 的运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile变量读写过程</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203221.png" /></p>
<p>read：作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p>
<p>load：作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p>
<p>use：作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p>
<p>assign：作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作。</p>
<p>store：作用于工作内存，将赋值完毕的工作变量的值写回给主内存</p>
<p>write：作用于主内存，将store传输过来的变量赋值给主内存中的变量</p>
<p>由于上述6条只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以JVM提供了另外两个原子指令</p>
<p>lock：作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，只是锁了写变量的过程。</p>
<p>unlock：作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p>
<h3 id="没有原子性">（2）没有原子性</h3>
<p>对于volatile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅是数据加载时是最新的，但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，主内存volatile修饰变量发生修改，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即<strong>各线程私有内存和主内存公共内存中变量不同步</strong>，进而导致数据不一致，由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，<strong>对于多线程修改主内存共享变量的场景必须使用加锁同步。</strong></p>
<p>demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileNoAutomicDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; ++j) &#123;</span><br><span class="line">                    myNumber.plusOneToNum();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">        System.out.println(myNumber.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">plusOneToNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令禁重排">（3）指令禁重排</h3>
<p>volatile的底层实现是通过内存屏障</p>
<h3 id="结论">（4）结论</h3>
<p>​ volatile变量不适合参与到依赖当前值的运算，如 i = i+1; i++; 之类
。通常volatile用作保存某个状态的Boolean值或 int 值。</p>
<p>​
由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只能单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<h2 id="使用volatile">6、使用volatile</h2>
<ul>
<li>单一赋值可以使用volatile，含复合运算赋值不可以（i++之类）</li>
<li>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件</li>
<li>当读远多于写，结合使用内部锁和volatile变量减少同步的开销</li>
</ul>
<h1 id="七cascompare-and-swap">七、CAS（compare and swap）</h1>
<h2 id="概念-6">1、概念</h2>
<p>（有点像乐观锁，更新之前先比较一下是不是之前的那个值）</p>
<p>compare and swap
比较并交换，包含三个操作数——内存位置、预期原值及更新值</p>
<p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p>
<ul>
<li>如果相匹配，那么处理器会自动将该位置值更新为新值</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203233.png" /></p>
<p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。它是非阻塞的且自身具有原子性。CAS是一条CPU的原子指令（cmpxchg指令），执行cmpxchg指令时，会判断当前系统是否为多核系统，若为多核系统，则给总线加锁，只有一个线程会对总线加锁成功，加锁成功后会执行CAS操作，即CAS的原子性实际上是CPU实现独占，比起synchronized重量级锁，这里的排他事件要短很多，所以在多线程情况下性能会更好。</p>
<h2 id="cas底层原理">2、CAS底层原理</h2>
<h3 id="unsafe">（1）Unsafe</h3>
<p>是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe基于该类可以直接操作特定内存的数据。Unsafe类其内部方法操作可以像C的指针一样直接操作内存，因此Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p><strong>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong></p>
<h3 id="变量valueoffset">（2）变量valueOffset</h3>
<p>其实就是内存偏移地址，因为Unsafe是根据内存偏移地址来获取数据的</p>
<h3 id="使用volatile修饰变量value">（3）使用volatile修饰变量value</h3>
<p>变量value用volatile修饰，保证了多线程之间的内存可见性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JUC</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖传递的三种方式</title>
    <url>/2025/03/18/Java/%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一什么是依赖">一、什么是依赖？</h1>
<p>在Java中，“依赖”是一种关系，它表示一个类或模块（被称为“被依赖项”）
依赖于另一个类或模块（被称为“依赖项”）来实现其功能。依赖描述了一个类在其视线中使用了其他类的功能，而不是将所有功能都封装在类中。</p>
<blockquote>
<p>举个栗子：类A直接依赖类B：类B是类A的某个成员方法的返回值、形参、局部变量或类A调用了类B的静态方法。</p>
</blockquote>
<p>依赖是可以传递的，A对象依赖B对象，B对象又依赖C对象，C对象又依赖D对象......</p>
<h1 id="二依赖传递的三种方式">二、依赖传递的三种方式</h1>
<p>依赖传递主要有三种实现方式：构造方法传递依赖对象；setter方法传递依赖对象；接口声明传递依赖对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDriver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(ICar car)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">IDriver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ICar car;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 构造方法传递依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(ICar car)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. setter方法传递依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCar</span><span class="params">(ICar car)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 接口传递依赖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(ICar car)</span> &#123;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三总结">三、总结</h1>
<p>依赖注入是一种非常有用的设计模式，可以使得代码更加灵活、可维护和易扩展。但是，依赖注入也有一些缺点，包括增加代码的复杂性、难以调试和可能影响代码的性能。
因此，在使用依赖注入时，我们需要权衡其优缺点，并根据具体情况来选择适当的方案。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>依赖传递</tag>
      </tags>
  </entry>
  <entry>
    <title>实习坑点</title>
    <url>/2025/01/04/Java/%E5%AE%9E%E4%B9%A0%E5%9D%91%E7%82%B9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="39f6fc65c56b885e0fadb17bc2a8eeb1a64c28db461f500933fdcec77f7e0e02">1f6bb8509d126916afe1b073331b8b303e8fc819b81490765ad837df7dc1353814a72d845b5617ce1fc01ae8d2343ee9e00ca198754762b83bc34dc85adcadb9565ade93116558bad147e024d233f6fd50676540c5cfc12ef02bdb9408ec77a9cd0fd45cd751c067d00a32d02564a9ded5e79fab6af90cb1efe5602c3a23dbe85bc00b055b02a7731ad71244f3df0a0e4b22e405093904fdb426d271773c3cd945f10cef61240550fe1fc4511c9ce05e4299e86b95d3c2629b712259f3645574d5450c3915182a5b63f52fd1b9a987470d809318389bf47264abc009d75e63699fe01e548d0ccd5c5a5393bac04d96ba61630da33c84987a274094cae6c6fb00be8a457b5703d7bf2dc1e6825e0314e1bd96e928fc5384ab593e02b2028ac65117828b0a7171311817a002c4804b5e87d6b862a31cfee9328e8793a5763a6f7998bee9741e2163ad1fdc40b65842374a933ac726a26b96e1d1f09fa850a77136af875dadf227595bae3174aaead10bf6be33ad53fe0b55a65c627c7361b07e6b00e8e9b0c51cddcc2d99bb5247a33dea91e5f30f48ae20d72e65e22f909fe3ba4ed66a3344b608738ad3eab169b50d6fe0097944f2e1f4af6ef793a37a5cf3ab8c7d027451039abc4a88d9ce6ee052c506c77959dd1e471e137ff984b576d9011611a60632198f2bb59b7330544a51958a13b094b5a1b39cf8f1c817e57e0ba87f2ae06d347bd39c25953b40c518d8167f0beef5cc0e7982735fd0fffc1c699dd9923e1f4570d5255f0f985dabcc890e004b6fbc9faf80cd66cee28b03be73b0b2a3edf2da7fcaa9bf50059da89ae9be</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>英文单词</title>
    <url>/2024/12/04/Life/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语单词3000个</tag>
        <tag>积累</tag>
      </tags>
  </entry>
  <entry>
    <title>碎碎念</title>
    <url>/2024/12/01/Life/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p><font size=4>🚩
真正的自由意味着控制你整个生活，学会计划、承诺和决定，为你自己的行为负责！</font>
<br></p>
<blockquote>
<p><font face="楷体">
原来，让内心强大，我只需要看到自己，接纳我还不能做的，欣赏我已经做到的
——《当我真的足够强大》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
没有一种批判比自我批判更强烈，也没有一种法官比我们自己更严苛。
——《蛤蟆先生去看心理医生》</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
对抗消极的不是积极，而是专注。积极的情绪是无法击退消极情绪的，只有把自己沉浸在某件事件上才能从消极情绪中走出来。
——若林正恭 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 生活的不确定性正是我们希望的来源。 ——阿德勒
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
那些看起来比你勇敢的人也像你一样害怕，他们只是在黑暗中把口哨吹得响亮一些罢了。
——《为什么长大》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
那晚，我点了一把篝火，大地在月亮眼中亮起了一颗星星。 ——弱智吧
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 这乱糟糟的世上还有人拿着花四处走走。
——李沧东《火与灰》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 好在，别人如何分析我，跟我本身是一点关系都没有的。
——三毛《撒哈拉的故事》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 你极目远望，其余的由心去完成。 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 一个人变好的前提是，允许自己不好。 ——武志红
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
纯粹，就是不要一心要成为高贵或者强大的人，而是成为自己。
——佩索阿《惶然录》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
人人都有天赋，但可贵的是，你是否有勇气追随你的天赋到黑暗之地。
——艾丽卡·琼 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
随着年龄的增长，你越来越不在意别人怎么看你，只有那时你才能愈加自由。
——《失踪树木的岛屿》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
人脑虽然可以努力什么都试图记住，但写下来就可以安心忘记了。 ——《告白》
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
后来我知道了，人生在世，临到每一个紧要关头，你都是孤军衰兵。
——《关山夺路》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
我们本能地把错误归咎于他人，但最重要的是，坏事情发生时，应该寻找原因，而不是寻找坏人。
——《事实》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
勇气，并不是闪闪发光的英雄主义，勇敢中也包含怯懦，就像爱中也有不爱的时刻。这来回摇摆的踱步，斑驳的杂质，才是真相。
——《茫然尘世的珍宝》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 我独自度过了太多时光，沉默已成一种习惯。
——《夜航西飞》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
幸福的关键，并不在于你是否结婚、是否有孩子等，而是无论你处于什么样的状态都有不停追求幸福的行动力，以及无论多小的一件事，你都能感到幸福的能力。可以说，幸福的关键是一种心态。
——《超单身社会》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
因为有了仪式，某一天才有别于其他任何一天，某一个小时才有别于其他任何一个时刻。
——圣·埃克絮佩里 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
时间不是一条直线，而是一个循环，我们在其中不断重复着相似的故事，直到我们学会从中解脱。
——《悉达多》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
你不能在赢的时候才自信，那不是自信，是对结果的复读。 ——冯骥 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
出路只有一条：在别人头脑发热大声喧闹的时候，退回到自己的内心并保持沉默
——《昨日的世界》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
无论风暴将我带到什么样的岸边，我都将以主人的身份上岸
——昆图斯·贺拉斯·弗拉库斯 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 而我，还是那个身披霞光的人
<br>雨水流过山岚，孤独如杜鹃开放 ——余秀华 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
能够用干净利落、毫不妥协的态度看待事情，本身就是一种成就。
——《永不停步》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 我一定会幸福，为此，我现在要做必须做的事。
——上野千鹤子 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 这世界有时很糟糕，我用我自己的方式寻找自由
——莱昂纳德·科恩 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
知交零落实是人生常态，能够偶尔话起，而心中仍然温柔，就是好朋友。 ——三毛
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
过去和风评都是死的，但你是活的；不要被它们影响，不要回头！
——《强风吹拂》 </font></p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>名言积累</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis应用</title>
    <url>/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="一使用redis实现登录校验">一、使用Redis实现登录校验</h1>
<p> 
主要验证是校验码验证和密码验证，我觉得可以这样设计，把验证码存入到Redis中，用户信息使用JWT生成对应的token，然后将JWT生成的token存入到Redis中（替代直接将用户信息存入Redis中），这样可以减少Redis的内存负担。具体流程图如下方所示，<br />
 
下图的具体做法是将用户的信息采用JWT进行加密保存了，出于安全考虑，我觉得对于前端页面上用户的基本信息可以使用JWT存储，这样在解析的时候也会比去Redis中再获取一次要快。但是对于用户一些常用的敏感信息，我觉得还是有必要放在Redis中的。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309103254.png" style="zoom:50%;" /></p>
<h1 id="二缓存">二、缓存</h1>
<p>使用缓存主要会存在几种问题：缓存雪崩，缓存击穿，缓存穿透。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309110729.png" style="zoom:50%;" /></p>
<h2 id="缓存雪崩">1、 缓存雪崩</h2>
<h3 id="什么是缓存雪崩">（1）什么是缓存雪崩？</h3>
<p>如果缓存在某一个时刻出现大规模key失效，那么就会导致大量的请求打在数据库上面，导致数据库压力巨大，如果高并发的情况下，可能瞬间就会导师数据库宕机。这时如果运维马上又重启数据库，马上又会有新的流量把数据库打死，这就是缓存雪崩。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203618.png" style="zoom:70%;" /></p>
<h3 id="问题分析">（2）问题分析：</h3>
<p>存在这种情况的问题所在：</p>
<ul>
<li>Redis宕机</li>
<li>大量缓存采用了相同的过期时间</li>
</ul>
<h3 id="解决方案">（3）解决方案：</h3>
<h4 id="事前">&lt;1&gt; 事前：</h4>
<ol type="1">
<li><p>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问</p></li>
<li><p>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不相同</p></li>
<li><p>热点数据永远不过期</p>
<blockquote>
永不过期实际包含两层意思：
<ul>
<li>物理不过期：针对热点key不设置过期时间</li>
<li>逻辑过期：把过期时间存在key对应的value中，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</li>
</ul>
</blockquote></li>
<li><p>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用
主从 + 哨兵，Redis集群来避免Redis全盘崩溃的情况</p></li>
</ol>
<h4 id="事中">&lt;2&gt; 事中：</h4>
<ol type="1">
<li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读写数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他线程，此时系统的吞吐量会下降</li>
<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果</li>
</ol>
<h4 id="事后">&lt;3&gt; 事后：</h4>
<p> 
开启Redis持久化机制，尽快回复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p>
<h2 id="缓存击穿">2、缓存击穿</h2>
<h3 id="什么是缓存击穿">（1）什么是缓存击穿</h3>
<p> 
缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿则是某个热点key失效，大规模并发对其进行请求，就会导致大量请求读缓存读取不到数据，从而导致大规模请求直接打到数据库，引起数据库压力剧增，这就是缓存击穿。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135734.png" style="zoom:70%;" /></p>
<h3 id="问题分析-1">（2）问题分析</h3>
<p> 
关键在于某个热点key失效了，导致大并发集中打在数据库上。所以要从两个方面解决。第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量</p>
<h3 id="解决方案-1">（3）解决方案</h3>
<h4 id="互斥锁或者队列">&lt;1&gt; 互斥锁或者队列</h4>
<p> 
在缓存失效后，通过<strong>互斥锁或者队列</strong>来控制读数据写缓存的线程数量
#### &lt;2&gt; 永不过期   热点数据缓存<strong>永不过期</strong></p>
<h2 id="缓存穿透">3、缓存穿透</h2>
<h3 id="什么是缓存穿透">（1）什么是缓存穿透</h3>
<p> 
缓存穿透是指用户请求的数据在<strong>缓存中不存在</strong>，即读请求时没有命中缓存，同时<strong>数据库也不存在该数据</strong>。导致用户每次请求该数据都要去数据库查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间内大量请求直接打在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135630.png" style="zoom:70%;" /></p>
<h3 id="问题分析-2">（2）问题分析</h3>
<p> 
缓存穿透的关键在于在Redis中查不到key值。一般导致缓存穿透主要有两种情况：一个是业务误操作，删除了数据库和redis中的缓存；另外一个是黑客恶意攻击。假如有黑客传进大量的不存在key，那么大量的请求打在数据库上是很致命的问题。所以在日常开发中要对参数做好校验，一些非法参数，不可能存在的key就直接返回错误提示。</p>
<h3 id="解决方案-2">（3）解决方案</h3>
<h4 id="非法请求的限制">&lt;1&gt; 非法请求的限制</h4>
<p> 
在API入口处判断请求参数是否合理，请求参数是否含有非法值，请求字段是否存在，如果判断出是恶意请求则直接返回错误，避免进一步访问缓存和数据库</p>
<h4 id="将无效key存放在redis中">&lt;2&gt; 将无效key存放在Redis中</h4>
<p> 
当出现Redis查不到数据，数据库也查不到数据的情况，则把这个key保存到Redis中，这是value=“null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，不再需要查询数据库。但该方法存在一定的问题，假如传进来的不存在的key每次都是随机的，那存入Redis也没有意义</p>
<h4 id="使用布隆过滤器">&lt;3&gt; 使用布隆过滤器</h4>
<p> 
在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询key是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<blockquote>
<p>什么是布隆过滤器？</p>
<p>布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好得多，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<p>布隆过滤器原理：</p>
<ul>
<li>第一步，使用N个哈希函数分贝对数据做哈希计算，得到N个哈希值；</li>
<li>第二步，将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为1。</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203643.png" style="zoom:80%;" /></p>
<blockquote>
<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机的，若采用缓存空对象方案会缓存大量不存在key的数据，并不合适。所以需要采用布隆过滤器方案，布隆过滤器先过滤掉不存在的key。针对key异常多、请求重复率比较低的数据，优先使用布隆过滤器方案。对于空数据的key有限，重复率比较高的，则优先采用缓存空对象方案</p>
</blockquote>
<h2 id="汇总">汇总</h2>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309181748.png" style="zoom:80%;" /></p>
<h2 id="缓存预热">4、缓存预热</h2>
<h3 id="什么是缓存预热">（1）什么是缓存预热</h3>
<p> 
缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，再将数据缓存的问题，用户可以直接查询事先被预热的缓存数据。若不进行预热，则Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。</p>
<h3 id="缓存预热实现方案">（2）缓存预热实现方案</h3>
<ul>
<li>数据量不大时，工程启动的时候进行加载缓存动作</li>
<li>数据量大时，设置一个定时任务脚本，进行缓存的刷新</li>
<li>数据量非常大时，优先保证热点数据进行提前加载到缓存</li>
</ul>
<h2 id="缓存降级">5、缓存降级</h2>
<p> 
缓存降级指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般时有损的操作，所以尽量减少降级对业务的影响程度。
在项目实战中，通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p>
<h1 id="三数据库缓存保持一致性">三、数据库缓存保持一致性</h1>
<blockquote>
<p>先说结论：大多数业务采用的都是<strong>【先更新数据库，再删除缓存】</strong>的
Cache
Aside（旁路缓存）策略，同时给缓存设定过期时间，防止在第二步，删除缓存数据失败导致数据不一致的问题。</p>
<p>若业务对缓存命中率有很高的要求，则可以采用【先更新数据库，再更新缓存】的方案，因为主动更新缓存可以减少缓存未命中的情况</p>
</blockquote>
<h2 id="先更新数据库还是先更新缓存">1、先更新数据库还是先更新缓存</h2>
<p> 
<strong>都不可行。</strong>无论是【先更新数据库，再更新缓存】，还是【先更新缓存，再更新数据库】，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能出现数据库和缓存中的数据不一致的情况。常见的缓存更新策略主要有三种：Cache
Aside（旁路缓存）策略；Read/Write Through（读穿 / 写穿）策略；Write
Back（写回）策略；</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309190713.png" style="zoom:50%;" /></p>
<p>但在实际开发中，Redis和MySQL的更新策略用的是Cache
Aside策略，另外两种主要是用在操作系统中。</p>
<h2 id="cache-aside旁路缓存策略">2、 Cache Aside（旁路缓存）策略</h2>
<p> 
先更新数据库数据，然后不更新缓存，直接删除缓存中的数据。等客户端要读取数据时，发现缓存中没有，再从数据库中读取数据放到缓存中。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203658.png" style="zoom:50%;" /></p>
<h3 id="写策略">（1）写策略</h3>
<ul>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ul>
<h3 id="读策略">（2）读策略</h3>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据</li>
<li>如果读取的数据未命中缓存，则直接读取数据库中的数据，再将数据放入缓存。</li>
</ul>
<h2 id="先更新数据库还是先删缓存">2.1 先更新数据库还是先删缓存</h2>
<p> 
先说结论，<strong>先更新数据库，再删缓存</strong>。理论上来说，无论是【先更新数据库，再删除缓存】，还是【先删除缓存，再更新数据库】都会导致数据库与缓存数据不一致的问题。但为什么还是推崇【先更新数据库，再删除缓存】呢？
 
主要原因还是在【先更新数据库，再更新缓存】出现数据库与缓存数据不一致的情况较少。因为缓存的写入通常要远远快于数据库的写入。具体例子参考：<a
href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98">小林coding</a></p>
<h2 id="readwrite-through读穿-写穿策略">3、 Read/Write Through（读穿 /
写穿）策略</h2>
<p>  Read / Write
Through（读穿/写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是有缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p>
<h3 id="read-through">（1）Read Through</h3>
<p> 
先查询缓存中数据是否存在，如果存在则直接返回；如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用</p>
<h3 id="write-through">（2）Write Through</h3>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul>
<li>如果缓存中数据已存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li>
<li>如果缓存中数据不存在，则直接更新数据库，然后返回。</li>
</ul>
<h2 id="write-back写回策略">4、Write Back（写回）策略</h2>
<p>  Write
Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。【主要用于操作系统】</p>
<h2 id="小结">5、小结</h2>
<h3
id="使用先删除缓存再更新数据库">（1）使用【先删除缓存，再更新数据库】</h3>
<p>  针对【先删除缓存，再更新数据库】方案在【读 +
写】并发请求而造成缓存不一致的解决办法是<strong>【延迟双删】</strong>。就是等更新数据库的线程更新完数据库之后先睡眠一段时间，然后再删一次缓存，可以避免由于高并发使缓存中放入脏数据。但是这个睡眠时间需要大于另外一个读取数据的时间（查数据库
+ 将数据放入缓存）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br><span class="line"><span class="comment"># 更新数据库		</span></span><br><span class="line">db.update(X)</span><br><span class="line"><span class="comment"># 睡眠一段时间</span></span><br><span class="line">thread.sleep(N)</span><br><span class="line"><span class="comment"># 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure>
<h3
id="保证先更新数据库再删除缓存成功">（2）保证【先更新数据库，再删除缓存】成功</h3>
<p>为了保证【先更新数据库，再删除缓存】的第二个步骤，也就是删除缓存能成功，可以使用：</p>
<ul>
<li>消息队列重试缓存的删除，优点是保证缓存一致性问题，缺点是对业务代码入侵</li>
<li>订阅MySQL binlog + 消息队列 +
重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题。缺点是引入的组件较多，对团队的运维能力有比较高要求。</li>
</ul>
<h1 id="四redis持久化机制">四、Redis持久化机制</h1>
<p>Redis持久化数据的主要方式有两个，分别是：RDB快照和AOF日志。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309112643.png" /></p>
<h2 id="rdb快照">1、 RDB快照</h2>
<h3 id="相关概念">【1】相关概念</h3>
<h4 id="概念和启用">（1）概念和启用</h4>
<p>记录某一瞬间的内存数据【全量快照】，记录的是实际全部数据。所以相比于AOF文件记录命令操作日志，RDB恢复数据的效率要高很多，因为直接将RDB文件读入内存即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bgsave指令</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span>     <span class="comment"># 900秒之内，对数据库进行了至少1次修改</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>		<span class="comment"># 300秒之内，对数据库进行了至少10次修改</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>	<span class="comment"># 60秒之内，对数据库进行了至少10000次修改</span></span><br></pre></td></tr></table></figure>
<p>只要满足上面条件的任意一个，就会执行bgsave。</p>
<h4 id="使用指令">（2）使用指令</h4>
<ul>
<li><code>save</code>指令，使用主线程。若写入RDB文件的时间太长，会阻塞主线程</li>
<li><code>bgsave</code>指令，使用子线程。可以避免主线程的阻塞</li>
</ul>
<h3 id="执行快照时数据能被修改吗">【2】执行快照时，数据能被修改吗</h3>
<p>（1）save指令。不行，当执行save指令时，使用的是主线程生成快照，所以此时的主线程会被阻塞，然后去执行快照操作</p>
<p>（2）bgsave指令。
可以，bgsave使用的是子线程，主线程基本不会被阻塞。</p>
<h3
id="子线程如何拥有主线程相同的数据副本">【3】子线程如何拥有主线程相同的数据副本</h3>
<p><strong>写时复制。</strong>主进程通过<code>fork</code>系统调用生成子进程。同时，操作系统会把主进程的【页表】复制一份给子进程，这个页面记录着虚拟地址和物理地址的映射关系，而不会复制物理内存，即两者的虚拟空间不同，但指向的都是同一块物理空间。当父进程或子进程在向这块物理内存发起写操作时，由于这块内存父子进程只有只读共享权限，所以CPU会触发写保护中断，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制（需要注意的是这里只会复制主进程修改的物理内存数据，没修改的物理内存数据还是和子进程共享的）</p>
<h3
id="能否保证快照和数据库数据一致性">【4】能否保证快照和数据库数据一致性</h3>
<p><strong>不能</strong>，快照只能保存快照执行那一刻的Redis所有数据。</p>
<h2 id="aof日志">2、AOF日志</h2>
<h3 id="相关概念-1">【1】相关概念</h3>
<h4 id="概念和启用-1">（1）概念和启用</h4>
<p>对于Redis的每一次<strong>写操作</strong>，都会将这次写操作追加到一个文件里。在Redis中AOF持久化功能默认是不开启的，需要我们修改
redis.conf 配置文件中的以下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// redis.conf</span><br><span class="line">appendonly       yes   // 表示是否开启AOF持久化（默认no，关闭）</span><br><span class="line">appendfilename   &quot;appendonly.aof&quot;   // AOF持久化文件的名称</span><br></pre></td></tr></table></figure>
<h4 id="先写后记录">（2）先写后记录</h4>
<p>Redis只先执行了相关的写操作指令后，才将该指令写入到aof文件中的，这样子有多个好处：</p>
<ul>
<li><p>避免额外的检查开销</p>
<p>先执行，再写。执行不通过就不写。语法有问题，或者逻辑有问题，在运行的时候就能检测出来，减少了写进aof文件前的检查时间</p></li>
<li><p>不会阻塞当前写操作命令的执行</p>
<p>当前写操作指令执行成功后，才会将命令记录到AOF日志中。</p></li>
</ul>
<h4 id="潜在风险">（3）潜在风险</h4>
<ul>
<li><p>丢失风险</p>
<p>执行写操作命令和记录日志是两个过程，并不是原子操作。若Redis在还没来得及将命令写入硬盘时，服务器宕机，这个数据就会有丢失的风险</p></li>
<li><p>可能会给【下一个】命令带来阻塞风险</p>
<p>由于Redis在写AOF文件时，是以串行的方式进行，所以对当前的写Redis的执行不会阻塞，但是后面在写AOF文件的时候一旦发生阻塞，那下一个写Redis的命令就会有阻塞风险。</p></li>
</ul>
<h3 id="三种写回策略">【2】三种写回策略</h3>
<h4 id="aof写回">（1）AOF写回</h4>
<p>在介绍AOF写回策略之前，需要先介绍一下Redis将命令写入AOF的过程。如下图所示：</p>
<p>① Redis执行完写操作命令后，会将命令追加到
<code>server.aof_buf</code>缓冲区；<br>②
通过write()系统调用，将<code>aof_buf</code>
缓冲区的数据写入到AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区<code>page cache</code>，等待内核将数据写入硬盘;
<br>③ 具体内核缓冲区的数据什么时候写入到硬盘。由内核决定。</p>
<p><img src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311141509633.png" alt="image-20250311141509633" style="zoom:50%;" /></p>
<h4 id="三种写回策略-1">（2）三种写回策略</h4>
<p>Redis主要有三种写回策略，如下图思维导图所示：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311135343.png" /></p>
<h4 id="优化局限">（3）优化局限</h4>
<p>这3种写回策略都无法完美解决【主进程阻塞】和【减少数据丢失】的问题，因为两个问题对立，就像算法题优化时间和空间一样，有得有失。具体原因如下：</p>
<ul>
<li>Always
策略，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将
AOF 内容写回硬盘，所以是不可避免会影响主进程的性能; 【适合高可靠】</li>
<li>No 策略，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于
Always 策略性能较好但是操作系统写回硬盘的时机是不可预知的，如果 AOF
日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。【适合高性能】</li>
<li>Everysec 策略的话，是折中的一种方式，避免了 Always
策略的性能开销，也比 No
策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。【折中选择】</li>
</ul>
<h4 id="实现原理">（4）实现原理</h4>
<p>在查看源码时，会发现三种策略的实现都是建立在控制<code>fsync()</code>函数的调用时机。若想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用<code>fsync()</code>函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回</p>
<ul>
<li>Always策略：每次写入AOF文件数据，都会调用<code>fsync</code>函数</li>
<li>Everysec策略：创建一个异步任务调用<code>fsync</code>函数</li>
<li>No策略：永不调用<code>fsync</code>函数</li>
</ul>
<h3 id="aof重写机制">【3】AOF重写机制</h3>
<p> 其实就是压缩AOF文件，减少AOF文件中的执行代码。AOF重写机制在重写时，会读取当前Redis中的所有键值对，然后对每一个键值s生成一条命令记录到【新的AOF文件】，等全部记录完成，将新的AOF文件替换掉现在的AOF文件。</p>
<p> 举个栗子：假如现在王五要在redis种记录自己的名字，最开始记录名字为<code>zs</code>，发现记录错了，又改成<code>lisi</code>，结果发现还是错的，又改成<code>wangwu</code>，几番折腾，此时的AOF就需要记录3条写语句，这样很多写操作都是荣冗余的。在经过AOF重写后，AOF文件只需要保存最后一条写操作就可以。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311144321.png" style="zoom:67%;" /></p>
<h3 id="aof-后台重写">【4】AOF 后台重写</h3>
<h4 id="为什么是后台完成重写">（1）为什么是后台完成重写</h4>
<p> 为什么是后台重写呢？在上文我们可以看到，Redis在写AOF的时候，都是使用了主进程，（即写Redis操作和写AOF操作都是主进程在执行）。那为什么AOF的重写需要后台执行呢？因为AOF重写，是需要从Redis中读取所有键值对，然后对再为每一个键值对生成对应的Redis写指令，写进新的AOF文件中，再替换原来的AOF文件，这个过程非常耗时，所以需要系统在后台进行，不然很容易就阻塞了实际的写Redis操作。所以Redis在进行重写的时候是<strong>由后台子进程bgrewriteaof来完成</strong>。</p>
<h4 id="为什么是子进程">（2）为什么是子进程</h4>
<p> 进程才是操作系统的资源分配最小单位。如果使用线程，那么多线程之间会共享内存，那么在修改共享内存数据时，需要通过加锁来保证数据的安全，这样会降低性能。而使用子进程，创建子进程时，父子进程是以<strong>只读</strong>的方式共享内存数据的。当父子进程任意一方修改了该共享内存，就会发生【写时复制】（复制的也只是要写入或者修改的部分），于是父子进程就有了独立的数据副本，而不用加锁来保证数据安全。</p>
<h4
id="子进程如何拥有主进程相同的数据副本">（3）子进程如何拥有主进程相同的数据副本</h4>
<p><strong>整个过程：</strong></p>
<p>① 主进程通过<code>fork</code>系统调用生成bgrewriteaof子进程。</p>
<p>②
同时，操作系统会把主进程的【页表】复制一份给子进程，这个页面记录着虚拟地址和物理地址的映射关系，而不会复制物理内存，即两者的虚拟空间不同，但指向的都是同一块物理空间。</p>
<p>③
当父进程或子进程在向这块物理内存发起写操作时，由于这块内存父子进程只有只读共享权限，所以CPU会触发写保护中断，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制（需要注意的是这里只会复制主进程修改的物理内存数据，没修改的物理内存数据还是和子进程共享的）<br>
同时，由于此时子进程还处于重写AOF状态，读取的是还是之前的Redis中的数据，所以当主进程完成写操作时，会导致子进程读取的Redis数据与最新的数据不一致，也就是有“脏读”的现象。对于这种现象，Redis也有应对措施。那就是将AOF重写期间，主进程执行的所有写指令，都写进<strong>AOF重写缓冲区</strong>。另外，Redi也会写一份在<strong>AOF缓冲区</strong>（这个是为了防止子进程宕机，原来的AOF也不会少在AOF重写时候的写指令）</p>
<p>④ 等子进程重写完成时，主进程会将 AOF
重写缓冲区的指令，追加到新的AOF文件中，然后用新的AOF文件替换原来的AOF文件，这样也就保证了AOF文件和Redis的数据一致性。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311201538.png" style="zoom:60%;" /></p>
<p><strong>问题：</strong></p>
<p>整个过程会有风险吗？有。整个过程期间会有两个阶段会导致阻塞父进程：</p>
<ul>
<li>创建子进程期间，由于要复制父今晨更多页表等数据结构，阻塞时间跟页表的大小有关，页表越大，阻塞时间越长</li>
<li>创建子进程后，若子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，若内存越大（会有大Key问题），自然阻塞的时间越长。</li>
</ul>
<h2 id="rdb和aof合体">3、RDB和AOF合体</h2>
<h3 id="相关概念-2">【1】相关概念</h3>
<p>即将RDB和AOF合体使用，该方法也叫做<strong>混合使用AOF日志和内存快照</strong>，也叫<strong>混合持久化</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes	</span><br></pre></td></tr></table></figure>
<h3 id="过程">【2】过程</h3>
<p>缓和持久化工作在<strong>AOF日志重写过程</strong>。<br>当开启了混合持久化，在AOF重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，然后主线程的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以AOF方式写入到AOF文件，写入完成后通知主进程将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。</p>
<p>换句话说，使用了混合持久化，AOF文件的前半部分时RDB格式的全量数据，后半部分时AOF格式的增量数据。</p>
<h1 id="五redis实现秒杀">五、Redis实现秒杀</h1>
<h2 id="全局唯一id">1、 全局唯一id</h2>
<p>在分布式系统中，生成全局唯一id是一个常见且重要的需求，唯一ID的生成需要满足高并发、全局唯一性和高可用性。</p>
<h3 id="需要具备的特点">（1）需要具备的特点</h3>
<ul>
<li>全局唯一性：生成的ID在整个系统中必须是唯一的，避免冲突。</li>
<li>高可用性：生成ID的服务必须具备高可用性，确保在高并发场景下不出现性能瓶颈</li>
<li>有序性：在某些场景下，需要生成的ID有一定的顺序性，以便进行排序和分析</li>
<li>高性能：生成ID的过程需要高效，能够支持高并发请求</li>
<li>安全性：生成ID要不容易被摸索出规律，防止网络攻击</li>
</ul>
<p>Redis生成全局唯一id，这是用Redis自增的方法，我们还需要拼接上其他东西，比如时间戳之类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);	</span><br></pre></td></tr></table></figure>
<h2 id="超卖问题">2、超卖问题</h2>
<h3 id="问题描述">（1）问题描述</h3>
<p> 
一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是最基本的问题。</p>
<h3 id="产生原因">（2）产生原因</h3>
<p> 
在多个用户同时发起对同一个商品的下单请求时，先查询商品库存，再修改商品库存，会出现资源竞争问题，导致库存的最终结果出现异常。问题：
当商品A一共有库存15件，用户甲先下单10件，用户乙下单8件，这时候库存只能满足一个人下单成功，如果两个人同时提交，就出现了超卖的问题。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310094729.png" style="zoom:67%;" /></p>
<h3 id="解决方案-3">（3） 解决方案</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310095101.png" style="zoom: 60%;"></p>
<h4 id="悲观锁">【1】 悲观锁</h4>
<p> 
悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁</p>
<h4 id="乐观锁">【2】 乐观锁</h4>
<p> 会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1
，如果大1
，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1
，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas.</p>
<p> 乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5
是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 ==
内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值。 其中do
while
是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CAS一般是Java虚拟机在实现JUC的时候使用的，Java在UnSafe文件中编写了很多直接调用系统底层函数的功能方法，该类中就实现了CAS。</p>
<p>对于一般的超卖问题，主流方法还是使用乐观锁或者基于Redis的lua脚本进行解决</p>
</blockquote>
<h3 id="衍生改良">（4）衍生改良</h3>
<h4 id="问题">【1】问题</h4>
<p> 对于电商的超卖问题，如果只是简单让程序在扣减库存时，判断库存与操作前的数值是否一致，会导致其他大量并发操作失败。比如现在有100个进程打进来，查询到剩余的库存都是1000个，经过一顿操作后，现在要执行扣减库存的操作。此时我们采用了乐观锁进行更新，如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set 库存 = 库存 - 1 where id = 1 and 库存 = 1000</span><br></pre></td></tr></table></figure>
<p> 如果更新方式如上所述，那么程序在运行时，因为我们的程序并没有像CAS那样子实现自旋操作，所以这打进来的100个进程就只有一个会成功。这对用户的使用体验是非常不好的。</p>
<h4 id="解决">【2】解决</h4>
<p>我们需要改良一下数据库的执行操作，对于库存而言，只要库存大于0，我们就能卖。所以，没必要每个线程更新时都要确保当前库存跟操作前的库存一样，于是可以调整代码成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set 库存 = 库存 - 1 where id = 1 and 库存 &gt; 0</span><br></pre></td></tr></table></figure>
<h2 id="一人一单">3、一人一单</h2>
<h3 id="问题描述-1">（1）问题描述</h3>
<p>  很多时候有些商家要拿出一部分好用且贵重的产品来做促销引流，而将该物品进行低价售出，此时为了防止有人恶意低买高卖以及保证引流的效果，我们要保证一个用户只能买一次，也就一人一单.</p>
<h3 id="产生原因-1">（2）产生原因</h3>
<p> 一人一单的实现步骤是在原来下单逻辑的判断库存是否足够之后去查询数据库看是否该用户的是否已经存在订单，如果存在则不能下单成功，如果不存在则继续下单。</p>
<p> 由于该物品的特殊性，当开始秒杀时的并发量是极高的，这就会产生这样的问题，多个线程查询库存后判断该用户是否存已经存在订单时，此时这些线程都没有查询到订单信息说明该用户未下过单，让这些线程进行后续下单操作，但是在查询后有线程下单成功了，但是其他线程已经判断为未下过单，还在进行后续的下单操作，这就导致一个用户下单好几次</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310134922.png" style="zoom:50%;" /></p>
<h3 id="解决方案-4">（3）解决方案</h3>
<p>【1】解决一</p>
<p> 可以将上述的<strong>查询是否下过单与后续的库存扣减操作进行加锁</strong>。但在加锁时需要控制好锁的粒度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="comment">// 查询是否已经下单</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【2】问题一</p>
<p> 如果给方法加锁，对于每一个用户进程，进入程序时都需要进行锁竞争，这样对导致同一时间只有一个用户的进程可以执行操作，直接把并发执行变成了用户排队执行（串行执行）</p>
<p>【3】解决二</p>
<p> 一人一单的线程安全问题，其实是单个用户在同一时间触发了多个线程访问的问题，所以我们加锁的粒度可以针对单个用户进行加锁，那么，我们可以获取用户id，对用户id进行加锁。需要注意的时，用户id是一个String的字符串变量，如果我们直接使用userId.toString()
他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法。我们的代码就可以修改成如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactionl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 查询是否已经下单</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 扣减库存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【4】问题二</p>
<p>  上述加锁在很大程度上保证了一人一单的线程安全问题，但是还有一种情况，就是上述我们提到的线程1进行操作后把锁释放了，但是事务还没提交也就是数据库中已下单还没有订单信息，此时线程2获取到了锁，查询数据库中是否存在订单信息时没有查询到，于是又去进行了扣减库存操作，此时该用户一个人又下了多单。</p>
<p>【5】解决三</p>
<p>  上述问题产生的原因是，锁释放在事务提交之前。我们需要做的就是保证锁释放在事务提交之后，我们可以将加锁的位置进行修改，在调用该方法的地方进行加锁。修改后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询库存判断是否足够</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 查询是否已下单与扣减库存</span></span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        createVoucherOrder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Transactionl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询是否已经下单</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 扣减库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式问题">（4）分布式问题</h3>
<p> 上述悲观锁解决思路可以解决单机环境下的线程安全问题，但是在集群模式下就不行了，在不同的服务器进行部署该服务时，由于不同服务器有着不同的JVM，其线程锁的监视器也不同，所以加锁不能解决集群环境下的安全问题</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141541.png" style="zoom:50%;" /></p>
<h2 id="分布式锁">4、分布式锁</h2>
<h3 id="基本原理">（1）基本原理</h3>
<p> 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁需要具备多进程可见、互斥、高可用、高性能、安全性等特点。分布式锁的核心思想是让各个服务器使用同一把锁，只要使用的都是同一把锁，就能锁住线程，不让线程执行。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141854.png" style="zoom:50%;" /></p>
<h3 id="基本方法">（2）基本方法</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310142616.png" style="zoom:67%;" /></p>
<h3 id="实现代码">（3）实现代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁，并设置超时时间，防止死锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在问题">（4）存在问题</h3>
<h4 id="redis分布式锁误删">【1】Redis分布式锁误删</h4>
<p><strong>问题：</strong>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143057.png" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143251.png" style="zoom:50%;" /></p>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分布式锁原子性问题">【2】分布式锁原子性问题</h4>
<p><strong>问题：</strong>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143500.png" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>那就是使用Redis提供的Lua脚本，把<strong>判断锁和释放锁变成一个原子操作</strong></p>
<p>实现代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- &lt; unlick.lua &gt;</span></span><br><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分布式锁--redission">5、分布式锁--Redission</h2>
<h3 id="引言">（1）引言</h3>
<p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指
获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong>
如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144256.png" style="zoom:50%;" /></p>
<h3 id="什么是redission">（2）什么是Redission</h3>
<p> Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory
Data
Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144414.png" style="zoom: 80%;" /></p>
<h3 id="分布式锁redisson---可重入锁原理">（3）分布式锁Redisson--
可重入锁原理</h3>
<blockquote>
<p>ReentrantLock实现可重入锁原理：借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1
。</p>
<p>如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1
，直到减少成0 时，表示当前这把锁没有被人持有。</p>
</blockquote>
<p> 其实实现的原理跟ReentrantLock是一样的，都是借助计数变量，记录重入次数，实现可重入。实现原理大致是这样的：采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，最终的value记录的就是重入次数。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310145407.png" style="zoom:50%;" /></p>
<p><strong>代码实现：</strong>Redission底层实现可重入锁，也是借助了Lua脚本实现的，这样可以保证其执行的原子性。</p>
<p>——加锁实现代码：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310151049.png" style="zoom: 67%;" /></p>
<p>——释放锁实现代码：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311140348.png" style="zoom:67%;" /></p>
<h3 id="分布式锁ression-锁重试和watchdog机制">（4）分布式锁Ression ——
锁重试和WatchDog机制</h3>
<blockquote>
<p>获取锁失败，就会启动【锁重试】机制，不断询问锁是否释放。
获取锁成功，就会启动【WatchDog机制】，保证当前线程的任务执行完成。</p>
</blockquote>
<h4 id="原理">【1】原理</h4>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310165123.png" style="zoom:67%;" /></p>
<h4 id="源码解析">【2】源码解析</h4>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span></span><br></pre></td></tr></table></figure>
<p>waitTime –
获取锁的最大等待时间，<strong>不设置就只尝试获取锁一次，不会重试</strong>
leaseTime –
租约时间，约定使用锁时间，到期锁自动释放。不设定则会自动采用看门狗机制，自动续费
unit – 时间单位</p>
</blockquote>
<p>①
抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这线程已经抢锁完毕，或者可重入完毕。但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，可以发现有个while(
true) 再次进行tryAcquire进行抢锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② tryAcquire中有条件分支，如果 leaseTime 为
-1，则表示不设定租锁时间，也就是这把锁得借到当前进程执行完成后才能释放。那Redission是怎么实现的呢？Redission也是照常会去获取锁，有所区别的是，如果不设定租锁时间(leaseTime)，那么Redission
会启动看门狗机制，自动延长租锁时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设定了租锁时间，那就将其设置为借锁的时间，到期锁自动释放</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不设置，就启用看门狗机制</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                                         commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                                         TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 看门狗机制刷新租锁时间</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③
看门狗逻辑：因为【看门狗机制】锁的失效时间是30s，当10s之后，此时这个timeTask
就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约。那么假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式锁redission-mutilock原理">（5）分布式锁Redission ——
MutiLock原理</h3>
<blockquote>
<p>解决主从一致性问题！</p>
</blockquote>
<h4 id="原理-1">【1】原理</h4>
<p> 为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例。此时我们去写命令，写在主机上，
主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163322.png" style="zoom:50%;" /></p>
<p> 为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的，
这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163403.png" style="zoom:40%;" /></p>
<h4 id="源码解析-1">【2】源码解析</h4>
<p>① 创建联锁 multilock，就是将传入的lock用一个数组去存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;RLock&gt; locks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedissonMultiLock</span><span class="params">(RLock... locks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (locks.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Lock objects are not defined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.locks.addAll(Arrays.asList(locks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 获取锁时，会挨个访问每个节点，对每个节点，都获取一遍锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">// 若获取锁失败，则会释放掉已经获取的那些节点的锁</span></span><br><span class="line">    <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">        time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            unlockInner(acquiredLocks);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置了重试机制</span></span><br><span class="line">    <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        unlockInner(acquiredLocks);</span><br><span class="line">        <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有设置等待获取锁时间，表示只想获取一次，则获取失败的话直接退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是了等待时间</span></span><br><span class="line">        failedLocksLimit = failedLocksLimit();</span><br><span class="line">        acquiredLocks.clear();</span><br><span class="line">        <span class="comment">// reset iterator</span></span><br><span class="line">        <span class="comment">// 重试的时候重新开始</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">            iterator.previous();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        failedLocksLimit--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取锁成功</span></span><br><span class="line"><span class="comment">// 若设置了租锁时间，会对每一个节点上的锁，设置一个锁的有效时间</span></span><br><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(acquiredLocks.size());</span><br><span class="line">    <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span><br><span class="line">        RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">        futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class="line">        rFuture.syncUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="六redis消息队列">六、Redis消息队列</h1>
<h2 id="认识消息队列">1、 认识消息队列</h2>
<p>即存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310172219.png" /></p>
<p>使用队列的好处在于<strong>解耦</strong>：所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message
Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<h2 id="基于list实现消息队列">2、 基于List实现消息队列</h2>
<h3 id="实现原理-1">（1）实现原理</h3>
<p>消息队列（Message
Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者
RPUSH 结合
LPOP来实现。不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310213814.png" /></p>
<h3 id="优缺点">（2）优缺点</h3>
<p>优点：① 利用Redis存储，不受限于JVM内存上限； ②
基于Redis的持久化机制，数据安全性有保证； ③ 可以满足消息有序性</p>
<p>缺点：① 无法避免消息丢失； ②只支持单消费者</p>
<h2 id="基于pubsub的消息队列">3、基于PubSub的消息队列</h2>
<h3 id="实现原理-2">（1）实现原理</h3>
<p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p>SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg
：向一个频道发送消息 PSUBSCRIBE pattern[pattern]
：订阅与pattern格式匹配的所有频道</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310213954.png" /></p>
<h3 id="优缺点-1">（2）优缺点</h3>
<p>优点：采用发布订阅模型，支持多生产、多消费</p>
<p>缺点：① 不支持数据持久化； ② 无法避免消息丢失； ③
消息堆积有上限，超出时数据丢失</p>
<h2 id="基于stream的消息队列">4、基于Stream的消息队列</h2>
<p>Stream 是 Redis 5.0
引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311084806.png" /></p>
<p>例如</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085207.png" /></p>
<p>读取消息的方式之一：XREAD</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085146.png" /></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085241.png" /></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085304.png" /></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314125756.png" /></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h2
id="基于stream的消息队列消费者组">5、基于Stream的消息队列—消费者组</h2>
<p>消费者组（Consumer
Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311091741.png" /></p>
<p>创建消费者组：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311091835.png" /></p>
<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其他命令：</p>
<p><strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>
<p><strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>
<p><strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>
<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：
<ul>
<li>"&gt;"：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul></li>
</ul>
<p>消费者监听消息的基本思路：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314125832.png" style="zoom:67%;" /></p>
<p>列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<h2 id="对比">6、对比</h2>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311092658.png" /></p>
<h1 id="七点赞收藏和关注">七、点赞、收藏和关注</h1>
<p>实现方式比较简单，都是通过利用Redis的set集合判断是否已经点赞、或者已经收藏、或者已经关注</p>
<p>这里贴一个demo代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关注实现</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">followUser</span><span class="params">(FollowAddVO addVO)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">channel</span> <span class="operator">=</span> addVO.getChannel();</span><br><span class="line">    <span class="comment">// 构造redis的key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">currentId</span> <span class="operator">=</span> ThreadLocalUtil.getCurrentId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FollowConstant.followKey + addVO.getUid();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">zScore</span> <span class="operator">=</span> redisUtils.zScore(key, currentId);</span><br><span class="line">    <span class="comment">// 先判断能不能关注</span></span><br><span class="line">    <span class="keyword">if</span> ((Objects.nonNull(zScore) &amp;&amp; CollectionConstant.OperateEnum.ON_COLL.getCode().equals(channel))</span><br><span class="line">        || (Objects.isNull(zScore) &amp;&amp; CollectionConstant.OperateEnum.DOWN_COLL.getCode().equals(addVO.getChannel()))) &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CollectionConstant.OperateEnum.ON_COLL.getCode().equals(channel)) &#123;</span><br><span class="line">        <span class="comment">// 实现关注逻辑，并将关注的关系加入到redis中</span></span><br><span class="line">        <span class="keyword">return</span> redisUtils.zAdd(key, currentId, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消关注</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionConstant.OperateEnum.DOWN_COLL.getCode().equals(addVO.getChannel())) &#123;</span><br><span class="line">        <span class="comment">// 实现取消关注的数据库逻辑，并将redis中的关注关系删除</span></span><br><span class="line">        <span class="keyword">return</span> redisUtils.zRemove(key, currentId) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八geo数据结构计算距离">八、GEO数据结构计算距离</h1>
<blockquote>
<p>使用Redis的GEO数据机构进行统计</p>
</blockquote>
<h2 id="geo数据结构基本用法">1、 GEO数据结构基本用法</h2>
<p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。
6.2.新功能</li>
</ul>
<h2 id="存入redis中的数据结构定义">2、存入Redis中的数据结构定义</h2>
<p> GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p> 但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105501.png" style="zoom:50%;" /></p>
<h1 id="九redis实现签到功能">九、Redis实现签到功能</h1>
<blockquote>
<p>使用Redis的BitMap实现</p>
</blockquote>
<h2 id="bitmap数据机构基本用法">1、BitMap数据机构基本用法</h2>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD
：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h2 id="实现原理-3">2、实现原理</h2>
<p> 我们按月来统计用户签到信息，签到记录为1，未签到则记录为0。把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示。Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是
2^32个bit位。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105928.png" /></p>
<h2 id="功能点实现">3、功能点实现</h2>
<p><strong>问题1：</strong>什么叫做连续签到天数？
从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311110039.png" /></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1
才是1，其他数字都是0
，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<h2
id="关于使用bitmap来解决缓存穿透的方案">4、关于使用BitMap来解决缓存穿透的方案</h2>
<p>实现原理跟布隆过滤器是基本一样的，都是通过Hash，将物料的主键id映射成位图能够记录的idx，然后在位图中标识出来。等要判断是当前查询主键id是否存在时，再将当前主键id进行Hash，看是否在位图中被标注。若被标注，则可以访问，若没有，则拒绝访问。布隆过滤器的区别主要是，可能布隆过滤器会多用几个Hash函数。</p>
<h1 id="十uv统计">十、UV统计</h1>
<h2 id="uv和pv">1、UV和PV</h2>
<ul>
<li>UV：全称Unique
Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page
View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<h2 id="hyperloglog-算法原理">2、HyperLogLog 算法原理</h2>
<p><a
href="https://juejin.cn/post/6844903785744056333#heading-0">参考文章</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网大厂推荐算法学习笔记</title>
    <url>/2025/03/13/Recommend/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【力扣】面试经典150题</title>
    <url>/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一力扣面试经典-150-题">一、力扣面试经典 150 题</h1>
<h2 id="数组字符串">1. 数组/字符串</h2>
<h3 id="合并两个有序数组">1.1 <a
href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">合并两个有序数组</a></h3>
<p>这道题目主要是利用到归并排序的思路，定义两个数组下标，比较数组对应的值，选择小的值插进新数组。需要注意的是，while
循环后还需要把剩下的数组遍历下去。这里还有一个点需要注意，就是 Java
的函数传参和数组赋值问题，Java
函数传递数组时，传进来的是数组地址，所以如果只是简单的给数组赋值新的数组，实际的数组并不会发生改变
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) res[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> res[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) res[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) res[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (m + n &gt;= <span class="number">0</span>) System.arraycopy(res, <span class="number">0</span>, nums1, <span class="number">0</span>, m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.2 <a
href="https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">移除元素</a></p>
<p>这个就是一个简单的双指针问题，我们只需要记录不等于给定值的下标，然后遍历数组，只要数值不等于给定值的数字，我们就使用初始定义的下标记录下来
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.3 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除有序数组中的重复元素</a></p>
<p>这道题目跟上面的题目一样，相当于上面是要记录不等于指定值，也就是重复值为
0。这道题目则是允许重复值为 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!record.contains(nums[i])) &#123;</span><br><span class="line">            record.add(nums[i]);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除有序数组中的重复项-ⅱ">1.4 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除有序数组中的重复项
Ⅱ</a></h3>
<p>这道题目也是跟上面题目一样的思路。上一道题目是允许重复值为
1，这道题目是允许重复值为 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!record.containsKey(nums[i])) &#123;</span><br><span class="line">            record.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(record.get(nums[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">            record.put(nums[i], <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多数元素">1.5 <a
href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">多数元素</a></h3>
<p>多数元素是出现次数超过数组长度一半的数。这道题目可以用相互抵消的思路来理解。因为它出现的次数多于总体一半，所以它与其他数出现次数相互抵消后，就一定还会存在这个数
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num) cnt++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                num = nums[i];   cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.6 <a
href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&amp;envId=top-interview-150">轮转数组</a></p>
<p>这道题目的主要思路是利用到数组反转的原理。其实原理很简单，要将数组中的元素整体向右移
k 个单位，只需要将整个数组，整体反转，然后分别反转前 k 位和后 k 位
<strong>eg：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;  end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.7 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机</a>
这道题目因为给了全部的天数数据，所以具有预知性，所以，我们可以从后开始遍历数组，记录后面哪一天是出价最高的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length, maxNum = prices[n-<span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res = Math.max(res, maxNum - prices[i]);</span><br><span class="line">        maxNum = Math.max(maxNum, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.8 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅱ</a>
因为可以多次购买，多次出售。这道题目跟前面的题目就不一样了。我们并不需要考虑什么时候出售，我们只需要在有差价，能挣钱的时候出售就可以
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>]) res += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.9 <a
href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&amp;envId=top-interview-150">跳跃游戏</a>
初看题目像是要遍历很多次，其实不用。我们只需要维护一个距离变量。表示从当前所在下标能到达的最远距离即可。若当前下标比最远距离还要大，说明前面的点，没办法到达当前下标的位置，也就是不可能完成这个跳跃任务，我们直接返回
false 即可 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.10 <a
href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">跳跃游戏
Ⅱ</a> 这一道题目的主要思路就是看当前所在位置能到达多远的距离，end
暂存下来，相当于从当前位置跳到 end
只需要一步，然后逐步更新能到达的最远距离。当当前位置到达 end
时，说明这一步能到达的最远距离已经更新完了，也就是需要再跳一次了，这样就能记录下所需要的最少跳数
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            res++;   end = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="h-指数">1.11 <a
href="https://leetcode.cn/problems/h-index/?envType=study-plan-v2&amp;envId=top-interview-150">H
指数</a></h3>
<p>这道题目其实用的是一个桶计数思路，但是这里有一个需要注意的是，当一篇文章的被引用次数超过实际数组长度时，我们只需要把它看成引用次数是数组长度就可以，这样可以减少很大的内存空间。然后桶主要记录的是引用次数对应出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> citation : citations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citation &gt; n) cnt[n]++;</span><br><span class="line">        <span class="keyword">else</span> cnt[citation]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        total += cnt[i];</span><br><span class="line">        <span class="keyword">if</span>(total &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="o1时间插入删除和获取随机元素">1.12 <a
href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&amp;envId=top-interview-150">O(1)时间插入、删除和获取随机元素</a></h3>
<p>这道题目主要用到一个 Hash 映射，通过可变数数组进行实现。但是这里用到
HashMap 集合，会让人感觉不是在 O(1)的时间内完成的操作。其实是 O(1)，因为
HashMap 的插入和删除，都是围绕下标进行，而 hash
获取下标只需要一个函数的映射操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(val);</span><br><span class="line">        map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.set(map.get(val), nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        map.put(nums.get(nums.size() - <span class="number">1</span>), map.get(val));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get(random.nextInt(nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除自身以外数组的乘积">1.13 <a
href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&amp;envId=top-interview-150">除自身以外数组的乘积</a></h3>
<p>这道题目本来可以用前缀积做，但是题目要求不能使用除法，所以这道题目需要在前缀积的基础上稍加改变一下。我们只需要定义一个中间变量，先将最终答案置为这个中间变量再进行前缀积，实现在当前位置赋值时，是前面变量的乘积。同时由于题目要求，是除当前位置的其他所有变量的乘积，所以需要从左向右走一遍，然后再从右向左走一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res[i] = left;</span><br><span class="line">        left = left * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        res[i] *= right;</span><br><span class="line">        right = right * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加油站">1.14 <a
href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&amp;envId=top-interview-150">加油站</a></h3>
<p>这道题目其实并不需要去每一个点进行探索，只需要计算 gas 和 cost
的差值的前缀和就能解决这个问题。<strong>因为只要差值
&gt;=0，就一定能绕圈走。</strong>所以我们的解题的最终目标变成了，探索从哪一个点开始出发。探索从哪个点开始出发也比较简单，我们看前缀和在哪里
&lt;0
了，说明在它前面的点出发是走不到当前的点的，所以出发点肯定需要从这个点的下一个点开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length, run = <span class="number">0</span>, sum = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        run += gas[i] - cost[i];</span><br><span class="line">        sum += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span> (run &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            run = <span class="number">0</span>;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= <span class="number">0</span> ? start : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分发糖果">1.15 <a
href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&amp;envId=top-interview-150">分发糖果</a></h3>
<p>两者兼顾很容易顾此失彼。如果想用一次遍历就解决问题，就必须时刻注意当前数左右两边的数，并且如果从左到右遍历，没发预测右边还未遍历的数字是否还会受到奖励。所以我们需要分开考虑，先走一遍从左到右，考虑左边数字对右边数字的影响，然后再走一遍从右到左，考虑右边数字对左边数字的影响。然后需要满足左边走得通，右边也得走得通，怎么办呢，各个位置上的数取从左到右，从右到左的最大值，就能实现两边都满足。</p>
<table>
<tr>
<td>
[1 0 2]<br/>[1 1 1] <br/>[1 1 2]<br/>[2 1 1]<br/>[2 1 2] 2+1+2 = 5<br/>
</td>
</tr>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        num1[i] = num2[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num1[i] = num1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            num2[i] = num2[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res += Math._max_(num1[i], num2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接雨水">1.16 <a
href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h3>
<p>这道题目的求解思路主要是，遍历数组，我们需要当前遍历位置，左边和右边最高的数值，然后对于这两个数值，去它们当中更小的那个数值（木桶效应），取出来之后需要减去当前位置的高度，算出差值。按照这种思路，我们需要多定义两个数组，分别记录当前位置左边的最大高度
leftMax[n]，和当前位置右边最大的高度
rightMax[n]，这样在遍历到当前位置时，当前位置的蓄水值为
min{rightMax[i],leftMax[i]} -
heigh[i]。然后我们会发现这种思路其实有一种更简洁的做法，我们不需要多定义两个额外的数组，只需要定义两个变量即可，分别记录
0...i 左边的最大高度 leftMax，和 i+1 ... n-1 的最大高度 rightMax，这样当
leftMax &lt; rightMax 时，我们更新左边；当 leftMax &gt; rightMax
时，我们更新右边；当 leftMax = rightMax
时，我们两边都更新。因为每次计算蓄水值时，我们都是拿 leftMax 和 rightMax
更小的那个值去更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, res = <span class="number">0</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightMax &lt; leftMax)&#123;</span><br><span class="line">            res += rightMax - height[right--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 两边都更新</span></span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right) &#123;</span><br><span class="line">                res += rightMax - height[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="罗马数字转整数">1.17 <a
href="https://leetcode.cn/problems/roman-to-integer/submissions/521990974/?envType=study-plan-v2&amp;envId=top-interview-150">罗马数字转整数</a></h3>
<p>比较简单的模拟题目...</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(array[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; map.get(array[i]) &lt; map.get(array[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            temp = map.get(array[i+<span class="number">1</span>]) - map.get(array[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数转罗马数字">1.18 <a
href="https://leetcode.cn/problems/integer-to-roman/?envType=study-plan-v2&amp;envId=top-interview-150">整数转罗马数字</a></h3>
<p>经典打表问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">            roman.append(symbols[i]);</span><br><span class="line">            num -= values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roman.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后一个单词的长度">1.19 <a
href="https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&amp;envId=top-interview-150">最后一个单词的长度</a></h3>
<p>模拟题，定义一个
StringBuilder，只需要从最后一个字符开始遍历，若不是空格，就开始记录下来，直到再遇到空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] == <span class="string">&#x27; &#x27;</span>) --i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] != <span class="string">&#x27; &#x27;</span>) res.append(charArray[i--]);</span><br><span class="line">    <span class="keyword">return</span> res.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共前缀">1.20 <a
href="https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&amp;envId=top-interview-150">最长公共前缀</a></h3>
<p>模拟问题，只需要算出字符串数组中最短的那个字符串长度，然后遍历这个长度，取出第一个字符串的字符，然后一一比对其他字符，如果一样就记录下来，如果不一样，就直接退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) len = Math.min(len, str.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strs.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != strs[j].charAt(i)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) res.append(ch);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转字符串中的单词">1.21 <a
href="https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">反转字符串中的单词</a></h3>
<p>这是一道简单的模拟题，我们只需要遍历一次给定的字符串，当遇到不是空格的字符时，把它记录下来，当再遇到空字符串时，我们把记录下来的这个字符串用列表记录下来。最后将整个列表反转一下，用
Collections 的 reverse 反转一下列表，就能实现反转单词的效果。然后再用
String 的 join 函数进行拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;String&gt; arr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s.charAt(i)!=<span class="string">&#x27; &#x27;</span> )&#123;</span><br><span class="line">                tmp.append(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections._reverse_(arr);</span><br><span class="line">    <span class="keyword">return</span> String._join_(<span class="string">&quot; &quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="z-字形变换">1.22 <a
href="https://leetcode.cn/problems/zigzag-conversion/description/?envType=study-plan-v2&amp;envId=top-interview-150">Z
字形变换</a></h3>
<p>这道题目看上去很复杂，其实我们只需要记录原字符串每一个字符应该放在哪一行就可以完成这个任务。比如</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/1.png" />
很明显，下标的规律就是先递增到指定 numRows - 1，然后再减少到
0。我们可以定义一个字符串数组，分别记录每一行需要记录的字符，最终将这些字符串数组拼接起来。这里有一个边界问题需要注意一下，就是当
numRows=1 时，实际上就是输出原来的字符串而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) index[i] = idx++;</span><br><span class="line">        <span class="keyword">else</span> index[i] = idx--;</span><br><span class="line">        <span class="keyword">if</span> (idx == numRows) &#123;</span><br><span class="line">            idx -= <span class="number">2</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            idx += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder[] arr = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>[numRows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) arr[i] = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[index[i]].append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) res.append(arr[i]);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出字符串中第一个匹配项的下标">1.23 <a
href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h3>
<p>这道题目是 KMP 的模板题目，抄模板即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> haystack.length(), n = needle.length();</span><br><span class="line">    <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>[] p = <span class="keyword">new</span> <span class="title class_">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) s[i + <span class="number">1</span>] = haystack.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) p[i + <span class="number">1</span>] = needle.charAt(i);</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 求Next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="双指针">2. 双指针</h2>
<h3 id="验证回文串">2.1 <a
href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=top-interview-150">验证回文串</a></h3>
<p>字符串处理的题目，这里可以直接用正则表达式完成。我们只需要定义需要保留字符的正则表达式，然后将不需要的字符替换成空字符串，然后将字符串整体转成小写，遍历一半字符串，看看另一半对应位置是否匹配即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = s.replaceAll(<span class="string">&quot;[^A-Za-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">2.2 <a
href="https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&amp;envId=top-interview-150">判断子序列</a></h3>
<p>这个题目直接用双指针就能完成，一层 for
循环遍历给定串，再定义目标串下标，若字符相同，则目标串下标往后移动；若到达目标串最后一位，则直接输出。需要判断的边界是，当两个字符串存在是空字符串的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.charAt(i) == s.charAt(idx)) idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数之和-ⅱ---输入有序数组">2.3 <a
href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和
Ⅱ - 输入有序数组</a></h3>
<p>这个是经典的双指针问题，因为它是有序数组，所以只需要定义头和尾数组，然后往中间靠就能完成这道题目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] == target) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="盛最多水的容器">2.4 <a
href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-interview-150">盛最多水的容器</a></h3>
<p>木桶效应，我们最终能盛最多水的容器取决于两根柱子中最短的那一根，并且取决于两根柱子之间的距离。使用双指针，定义前后两根柱子的位置，然后通过贪心的方法，取出最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        res = Math.max(Math.min(height[i], height[j]) * (j - i), res);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三数之和">2.5 <a
href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-interview-150">三数之和</a></h3>
<p>这道题目我主要用到两数之和的思想，三数之和为
0，只要把第三个数确定了，实际问题就变成了两数之和问题。因为两数之和给的是有序数组，所以，我们在这里需要先进行一个排序操作。然后枚举第一个数，再用两数之和的方法求出第二三个数出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span> - nums[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) ++i;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) --j;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) ++i;</span><br><span class="line">            <span class="keyword">else</span> --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="滑动窗口">3. 滑动窗口</h2>
<h3 id="长度最小的子数组">3.1 <a
href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">长度最小的子数组</a></h3>
<p>这道题目用到了前后滑动指针和前缀和的原理，设定一个前后指针和一个记录前缀和的变量。前缀和的变量记录前后指针之间的前缀和，当前缀和
&gt;=target 时，我们就记录距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE, l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = Math.min(r - l, res);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无重复字符的最长子串">3.2 <a
href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h3>
<p>有点像双指针的题目，记录一前一后两个指针，当前面的指针遍历到一个字符重复出现两次时，后面的指针往前移动，同时减少后面指针所指字符出现的次数，知道前面指针所指的字符重复出现次数
&lt;2 后，再移动前面的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">    Arrays.fill(cnts,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i)]++;</span><br><span class="line">        <span class="keyword">while</span> (cnts[s.charAt(i)] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            cnts[s.charAt(j)]--;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子串">3.3 <a
href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h3>
<p>两种解题思路，一种是利用动态规划，另外一种是利用双指针。我们一一讲解</p>
<p>——动态规划（五部曲）</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/db927238-7243-42da-b265-cf3c5e695c92.png" />
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/82efdcc2-127a-476b-ba29-579c97b65486.png" /></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">10</span>][s.length() + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; ++j) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i) &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">                res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——双指针</p>
<p>从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extend(s, i, i);</span><br><span class="line">        extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extend</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; str.length() &amp;&amp; str.charAt(l) == str.charAt(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            len = r - l + <span class="number">1</span>;</span><br><span class="line">            left = l;</span><br><span class="line">            right = r;</span><br><span class="line">        &#125;</span><br><span class="line">        --l;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回文子串">3.4 <a
href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a></h3>
<p>双指针直接把题目秒了，从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止。扩散之后如果是回文，结果数就
+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extendStr(s, i, i);</span><br><span class="line">        extendStr(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendStr</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;str.length() &amp;&amp; str.charAt(l) == str.charAt(r))&#123;</span><br><span class="line">        res++;</span><br><span class="line">        --l;  ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找到字符串中所有字母异位词">3.5 <a
href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h3>
<p>滑动窗口题目，在原字符串 s 上进行滑动，滑动窗口的大小是给定字符串 p
的长度，然后设定一个数组，记录滑动窗口中字符出现的个数，再设定一个变量值记录滑动窗口内的字母和给定字符串
p 是否有差别，如果没有差别，则将对应的下标记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length(), differ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30000</span>];</span><br><span class="line">    Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pLen &gt; sLen) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnts[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnts[i] != <span class="number">0</span>) differ++;</span><br><span class="line">    <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnts[ch];</span><br><span class="line">        ch = s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnts[ch];</span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="串联所有单词的子串">3.6 <a
href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&amp;envId=top-interview-150">串联所有单词的子串</a></h3>
<p>这道题目跟上面那道题目很像，但又不太一样。上面那道题目是字母，这题目是单词。官方的题解属实没看懂，放一版最后一个样例会超时的版本的，后续再优化一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), listLen = words.length, wordLen = words[<span class="number">0</span>].length(), totalLen = wordLen * listLen;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - totalLen + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; tmpMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + totalLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; totalLen; k += wordLen) &#123;</span><br><span class="line">            tmpMap.put(tmp.substring(k, k + wordLen), tmpMap.getOrDefault(tmp.substring(k, k + wordLen), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmpMap.equals(map)) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="矩阵">4. 矩阵</h2>
<h3 id="有效数独">4.1 <a
href="https://leetcode.cn/problems/valid-sudoku/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效数独</a></h3>
<p>这道题目有点像八皇后，与八皇后的区别是，现在是局限于一个 9<em>9
的矩阵中。所以我们可以定义一个 3</em>3<em>9 的矩阵，把原来 9</em>9
的矩阵分割成这样子，其中每个 9 代表记录一个 3<em>3
矩阵中的数出现的次数。现在问题在于，我们现在有数在 9</em>9 矩阵中的坐标
(i,j)， 怎么定位到自己独立 3*3 矩阵中？我们会发现
(i/3,j/3)，下面这些坐标 (0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1)
(2,2) 分别对应我们下面这 9 个矩阵的位置 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202532.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span>[][] cols = <span class="keyword">new</span> <span class="title class_">int</span>[n][n], rows = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span>[][][] nine = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">            cols[i][idx]++;</span><br><span class="line">            rows[j][idx]++;</span><br><span class="line">            nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx]++;</span><br><span class="line">            <span class="keyword">if</span> (cols[i][idx] &gt; <span class="number">1</span> || rows[j][idx] &gt; <span class="number">1</span> || nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="螺旋矩阵">4.2 <a
href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-interview-150">螺旋矩阵</a></h3>
<p>这个就是一个模拟题，我们根据题目，先往右，再往下，再往左，再往上。需要先定义方向导致的坐标变更，然后定义走到的坐标，我们先将坐标对应位置上的数加入到结果中，然后再试探性的往下走一步，看会不会越界。这里有个问题需要注意一下，我们走过的点不能再走，所以我们需要定义一个访问的
boolean
数组，表示位置是否被访问。当我们试探性的往下走一步发现走不下去的时候，我们就需要变更方向了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>, colIdx = <span class="number">0</span>, rowIdx = <span class="number">0</span>, newCol = <span class="number">0</span>, newRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n * m; ++i) &#123;</span><br><span class="line">        res.add(matrix[colIdx][rowIdx]);</span><br><span class="line">        vis[colIdx][rowIdx] = <span class="literal">true</span>;</span><br><span class="line">        newCol = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        newRow = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newCol &lt; <span class="number">0</span> || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newRow &gt;= m || vis[newCol][newRow]) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colIdx = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        rowIdx = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转图像">4.3 <a
href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&amp;envId=top-interview-150">旋转图像</a></h3>
<p>这个题目是数字位置变换的题目，我们通过观察可以发现，旋转后的数字位置，其实是原来矩阵先进行上下翻转，然后，再将下三角的数跟其坐标相反的数进行交换。比如
(i,j) 换到 (j,i)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 先上下反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - <span class="number">1</span> - i][j];</span><br><span class="line">            matrix[n - <span class="number">1</span> - i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后再将下三角的数，与横纵坐标相反的位置的数交换位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵置零">4.4 <a
href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&amp;envId=top-interview-150">矩阵置零</a></h3>
<p>直接记录原矩阵数值为 0
的位置，用列表存储对应的(i,j)，然后遍历记录的列表，就能实现题目要求的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; coordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) coordinates.add(Arrays.asList(i, j));</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; coordinate : coordinates) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> coordinate.get(<span class="number">0</span>), col = coordinate.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) matrix[row][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命游戏">4.5 <a
href="https://leetcode.cn/problems/game-of-life/?envType=study-plan-v2&amp;envId=top-interview-150">生命游戏</a></h3>
<p>模拟问题，新建一个新地图，然后根据规则在老地图遍历，并对新地图赋值。最后把新地图的数值复制给老地图即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] newBoard = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; direction.length; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[k][<span class="number">0</span>], col = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= n || col &lt; <span class="number">0</span> || col &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &lt; <span class="number">2</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (cnt == <span class="number">2</span> || cnt == <span class="number">3</span> )) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &gt; <span class="number">3</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第四种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; cnt == <span class="number">3</span>) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; n;++i) <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;m;++j) board[i][j] = newBoard[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="哈希表">5. 哈希表</h2>
<h3 id="赎金信">5.1 <a
href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&amp;envId=top-interview-150">赎金信</a></h3>
<p>这道题目只需要用桶的思路，记录 <code>magazine</code>
每个字符出现的次数，然后再遍历 <code>ransomNote</code>
看出现字符次数是否超过 <code>magazine</code> 字符出现的次数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] magazineCharCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(Character ch : magazine.toCharArray()) magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(Character ch: ransomNote.toCharArray()) &#123;</span><br><span class="line">        magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同构字符串">5.2 <a
href="https://leetcode.cn/problems/isomorphic-strings/?envType=study-plan-v2&amp;envId=top-interview-150">同构字符串</a></h3>
<p>定义两个 Hash 映射就能解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Character&gt; lTor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Character&gt; rTol = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lTor.get(s.charAt(i))!=<span class="literal">null</span> &amp;&amp; lTor.get(s.charAt(i)) != t.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rTol.get(t.charAt(i))!= <span class="literal">null</span> &amp;&amp; rTol.get(t.charAt(i)) != s.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lTor.put(s.charAt(i), t.charAt(i));</span><br><span class="line">        rTol.put(t.charAt(i), s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词规律">5.3 <a
href="https://leetcode.cn/problems/word-pattern/?envType=study-plan-v2&amp;envId=top-interview-150">单词规律</a></h3>
<p>与上一道题目是一样的，只需要将字符串按照空格切分成单词，再定义两个
Hash
映射就能解决问题。不过这里需要注意一下给定单词的长度应该和切分出来的单词列表的长度一致，不然会出现以下这种情况。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202615.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, String&gt; ltoR = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Character&gt; rtoL = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    String[] strList = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(strList.length != pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltoR.get(pattern.charAt(i))!=<span class="literal">null</span> &amp;&amp; !ltoR.get(pattern.charAt(i)).equals(strList[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rtoL.get(strList[i])!=<span class="literal">null</span> &amp;&amp; !rtoL.get(strList[i]).equals(pattern.charAt(i))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ltoR.put(pattern.charAt(i), strList[i]);</span><br><span class="line">        rtoL.put(strList[i], pattern.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有效字母的异位词">5.4 <a
href="https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效字母的异位词</a></h3>
<p>这个题目更简单，跟<a
href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&amp;envId=top-interview-150">赎金信</a>是一样的，只需要把第一个单词中每个字母出现的次数记录下来，在第二个单词遍历的时候减去对应字母的次数，最后再遍历一下记录数组，看是否全为
0，即可判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (Character ch : t.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (Character ch : s.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字母异位词分组">5.5 <a
href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&amp;envId=top-interview-150">字母异位词分组</a></h3>
<p>这道题目按照以往的做法，需要判断各个字符串出现的字母次数是否一致，才能归为一类。但实际上我们可以将字符串中的字母先进行排序，将不通字母排序的字符串变成统一，然后再用
Hash 记录对应的组别。<strong><em>主要是排序</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);     <span class="comment">// 很关键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(sorted, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(sorted, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数之和">5.6 <a
href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;envId=top-interview-150">两数之和</a></h3>
<p>可以使用双指针做，也可以用 Hash
完成。双指针的话，需要先对给定的数组进行排序，然后指针从最左边和最右边开始移动。Hash
的话会比较快，记录目标值 - 当前值，映射当前值对应的下标，等遇到 目标值 -
当前值时，返回对应 Hash 映射和对应的下标即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">        map.put(target - nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快乐数">5.7 <a
href="https://leetcode.cn/problems/happy-number/?envType=study-plan-v2&amp;envId=top-interview-150">快乐数</a></h3>
<p>打表 YYDS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isHappy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        tmp = n;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n += (tmp % <span class="number">10</span>) * (tmp % <span class="number">10</span>);</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>) &#123;</span><br><span class="line">            isHappy = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHappy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在重复元素">5.8 <a
href="https://leetcode.cn/problems/contains-duplicate/">存在重复元素</a></h3>
<p>HashSet
去重，如果不能插入，说明有重复，重复直接返回存在重复元素，返回 True</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) <span class="keyword">if</span>(!set.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在重复元素-ⅱ">5.9 <a
href="https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">存在重复元素
Ⅱ</a></h3>
<p>用 Hash
记录数的下标，遇到重复的就看与之前存入的下标符不符合要求，不符合就更新下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; i - map.get(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长连续序列">5.10 <a
href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-interview-150">最长连续序列</a></h3>
<p>排序 + 哈希。如果比当前数字小 1 的数字在 map
映射中存在的话，当前数字的长度就是比他小的数字的长度 +1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            map.put(num, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> map.put(num, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="区间">6. 区间</h2>
<h3 id="汇总区间">6.1 <a
href="https://leetcode.cn/problems/summary-ranges/?envType=study-plan-v2&amp;envId=top-interview-150">汇总区间</a></h3>
<p>双指针，记录一个能到达最右边的指针，往右走到不再连续。然后判断与原指针是否相等，相等就只新增原来的数；不相等就插入箭头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[high] + <span class="number">1</span> == nums[high + <span class="number">1</span>]) high++;</span><br><span class="line">        <span class="keyword">if</span> (high == i) res.add(String.valueOf(nums[i]));</span><br><span class="line">        <span class="keyword">else</span> res.add(String.valueOf(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + String.valueOf(nums[high]));</span><br><span class="line">        i = high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并区间">6.2 <a
href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&amp;envId=top-interview-150">合并区间</a></h3>
<p>思路跟上面的题目一样，也是遍历给定的数组，然后设定一个最右边能到达的指针下标，然后等这个指针不能再往右边走时，就把对应的区间加入到最终的结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入区间">6.3 <a
href="https://leetcode.cn/problems/insert-interval/?envType=study-plan-v2&amp;envId=top-interview-150">插入区间</a></h3>
<p>这道题目是上面那道题目的扩展，思路很简单，先把要插入的区间插入到给定的数组中，然后再执行一遍上一道题目的那个函数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="comment">// 使用ArrayList创建一个可以修改大小的列表</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intervals));</span><br><span class="line">    tmpList.add(newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将列表转换回数组，并进行排序</span></span><br><span class="line">    intervals = tmpList.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[tmpList.size()][]);</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用最少数量的箭引爆气球">6.4 <a
href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&amp;envId=top-interview-150">用最少数量的箭引爆气球</a></h3>
<p>这道题目也是边界判断延续问题，不同点是我们要尽量让区间右端点尽可能的包含更多的区间。所以我们需要按照区间右端点进行升序排序，然后看当前区间的右端点，能包含多少区间的左端点，被包含的区间直接跳过即可。这里会存在一个数的极限问题，就是一个整数减去一个负数，会爆
Integer 边界，所以在排序的时候应该使用 Integer._compare 比较函数_</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] != b[<span class="number">1</span>] ? Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]) : Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    <span class="type">long</span> <span class="variable">high</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        high = Math.max(high, points[i][<span class="number">1</span>]);</span><br><span class="line">        right = i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; high &gt;= points[right][<span class="number">0</span>]) right++;</span><br><span class="line">        res++;</span><br><span class="line">        i = right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="栈">7. 栈</h2>
<h3 id="有效括号">7.1 <a
href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效括号</a></h3>
<p>存入当前括号对应的反括号，为什么呢？因为如果式子有效的话，当前括号的反括号在当前位置后面一定会出现，当我们比对不匹配时，我们便可以得出当前串存在问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.lastElement() != ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化路径">7.2 <a
href="https://leetcode.cn/problems/simplify-path/?envType=study-plan-v2&amp;envId=top-interview-150">简化路径</a></h3>
<p>用栈存放路径名称，不存放“/”，然后对于 ..
的路径，表示的是返回上一层的路径，所以我们可以把栈顶元素弹出，相当于回到了上一层。最后再用“/”将栈中元素进行拼接即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    String[] strList = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(str) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;.&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;..&quot;</span>.equals(str)) stack.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        res.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        res.insert(<span class="number">0</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.isEmpty()) res.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小栈">7.3 <a
href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&amp;envId=top-interview-150">最小栈</a></h3>
<p>存一个普通栈和一个最小栈，当一个新的数来的时候，普通栈直接压入，最小栈则跟栈顶元素比较一下，压入更小的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; xstack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        xstack.push(val);</span><br><span class="line">        minStack.push(Math.min(val,minStack.lastElement()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆波兰表达式求值">7.4 <a
href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&amp;envId=top-interview-150">逆波兰表达式求值</a></h3>
<p>这个已经将表达式转成后缀表达式了，我们并不需要判断运算符的优先级问题。我们只需要定义一个数字栈，遇到数字入栈，遇到符号，取出栈顶的两个元素，根据运算符号进行计算，把计算结果压入栈中，最后栈顶便为最终计算结果，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;+&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;-&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;*&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">            nums.push(Integer.parseInt(token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums.pop(), num2 = nums.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token)) nums.push(num1 + num2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(token)) nums.push(num2 - num1);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(token)) nums.push(num1 * num2);</span><br><span class="line">            <span class="keyword">else</span> nums.push(num2 / num1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本计算器">7.5 <a
href="https://leetcode.cn/problems/basic-calculator/?envType=study-plan-v2&amp;envId=top-interview-150">基本计算器</a></h3>
<p>这道题目因为只有加减运算，所以可以把它同意看成是加法运算，对于减法运算，我们可以看成是加上减去的那个数的相反数。这样我们只需要定义一个存储符号的栈，遇到(压栈，遇到)弹栈，遇到加号，符号为
1，遇到减号，符号为 0 。遇到数字，加上数字与符号的乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length(), res = <span class="number">0</span>, sign = <span class="number">1</span>;   <span class="comment">// sign 为 1 表示是正数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            sign = stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(sign);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                tmp = tmp * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            res += sign * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="链表">8. 链表</h2>
<h3 id="环形链表">8.1 <a
href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&amp;envId=2cktkvj&amp;page=1">环形链表</a></h3>
<p>这是一道经典的问题，我们只需要定义一快一慢两个指针，快指针每次走两步，慢指针每次走一步。如果链表中存在环，那么快指针一定跟慢指针相遇。如果链表中不存在环，那么快指针一定会以最快的速度到达尾指针，也就是
null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head, high = head;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="literal">null</span>) &#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="keyword">if</span>(high.next!=<span class="literal">null</span> &amp;&amp; high.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                high = high.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(high == low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数相加">8.2 <a
href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">两数相加</a></h3>
<p>其实跟高精度计算是同一个思路。就是模拟数字笔算相加的过程，定义进位变量，存储最终链表头文件，在加上类似于归并排序的合并两个数组的思路，合并两个链表。最后由
add 是否大于 0，在决定是否添加新的结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> l1, n2 = l2, tmp = <span class="literal">null</span>, res = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span> ,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = (n1.val + n2.val + add);</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n1.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n2.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(add &gt; <span class="number">0</span>) tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(add);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个有序链表">8.3 <a
href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&amp;envId=top-interview-150">合并两个有序链表</a></h3>
<p>跟归并排序同一个思路，分别记录两个链表的两个指针，哪个链表的指针指向的值小，就记录哪个值，并移动对应的指针。最后，当两个链表有一方遍历完成，则只需将另一方剩余的链表加入到结果链表中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>, tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(list1) &amp;&amp; Objects.nonNull(list2)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(res)) res = tmp.next;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list1)) tmp.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list2)) tmp.next = list2;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(res)? tmp.next : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机链表的复制">8.4 <a
href="https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&amp;envId=top-interview-150">随机链表的复制</a></h3>
<p>—— 回溯 + 哈希</p>
<p>本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p>
<p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p>
<p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Node, Node&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cacheMap.containsKey(head)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        cacheMap.put(head, newHead);</span><br><span class="line">        newHead.next = copyRandomList(head.next);</span><br><span class="line">        newHead.random = copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheMap.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表">8.5 <a
href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h3>
<p>——模拟</p>
<p>我们只需要定义一前一后两个指针，然后保留后一个指针的 next
地址【newNode】，将后一个指针的 next
指向前一个指针，前一个指针再移动到后一个指针的位置，后一个指针移动到
newNode。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表-ⅱ">8.6 <a
href="https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">反转链表
Ⅱ</a></h3>
<p>——模拟</p>
<p>这道题目思路不复杂，就是根据函数参数提供的位置，把要反转的那部分链表切出来，同时记录要反转的那部分链表的前后节点（因为把反转后的链表放回原链表需要这两个节点）</p>
<p>具体实现需要注意定义虚拟头指针，因为这道题目的数据中，头指针很有可能也是要被反转的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-个一组反转链表">8.7 <a
href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&amp;envId=top-interview-150">K
个一组反转链表</a></h3>
<p>这道题目第一次看上去跟上面的题目是同个思路，基本就是上面题目加个 for
循环的变体。我们在这里只需要知道链表的长度，然后每 k
个单位长度，调用上一问的函数反转一下，然后把反转后的链表重新赋值给
head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 获得链表总长度</span></span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        head = reverseBetween(head, i+<span class="number">1</span>, i + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第-n-个结点">8.8 <a
href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除链表的倒数第
N 个结点</a></h3>
<p>——模拟</p>
<p>先计算链表总共有几个结点，然后遍历到链表的倒数第 N
个结点的前一个结点，然后将结点的 next 赋值为 next.next 就可以。</p>
<p>实现的时候需要注意一下定义虚拟头结点，因为头结点有可能就是要被删除的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    tmp = dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - n; ++i) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = tmp.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素">8.9 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h3>
<p>——模拟</p>
<p>定义前后两个指针，若后指针的下一个指针的值等于当前指针的值，则将前指针的
next 指向后指针的 next。</p>
<p>实现的时候需要定义一个虚拟头结点，因为可能要删除的结点函数传入的
head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(head)) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head, pre = dummyNode;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(curr.next))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素-ⅱ">8.10 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?envType=study-plan-v2&amp;envId=top-interview-150">删除排序链表中的重复元素
Ⅱ</a></h3>
<p>这道题目跟上一道题目不太一样，这道题目是不保留如果存在重复的数值，所以我们要先让当前指针
cur 先跨越所有重复值的值，然后再更新前指针 prev 的 next
的值。需要注意的是，如果存在重复的情况的话，不要移动 prev
指针的位置，因为重复后的数字很肯定再次出现重复的情况，所以我们等真的没有重复再移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur) &amp;&amp; Objects.nonNull(cur.next)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(cur.next) &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev = cur; </span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转链表">8.11 <a
href="https://leetcode.cn/problems/rotate-list/?envType=study-plan-v2&amp;envId=top-interview-150">旋转链表</a></h3>
<p>这道题目考察的是一个链表移动的问题，首先进行链表旋转的本质是给链表新的起始点。我们可以先走到链表尾，同时记录下链表的长度，因为旋转如果是链表的倍数的话，其实可以不用旋转，所以我们应该拿旋转次数
k 对链表长度 len 取余。然后走到链表尾的指针需要再往前走 k = len - k%len
步，直到下一次起点的前一个指针，我们记录下当前起点的下一个指针，将当前起点的
next 赋值为
null，表示链表结尾，然后再将刚刚记录的值返回函数，即可实现效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head) || Objects.isNull(head.next) || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp.next)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = head;</span><br><span class="line">    k = len - k % len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) tmp = tmp.next;</span><br><span class="line">    head = tmp.next;</span><br><span class="line">    tmp.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分隔链表">8.12 <a
href="https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&amp;envId=top-interview-150">分隔链表</a></h3>
<p>有点分治思想，但也不是分治，就是一个模拟。思路是这样的，新开两条新链，采用尾插的方式往链表中添加元素。对于小于指定值的节点，我们添加到链表一；对于大于等于指定值，我们添加到链表二。我们需要注意的是记录两条链表的起始位置，等遍历结束时，我们可以进行拼接。最后在返回时还需要注意，可能全部节点都加到了链表二中，所以我们不能直接返回链表一，只有当链表一不为空时，才返回链表一，否则应该返回链表二。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l1Head = <span class="literal">null</span>, l2Head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">            l1.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l1Head)) l1Head = l1.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l2Head)) l2Head = l2.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1.next = l2Head;</span><br><span class="line">    l2.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(l1Head)? l2Head : l1Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lru-缓存">8.13 <a
href="https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&amp;envId=top-interview-150">LRU
缓存</a></h3>
<p>双向链表 + Hash</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/8200f0da-2159-41f1-9fe7-5eb367030884.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉树">9. 二叉树</h2>
<h3 id="二叉树的最大深度">9.1 <a
href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的最大深度</a></h3>
<p>递归，土到极致就是潮。求最大深度，当前节点不存在，则为递归出口，直接返回
0。当前节点存在，则返回当前节点左右子树中比较深的那个数，同时，考虑到当前节点也为一层，所以需要在求出左右子树比较深的那个数值后面
+ 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Math._max_(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相同的树">9.2 <a
href="https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&amp;envId=top-interview-150">相同的树</a></h3>
<p>——递归</p>
<p>比较两棵树，可以看作是比较当前的两个节点的递归实现，我们只需要把比较当前两个节点的逻辑处理通顺，比较两棵树就是递归的活。我们对于当前两个节点，两个节点都为
null，则返回 true。如果只有一方为空，则返回
false；如果都不为空，则比较节点的值，如果值不同，则返回
false；值相同，则需满足他们各自的左右子树都应该相同才能返回
true，此时就用上了递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p) &amp;&amp; Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.val == q.val) <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转二叉树">9.3 <a
href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">翻转二叉树</a></h3>
<p>——后递归原理</p>
<p>先翻转左右子树，再反转左右节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称二叉树">9.4 <a
href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&amp;envId=top-interview-150">对称二叉树</a></h3>
<p>——递归</p>
<p>单个节点作为函数参数很难解决这道题目，我们直接使用<strong>重载</strong>的方式，将使用传入两个参数的形式，按照上面题目的方法，进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode a, TreeNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a) &amp;&amp; Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.val == b.val) <span class="keyword">return</span> isSymmetric(a.left, b.right) &amp;&amp; isSymmetric(a.right, b.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从前序与中序遍历序列构造二叉树">9.5 <a
href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150">从前序与中序遍历序列构造二叉树</a></h3>
<p>由前序和中序构造二叉树有个特点，就是因为前序是最开始访问根节点的，所以前序遍历数组的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历，这样讲有点抽象，我们画个图会清晰点。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202727.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= preorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从中序与后序遍历序列构造二叉树">9.6 <a
href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">从中序与后序遍历序列构造二叉树</a></h3>
<p>由后序和中序构造二叉树有个特点，就是因为后序从右往左第一个是最开始访问根节点的，所以后序遍历数组从右往左的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历。需要注意的是，由后序遍历进行构造的数组，我们需要先构造右子树，再构造左子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        root.left = buildTree(postorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">        root.left = buildTree(postorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="填充每个节点的下一个右侧节点指针-ⅱ">9.7 <a
href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/?envType=study-plan-v2&amp;envId=top-interview-150">填充每个节点的下一个右侧节点指针
Ⅱ</a></h3>
<p>——层序遍历</p>
<p>考察的是二叉树的层序遍历。要使得每一行的二叉树节点的 next
指针都指向它的右边，我们需要对每一层单独做处理。我们通过队列 +
数组来完成。具体实现是先将根节点加入到队列中，然后我们以队列是否为空进行循环，每一次循环都遍历队列中所有元素，因为队列每一次循环弹出的是当前层的节点，每一次插入的是我们下一层的节点。对于当前层的节点，我们需要用一个数组将这些点记录下来，等我们把这一层的节点
next
指针连接完成，即遍历完这一层的节点后，我们再将这一层的孩子节点加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        temp.add(cur);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            cur.next = queue.poll();</span><br><span class="line">            temp.add(cur.next);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node node : temp) <span class="keyword">if</span>(Objects.nonNull(node))&#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.left))&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.right))&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树展开为链表">9.8 <a
href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树展开为链表</a></h3>
<p>第一次看到这道题目想用前序遍历做，但是前序遍历的空间复杂度比较高，就想着能不能边翻遍历边翻转。用递归实在想不出来，看了一下别人题解使用的遍历。大概思路我画个图讲一下。思路主要是下面这样
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202752.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(root)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(root.left))&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(pre.right)) pre = pre.right;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 考虑下一个节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="路径总和">9.9 <a
href="https://leetcode.cn/problems/path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">路径总和</a></h3>
<p>——递归</p>
<p>如果当前节点为空，则无论 targetSum 等不等于 0，都返回
false。如果当前节点左右子树都为空，则说明当前节点为叶子节点，则直接返回当前节点值是否等于
target。若当前节点值不满足，则看看当前节点的左右子树是否满足。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right) ) <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求根节点到叶节点数字之和">9.10 <a
href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">求根节点到叶节点数字之和</a></h3>
<p>——递归</p>
<p>先记录一个临时变量 tmp = 上一个节点的值 num * 10 + 当前节点的值
val，如果当前节点为叶子节点，则直接返回临时变量
tmp，即已经到叶子，不用再拼接数字了。若不是叶子节点，则当前节点的左右子树递归结果相加，可作为最终的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getResult(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right)) <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="keyword">return</span> getResult(root.left, temp) + getResult(root.right, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的直径">9.11 <a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a></h3>
<p>根据题目示例，我们可以知道一条路径的长度等于该路径上的节点数 -
1，所以我们的问题转换成了求路径经过的节点数最大值 - 1。</p>
<p>而路径经过的节点数最大值怎么求呢？递归的主要思路是这样的</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">当前节点所在的路径经过的节点数的最大值 = 当前节点左孩子的最大深度 + 当前节点右孩子的最大深度 + 1</span><br><span class="line">当前节点的最大深度 = max(当前节点左孩子的最大深度, 当前节点右孩子的最大深度)</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    maxNum = <span class="number">1</span>;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> maxNum - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    maxNum = Math.max(maxNum, L + R + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的最大路径和">9.12 <a
href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树中的最大路径和</a></h3>
<p>这道题目跟 <a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
这道题目很像，但是 <a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
这道题目是要算节点的个数的最大值，而这道题目是算节点的值的总和最大。所以在代码实现上还是有一点区别。
<a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
的当前节点的最大值是左右子树的最大深度之和 +
1。这道题目当前节点的最大值，则需要考虑左右子树的最大值是不是为负数，负数的话其实会阻碍当前节点求最大值，我们不应该考虑在内。所以这道题目相比于
<a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
，我们需要判断当前节点的左右子树的最大值是否大于 0
，只有左右子树的最大值 &gt;0 时，我们才把它们加入到当前节点的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    res = Integer.MIN_VALUE;</span><br><span class="line">    depthPathSum(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depthPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> Math.max(depthPathSum(root.left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.max(depthPathSum(root.right), <span class="number">0</span>);</span><br><span class="line">    res = Math.max(res, root.val + L + R);</span><br><span class="line">    <span class="keyword">return</span> Math.max(L, R) + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的中序遍历">9.13 <a
href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h3>
<p>按照中序遍历的规则，先遍历左子树，再遍历当前节点，再遍历右子树。由于需要记录节点，所以需要定义一个列表变量，按照顺序记录对应的节点返回即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    res.addAll(inorderTraversal(root.left));</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    res.addAll(inorderTraversal(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树迭代">9.14 <a
href="https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树迭代</a></h3>
<p>——递归</p>
<p>题目讲的有点抽象，不过样例比较清晰，直接看样例可以知道其实就是一个中序遍历的结果输出。我们最简单的做法就是拿一个列表存入中序遍历的结果，然后拿一个下标，随着
next()函数的调用，去访问列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; record;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        record = inorderTraversal(root);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> record.get(idx++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; record.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> res;</span><br><span class="line">        res.addAll(Objects._requireNonNull_(inorderTraversal(root.left)));</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        res.addAll(Objects._requireNonNull_(inorderTraversal(root.right)));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——迭代 其实还有迭代的版本，迭代就是用栈去存储节点，然后随着 next
函数的调用，实现一个将当前节点与对应的左子树入栈，入栈完成后，将栈顶元素弹出，并返回栈顶元素的值，同时返回栈顶节点的值。对于是否还有下一个节点的判定，需要同时存在栈为空且
cur 指针指向
null，才会出现没有下一个节点的情况(下图最有一个图)。讲起来比较抽象，画个图解释一下
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202818.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> TreeNode cur;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.nonNull(cur) || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完全二叉树的节点数">9.15 <a
href="https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&amp;envId=top-interview-150">完全二叉树的节点数</a></h3>
<p>——递归</p>
<p>具体的做法是返回左右子树的节点个数，由于当前节点也算一个节点，所以还需要
+ 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最近公共祖先">9.16 <a
href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的最近公共祖先</a></h3>
<p>最开始看到这道题目，想用并查集来做，也就是并查集压缩路径的方法，将所有节点指向同一个父节点，但是仔细一想，最后可能都指向了根节点，不可行。再仔细一想，感觉就是二叉树的<strong>后序遍历</strong>。左子树遍历一下，看一下左子树有没有节点与
p 或者 q 一样的，再右子树遍历一下，看看右子树有没有节点与 p 或 q
一样的；</p>
<ul>
<li>如果右子树与 p 或 q 节点相等的节点都不存在，说明什么？说明 p、q
两个节点都在左子树，直接返回左子树递归结果。</li>
<li>如果左子树与 p 或 q 节点相等的节点都不存在，说明什么？说明 p、q
两个节点都在右子树，直接返回右子树递归结果。</li>
<li>递归出口是什么，递归出口就是当前节点的值为 null 或者 = p 或者 =
q，直接返回当前节点。</li>
<li>最后实在找不到，直接返回根节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root) || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(right)) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(left)) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉树层次遍历">10. 二叉树层次遍历</h2>
<h3 id="二叉树的右视图">10.1 <a
href="https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的右视图</a></h3>
<p>——层序遍历</p>
<p>层序遍历，取每一层的最右边的节点，加入到返回的数组中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">            <span class="keyword">if</span> (i == len - <span class="number">1</span>) res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层平均值">10.2 <a
href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的层平均值</a></h3>
<p>——层序遍历</p>
<p>对于每一层，求出每一层的节点数和节点值的总和，然后每一层记录下这一层的平均值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> queue.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            sum += cur.val;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(cur.left)) queue.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(cur.right)) queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(sum * <span class="number">1.0</span> / len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层序遍历">10.3 <a
href="https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的层序遍历</a></h3>
<p>——层序遍历模板题，写模板，每一层用一个列表存储即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的锯齿形层次遍历">10.4 <a
href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的锯齿形层次遍历</a></h3>
<p>——层次遍历</p>
<p>跟上一题几乎一样的模板，只是多加了一个判断。当在遍历的层数为奇数层（根节点算第
0 层）时，我们需要翻转存储该层数的列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.reverse(level);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉搜索树">11. 二叉搜索树</h2>
<h3 id="二叉搜索树的最小绝对差">11.1 <a
href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树的最小绝对差</a></h3>
<p>首先，我们如何获取到一棵二叉搜索树的所有节点数值，并且按照升序排序？答案是中序遍历。对于这道题目，一棵二叉树中序遍历出来的结果，min(arr[i]
- arr[i+1])
的结果就是答案。怎么写代码呢？很明显这个公式是两个值，所以我们需要额外的一个变量
pre
记录前一个节点的值。然后呢？按照中序遍历的顺序，先遍历左子树；然后处理当前节点，取当前节点与上一个节点的值的差值；最后遍历右子树。
其实每一道题目讲起来都是抽象的，我画个图解释一下吧。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202900.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    pre = -<span class="number">1</span>;</span><br><span class="line">    res = Integer.MAX_VALUE;</span><br><span class="line">    inorderPrint(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span>;</span><br><span class="line">    inorderPrint(root.left);</span><br><span class="line">    <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = Math.min(res, root.val - pre); <span class="comment">// 这里只需要用当前数 - 前一个数； 因为中序遍历的结果就是递增的，所以相减一定是正数</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderPrint(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="验证二叉搜索树">11.2 <a
href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">验证二叉搜索树</a></h3>
<p>跟上一道题目一样的模板。上一道题目是记录前后两个值的差的最小值，这道题目是判断上一个值是否大于等于当前值，如果是，说明不是二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long._MIN_VALUE_;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    inorderPrint(root);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span>;</span><br><span class="line">    inorderPrint(root.left);</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre == Long._MIN_VALUE_) &#123;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= root.val) flag = <span class="literal">false</span>;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderPrint(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树中第-k-小的元素">11.3 <a
href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树中第
k 小的元素</a></h3>
<p>——中序遍历</p>
<p>其实就是取二叉搜索树中序遍历的结果列表中的第 k 个小标的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        inorderPrint(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span>;</span><br><span class="line">        inorderPrint(root.left);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) res = root.val;</span><br><span class="line">        inorderPrint(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="图">12. 图</h2>
<h3 id="岛屿的最大面积">12.1 <a
href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) res = Math.max(res, getAreaOfIsland(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getAreaOfIsland(grid, r + <span class="number">1</span>, c) + getAreaOfIsland(grid, r - <span class="number">1</span>, c) + getAreaOfIsland(grid, r, c - <span class="number">1</span>) + getAreaOfIsland(grid, r, c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿数量">12.2 <a
href="https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&amp;envId=top-interview-150">岛屿数量</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                traverseArea(grid, i, j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGrid(grid, r, c)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    traverseArea(grid,r,c+<span class="number">1</span>);</span><br><span class="line">    traverseArea(grid,r,c-<span class="number">1</span>);</span><br><span class="line">    traverseArea(grid,r-<span class="number">1</span>,c);</span><br><span class="line">    traverseArea(grid,r+<span class="number">1</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿的周长">12.3 <a
href="https://leetcode.cn/problems/island-perimeter/description/">岛屿的周长</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> traverseArea(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverseArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGrid(grid, r, c)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseArea(grid, r, c + <span class="number">1</span>) + traverseArea(grid, r, c - <span class="number">1</span>) + traverseArea(grid, r + <span class="number">1</span>, c) + traverseArea(grid, r - <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="所有可能的路径">12.4 <a
href="https://leetcode.cn/problems/all-paths-from-source-to-target/">所有可能的路径</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line">    Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">    stack.offerLast(<span class="number">0</span>);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dfs(graph, <span class="number">0</span>, graph.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> idx, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> target : graph[idx]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[target]) <span class="keyword">continue</span>;</span><br><span class="line">        stack.offerLast(target);</span><br><span class="line">        vis[target] = <span class="literal">true</span>;</span><br><span class="line">        dfs(graph, target, n);</span><br><span class="line">        stack.removeLast();</span><br><span class="line">        vis[target] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被围绕的区域">12.5 <a
href="https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&amp;envId=top-interview-150">被围绕的区域</a></h3>
<p>从边缘开始搜起，把边缘的‘O’先打上标记，然后再遍历一下数组，没有打上标记的‘O’则是我们需要进行替换的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(board) || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">edge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == n - <span class="number">1</span> || j == m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克隆图">12.6 <a
href="https://leetcode.cn/problems/clone-graph/description/?envType=study-plan-v2&amp;envId=top-interview-150">克隆图</a></h3>
<p>——DFS</p>
<p>还是用 DFS 进行爆搜。递归两个要点，一个是出口，一个是递归语句。</p>
<p>（1）出口：</p>
<ul>
<li>第一个出口：根据题目所给用例，我们可以很快找到一个递归出口，那就是当传入的结点为
null 时，返回 null。</li>
<li>第二个出口：我们会发现题目所给用例中是一个无向图，会有环的存在，如果这个不加以限制就会无线递归下去，无限创建节点。那怎么办呢？可以用一个
map 去接我们创建出来的节点，把节点值作为 key，节点本身作为
value。每一次创建节点前，都先看看之前是否已经创建过该节点，创建过了就不需要再创建了。</li>
</ul>
<p>（2）递归语句。我们需要明确的是，对于当前节点的邻居，我们应该在进入递归时加入还是递归返回时加入。答案很明显，需要在递归返回时加入。为什么因为对于当前节点的邻居，它们也有自己的邻居，先将当前节点的邻居用递归的方式创建，把它们的邻居也克隆好后，再将它们加入到当前节点的邻居位置。这个问题涉及递归前执行和递归后执行的问题，读者可以参考一下二叉树的前中后序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(node)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(node.val)) <span class="keyword">return</span> map.get(node.val);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">    map.put(node.val, newNode);</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">        newNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除法求值">12.7 <a
href="https://leetcode.cn/problems/evaluate-division/description/?envType=study-plan-v2&amp;envId=top-interview-150">除法求值</a></h3>
<p>两种做法：1. DFS； 2. 并查集</p>
<p>——DFS</p>
<p>这是我看到这道题目第一时间想到的做法。对于这道题目，第一时间想到的是建图，然后遍历给定的
queries，用 DFS 爆搜图。这种做法我们需要明确几个点：1.
图结构用什么存储？ 2. 怎么将数据存入图中 3. 递归出口是什么？4.
递归执行逻辑是什么？</p>
<p>接下来我们一一回答这个问题。</p>
<ol type="1">
<li>首先是图结构用什么存储，回答是 Map 或者结构体。我的代码用的是
Map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>怎么把数据存入图。</li>
</ol>
<p>我们先对题目所给的变量对以下定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">被除数 --&gt;   num1</span><br><span class="line">除数   --&gt;   num2</span><br></pre></td></tr></table></figure>
<p>回答是 被除数 num1 作为 key，除数 num2 和对应两个数的商构建 map 作为
value。然后需要再存入两个数位置相反的关系，也就是第二个数 num2
作为被除数，第一个数 num1 作为除数，对应值则为 1.0 /
value。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----&gt; Map&lt;num1, Map&lt;num2, value&gt;</span><br><span class="line">num1</span><br><span class="line">|</span><br><span class="line">---&gt; (num2,value)</span><br><span class="line"></span><br><span class="line">-----&gt; Map&lt;num2, Map&lt;num1, value&gt;</span><br><span class="line">num2</span><br><span class="line">|</span><br><span class="line">---&gt; (num1,<span class="number">1.0</span> / value)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>递归出口是什么？</li>
</ol>
<p>（1）当图中不存在查询数对的两个值时，需要返回 -1.0</p>
<p>（2）当图中存在查询数对，并且数对的两个值相等时，需要返回 1.0；因为
a/a = 1.0</p>
<p>（3）当图中存在查询数对，并且符合图结构，也就是 num1 下的 map 中含有
num2，则直接返回对应的数值</p>
<ol type="1">
<li>递归逻辑</li>
</ol>
<p>先找当前 num1 下的 map 的 key，如果能找到对应 num2，则直接返回对应的
value；若找不到，则递归 num1 下的 map 的 key，然后将当前 num1 下的 map
的 value 与 key 的递归结果相乘返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    <span class="type">double</span>[] res = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line">    <span class="comment">// 建图</span></span><br><span class="line">    createGraph(equations, values);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">        List&lt;String&gt; query = queries.get(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> query.get(<span class="number">0</span>), num2 = query.get(<span class="number">1</span>);</span><br><span class="line">        res[i] = dfs(num1, num2, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>), num2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">        graph.computeIfAbsent(num1, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()).put(num2, values[i]);</span><br><span class="line">        graph.computeIfAbsent(num2, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()).put(num1, <span class="number">1.0</span> / values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">dfs</span><span class="params">(String num1, String num2, Set&lt;String&gt; path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(num1) || !graph.containsKey(num2)) <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(num1, num2)) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    Map&lt;String, Double&gt; doubleMap = graph.get(num1);</span><br><span class="line">    <span class="keyword">if</span> (doubleMap.containsKey(num2)) <span class="keyword">return</span> doubleMap.get(num2);</span><br><span class="line">    path.add(num1);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; child : doubleMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.contains(child.getKey())) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> child.getValue();</span><br><span class="line">        <span class="type">double</span> <span class="variable">childValue</span> <span class="operator">=</span> dfs(child.getKey(), num2, path);</span><br><span class="line">        <span class="keyword">if</span>(childValue != -<span class="number">1.0</span>) <span class="keyword">return</span> tmp * childValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/?envType=study-plan-v2&amp;envId=top-interview-150">——并查集</a></p>
<p>这里贴一下官方题解吧，写的挺好的。官方题解采用路径压缩，会比 DFS
快一些。</p>
<h3 id="课程表">12.8 <a
href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-interview-150">课程表</a></h3>
<p>就是判断图中有没有环。</p>
<ol type="1">
<li>像什么？像拓扑排序。</li>
<li>怎么做？记录节点入度，用队列存储入度为 0 的节点。</li>
<li>出口在哪？如果图中没有环，则图中每个节点都会进入队列一次；如果图中有环，则环上的节点是不会进入队列的。</li>
<li>只有数组记录节点之间的关系怎么办？建图。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(prerequisites) || prerequisites.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] inSpend = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Arrays.fill(inSpend, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        inSpend[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        graph.computeIfAbsent(prerequisite[<span class="number">1</span>], k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) <span class="keyword">if</span> (inSpend[i] == <span class="number">0</span>) queue.addLast(i);</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(graph.get(it))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer target : graph.get(it)) &#123;</span><br><span class="line">            inSpend[target]--;</span><br><span class="line">            <span class="keyword">if</span> (inSpend[target] == <span class="number">0</span>) queue.addLast(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课程表-ⅱ">12.9 <a
href="https://leetcode.cn/problems/course-schedule-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">课程表
Ⅱ</a></h3>
<p>上一道题目的变体，存入拓扑图序列就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] inSpend = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Arrays.fill(inSpend, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        inSpend[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        graph.computeIfAbsent(prerequisite[<span class="number">1</span>], k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) <span class="keyword">if</span> (inSpend[i] == <span class="number">0</span>) queue.addLast(i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">        numCourses--;   res[idx++] = it;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(graph.get(it))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer target : graph.get(it)) &#123;</span><br><span class="line">            inSpend[target]--;</span><br><span class="line">            <span class="keyword">if</span> (inSpend[target] == <span class="number">0</span>) queue.addLast(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>? res: <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="图的广度优先搜索">13. 图的广度优先搜索</h2>
<h3 id="蛇梯棋">13.1 <a
href="https://leetcode.cn/problems/snakes-and-ladders/description/?envType=study-plan-v2&amp;envId=top-interview-150">蛇梯棋</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] p = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nxt</span> <span class="operator">=</span> p[<span class="number">0</span>] + i;</span><br><span class="line">            <span class="keyword">if</span> (nxt &gt; n * n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span>[] rc = id2rc(nxt, n);</span><br><span class="line">            <span class="keyword">if</span> (board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nxt = board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt == n * n) &#123;</span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[nxt]) &#123;</span><br><span class="line">                vis[nxt] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nxt, p[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> id, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (id - <span class="number">1</span>) / n, c = (id - <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        c = n - <span class="number">1</span> - c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n-<span class="number">1</span>-r, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小基因变化">13.2 <a
href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">最小基因变化</a></h3>
<p>有点像二叉树的层序遍历。哦不，BFS
就是多叉树的层序遍历版本。那么我们换种思想，把这道题目想象成多叉树，然后像二叉树的层序遍历那样，遍历这颗多叉树可以吗。答案是可以。继续往下看，我们需要解决以下几个问题。
1. 这颗多叉树是几叉？ 2. 题目要求的结果是遍历的什么结果？ 3.
层序遍历的队列应该存什么？</p>
<ol type="1">
<li>这颗多叉树是几叉？ 回答是 8*3 = 24。为什么？因为每一个基因序列都有 8
个字母，在一次变换中，每一个字母都有 3
种其他变化，所以，对于每一次变化，我们都需要考虑 24 种可能。</li>
<li>要求的结果是遍历的什么结果？
回答是树的深度，树的每一层代表每一次递进的变换，所以，当真的遇到最终序列时，树有几层，就应该对应几次变换。</li>
<li>层序遍历的队列应该存什么？
回答是，存基因库中的基因序列。显然，对于我们上述的 24
种变化，真正有效的变化只会出现在基因库中，所以，队列里面存的一定是基因库中的序列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">    <span class="type">char</span>[] keys = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (startGene.equals(endGene)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt.contains(endGene)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offer(startGene);</span><br><span class="line">    vis.add(startGene);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.charAt(i) != keys[j]) &#123;</span><br><span class="line">                        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(cur);</span><br><span class="line">                        sb.setCharAt(i, keys[j]);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                        <span class="keyword">if</span> (cnt.contains(target) &amp;&amp; !vis.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endGene.equals(target)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> step;</span><br><span class="line">                            &#125;</span><br><span class="line">                            queue.offer(target);</span><br><span class="line">                            vis.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词接龙">13.3 <a
href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词接龙</a></h3>
<p>跟上一道题目思路一模一样。把写死的长度换成可变长度就行。另外，题目的接龙中，第一个单词和最后一个单词也算进序列长度里面，所以我们需要给答案再加一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] keys = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>.toCharArray();</span><br><span class="line">    Set&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">    Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(!cnt.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    vis.add(beginWord);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; beginWord.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; keys.length; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.charAt(i) != keys[j]) &#123;</span><br><span class="line">                        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(cur);</span><br><span class="line">                        sb.setCharAt(i, keys[j]);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">nxt</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                        <span class="keyword">if</span> (cnt.contains(nxt) &amp;&amp; !vis.contains(nxt)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endWord.equals(nxt)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            queue.offer(nxt);</span><br><span class="line">                            vis.add(nxt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="字典树">14. 字典树</h2>
<h3 id="实现-trie前缀树">14.1 <a
href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">实现
Trie（前缀树）</a></h3>
<p>前缀树，也称字典树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加与搜索单词---数据结构设计">14.2 <a
href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&amp;envId=top-interview-150">添加与搜索单词
- 数据结构设计</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        maxLen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        maxLen = Math.max(maxLen, word.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.subNodes.containsKey(c)) &#123;</span><br><span class="line">                node = node.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                node = node.subNodes.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(word,<span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word, <span class="type">int</span> index, Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(node.subNodes.containsKey(c)) &#123;</span><br><span class="line">            node = node.subNodes.get(c);</span><br><span class="line">            <span class="keyword">if</span>(search(word, index+<span class="number">1</span>, node)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Node&gt; characterNodeEntry : node.subNodes.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(search(word, index+<span class="number">1</span>, characterNodeEntry.getValue())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索-ⅱ">14.3 <a
href="https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索
Ⅱ</a></h3>
<p>一顿操作猛如虎，交上超时二百五。破防了</p>
<p>——
最有一个样例没过版本。这个版本是先造出单词，然后再通过前缀树查找是否在前缀树中。很慢。下面的版本的是参考了官方题解的。直接把前缀树的查找过程顺着原来地图的
dfs 进行，很快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        Node root;</span><br><span class="line"></span><br><span class="line">        Trie() &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">                path.append(board[i][j]);</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(i, j, board, trie, visited);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j,<span class="type">char</span>[][] board, Trie trie, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length() &gt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (trie.search(path.toString())) &#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[<span class="number">0</span>], col = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isGrap(row, col, board) &amp;&amp; !visited[row][col]) &#123;</span><br><span class="line">                path.append(board[row][col]);</span><br><span class="line">                visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">                dfs(row, col, board, trie, visited);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">                visited[row][col] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——题解版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, Trie&gt; subNodes;</span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line">        Trie() &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    node = node.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">                    node = node.subNodes.get(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node.isEnd = <span class="literal">true</span>;</span><br><span class="line">            node.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(i, j, board, trie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, Trie trie)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!trie.subNodes.containsKey(board[i][j])) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        trie = trie.subNodes.get(c);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(trie.word)) &#123;</span><br><span class="line">            res.add(trie.word);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + direction[<span class="number">0</span>], y = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isGrap(x, y, board) &amp;&amp; board[x][y] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                dfs(x, y, board, trie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="回溯">15. 回溯</h2>
<h3 id="电话号码的字母组合">15.1 <a
href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">电话号码的字母组合</a></h3>
<p>——DFS</p>
<p>先打表，记录数字和字母组合的映射，然后再遍历数字序列 DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    put(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">    put(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">    put(<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    put(<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">    put(<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">    put(<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">    put(<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(digits) || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dfs(<span class="number">0</span>, digits);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == digits.length()) &#123;</span><br><span class="line">        res.add(path.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">combines</span> <span class="operator">=</span> map.get(digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : combines.toCharArray()) &#123;</span><br><span class="line">        path.append(c);</span><br><span class="line">        dfs(i + <span class="number">1</span>, digits);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合">15.2 <a
href="https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&amp;envId=top-interview-150">组合</a></h3>
<p>——DFS</p>
<p>DFS 模板题，但是这道题目需要注意的是，对于这个
List&lt;List<Integer>&gt; 变量类型，要将 List<Integer>
加进这个变量时，要 new 一下！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        dfs(i + <span class="number">1</span>, n, k);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全排列">15.3 <a
href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-interview-150">全排列</a></h3>
<p>组合跟全排列是不一样的。按最浅显的理解，可以认为全排列能回头，但是得标记是否已访问；组合不能回头，只能往前走。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    n = nums.length;</span><br><span class="line">    vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    dfs(<span class="number">0</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(start + <span class="number">1</span>, nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合总和">15.4 <a
href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">组合总和</a></h3>
<p>能重复，但是不能回头，那就把当前位置继续传入即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>, candidates, target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> num, <span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        dfs(i, num + candidates[i], candidates, target);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n-皇后-ⅱ">15.5 <a
href="https://leetcode.cn/problems/n-queens-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">N
皇后 Ⅱ</a></h3>
<p>——DFS</p>
<p>怎么理解呢？N 皇后是一个在边长为 n 的方阵上的问题，我们用 DFS
的时候一般都是把题目看成是树的解决方案来进行。【以后有时间一定开个 DFS
专题讲讲】。落实到这道题目，我们需要明确几个点，1. 树的深度是什么？ 2.
树的每个节点有几个孩子节点 3. 出口是什么？</p>
<ol type="1">
<li>树的深度？</li>
</ol>
<p>n。这道题目树的深度是矩阵的行，有几行就多深</p>
<ol type="1">
<li>树的每个节点有几个孩子节点？</li>
</ol>
<p>n。 有多少列，就有几个孩子节点。</p>
<ol type="1">
<li>出口是什么？</li>
</ol>
<p>到叶子节点</p>
<p>最后我们需要怎么满足彼此不攻击？
其实对于每一个位置的横竖撇捺方向，都可以转换成一个数组进行标记是否可行。怎么说呢？</p>
<ul>
<li>横——不用数组，因为我们 DFS
就是一行一行去试探，所以一定能保证行不会冲突。</li>
<li>竖——col 数组</li>
<li>撇——ueg 数组 当前位置[i,j]的撇怎么标记 ueg[i+j]</li>
<li>捺——eg 数组 当前位置[i,j]的撇怎么标记 eg[j-i+n]</li>
</ul>
<p>上图 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203004.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] col, eg, ueg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    eg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    ueg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    dfs(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="number">0</span> &amp;&amp; eg[i + u] == <span class="number">0</span> &amp;&amp; ueg[i - u + n] == <span class="number">0</span>) &#123;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>, n);</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八皇后">15.6 <a
href="https://leetcode.cn/problems/eight-queens-lcci/description/">八皇后</a></h3>
<p>与上面的题目一模一样，不过这道题需要先初始化一下地图，然后边 DFS
边改地图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] col, eg, ueg;</span><br><span class="line"><span class="type">char</span>[][] board;</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    eg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    ueg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, n, board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        List&lt;String&gt; rowStr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rowStr.add(String.valueOf(board[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(rowStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="number">0</span> &amp;&amp; eg[u + i] == <span class="number">0</span> &amp;&amp; ueg[i - u + n] == <span class="number">0</span> &amp;&amp; board[u][i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">            board[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>, n, board);</span><br><span class="line">            board[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索">15.7 <a
href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索</a></h3>
<p>——DFS</p>
<p>只有跟单词一样开头的字母才开始爆搜，只要长度超过目标单词就退出，不然就字母四周继续搜。需要标记是否已经遍历过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                path.append(board[i][j]);</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">                board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, board, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = tmp;</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (word.contentEquals(path)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (path.length() &gt; word.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + direction[<span class="number">0</span>], newY = y + direction[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isGrap(newX, newY, board) &amp;&amp; board[newX][newY] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            path.append(board[newX][newY]);</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[newX][newY];</span><br><span class="line">            board[newX][newY] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(newX, newY, board, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            board[newX][newY] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号生成">15.8 <a
href="https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&amp;envId=top-interview-150">括号生成</a></h3>
<p>对于每一次添加，左括号剩余的个数一定要大于或等于右括号的个数，这样可以保证不会出现类似
<code>())</code>
这种情况存在。我们初始化左右括号个数为最大，每次加，都减掉对应的个数，当左右括号剩余个数都为
0 时，加入最终的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) res.add(str);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">0</span>) dfs(str + <span class="string">&quot;(&quot;</span>, l - <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>) dfs(str + <span class="string">&quot;)&quot;</span>, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="分治">16. 分治</h2>
<h3 id="将有序数组转换为二叉搜索树">16.1 <a
href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">将有序数组转换为二叉搜索树</a></h3>
<p>有序数组取出中间值，左边数组构建左子树，右边数组构建右子树。前序遍历版建树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> creatTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">creatTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">    root.left = creatTree(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = creatTree(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序链表">16.2 <a
href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">排序链表</a></h3>
<p>——迭代版归并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead, curr = dummyHead.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> curr.next;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> merge(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead, temp1 = head1, temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">null</span> &amp;&amp; temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">                temp.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建立四叉树">16.3 <a
href="https://leetcode.cn/problems/construct-quad-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">建立四叉树</a></h3>
<p>先建树根，然后用递归填树的四个孩子，每次递归，都把矩阵用下标分割成对应的子矩阵。那递归出口是什么呢？是当左上角和右下角重合时，也就是当前矩阵只有一个数时，或者当矩阵中的树一样时，我们需要建立树的叶子节点返回。分割矩阵的下标填写可以参考下面的图
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203044.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> createTree(grid,<span class="number">0</span>,<span class="number">0</span>,n-<span class="number">1</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2 || isSameNumber(grid,x1,y1,x2,y2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(grid[x1][y1] == <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midX</span> <span class="operator">=</span> x1 + x2 &gt;&gt; <span class="number">1</span>, midY = y1 + y2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        root.topLeft = createTree(grid, x1, y1, midX, midY);</span><br><span class="line">        root.topRight = createTree(grid, x1, midY + <span class="number">1</span>, midX, y2);</span><br><span class="line">        root.bottomLeft = createTree(grid, midX + <span class="number">1</span>, y1, x2, midY);</span><br><span class="line">        root.bottomRight = createTree(grid, midX + <span class="number">1</span>, midY + <span class="number">1</span>, x2, y2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameNumber</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> grid[x1][y1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x1; i &lt;= x2; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> y1; j &lt;= y2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 16.4 <a
href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-interview-150">合并
K 个升序链表</a></p>
<p>——暴力版本</p>
<p>实践证明，暴力真的能过这道题目。只需要每一次都遍历一遍链表数组，把最小的那一个值取出来，插入到结果链表中即可。这也是我自己第一时间想到和写出来的结果。
还是看看下面用类似于归并排序的分治版本吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(lists) || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, maxNum = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(lists[i]) &amp;&amp; lists[i].val &lt; maxNum) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                maxNum = lists[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxNum == Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line">        cur.next = lists[idx];</span><br><span class="line">        lists[idx] = lists[idx].next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—— 分治版本</p>
<p>对于分治，给 up 的题感都跟 树的遍历或者归并排序的思路基本一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(l1) || Objects._isNull_(l2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects._isNull_(l1) ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy, l1Head = l1, l2Head = l2;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l1Head) &amp;&amp; Objects._nonNull_(l2Head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1Head.val &lt; l2Head.val) &#123;</span><br><span class="line">            cur.next = l1Head;</span><br><span class="line">            l1Head = l1Head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2Head;</span><br><span class="line">            l2Head = l2Head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l1Head)) &#123;</span><br><span class="line">        cur.next = l1Head;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        l1Head = l1Head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l2Head)) &#123;</span><br><span class="line">        cur.next = l2Head;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        l2Head = l2Head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="kadane算法">17. Kadane算法</h2>
<h3 id="最大子数组和">17.1 <a
href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&amp;envId=top-interview-150">最大子数组和</a></h3>
<p>定义一个变量 maxNum
记录当前位置之前的子数组和，然后比较要不要从当前位置开始新的子数组，还是继续把当前位置纳入到子数组中，比较的方式就是，
Math.max(nums[i], nums[i] + maxNum) 。 也就是当前位置之前的子数组和 +
当前位置的数值，会不会比当前位置的数大。会的话就将当前位置纳入子数组，不会的话，就从当前位置开始。每次更新都要记录子数组和的最大值，所以最终求出来的结果就是最大子数组和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        maxNum = Math.max(nums[i], maxNum + nums[i]);</span><br><span class="line">        res = Math.max(res, maxNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环形子数组的最大和">17.2 <a
href="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&amp;envId=top-interview-150">环形子数组的最大和</a></h3>
<p>题解参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minS</span> <span class="operator">=</span> Integer.MAX_VALUE, maxS = Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minF</span> <span class="operator">=</span> <span class="number">0</span>, maxF = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        minF = Math.min(minF,<span class="number">0</span>) + num;</span><br><span class="line">        maxF = Math.max(maxF,<span class="number">0</span>) + num;</span><br><span class="line">        minS = Math.min(minS, minF);</span><br><span class="line">        maxS = Math.max(maxS, maxF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minS == sum? maxS : Math.max(maxS, sum - minS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二分查找">18. 二分查找</h2>
<h3 id="搜索插入位置">18.1 <a
href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&amp;envId=top-interview-150">搜索插入位置</a></h3>
<p>二分查找经典题目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l] &gt;= target ? l : l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索二维矩阵">18.2 <a
href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-interview-150">搜索二维矩阵</a></h3>
<p>首先把二维矩阵拉成一维矩阵来看待，然后把对应一维的矩阵下标转换成二维矩阵对应的下标即可。画个图讲一下怎么转换.
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203141.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[mid / m][mid % m];</span><br><span class="line">        <span class="keyword">if</span> (tmp == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="寻找峰值">18.3 <a
href="https://leetcode.cn/problems/find-peak-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">寻找峰值</a></h3>
<p>由于题目说了，可以假设
<code>nums[-1] = nums[n] = -∞</code>，那么在数组中，只要有一个数比它相邻的元素大，那就顺着大的元素的方向继续往下找，就一定能找到峰值。因为极端情况边缘数字就是峰值。</p>
<ul>
<li>根据上述结论，我们就可以使用二分查找找到峰值。</li>
<li>查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件</li>
<li>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m
较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m +
1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索旋转排序数组">18.4 <a
href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">搜索旋转排序数组</a></h3>
<p>虽然数组旋转了，但还是会有有序的部分。数组中点一定会把数组分割成两部分，一部分一定是有序的，我们只需要在有序的部分继续使用二分查找，那就一定能找到目标值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在排序数组中查找元素的第一个和最后一个位置">18.5 <a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">在排序数组中查找元素的第一个和最后一个位置</a></h3>
<p>其实这道题目就是 acwing 的二分查找的模板题目，但是 up
当时看完视频还是不懂，知道看了这篇<a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/?envType=study-plan-v2&amp;envId=top-interview-150">题解</a>，确实不需要去判断哪个地方得等于，哪个地方又得
+
1。我们只需要当找到目标值的时候，如果要找第一个出现的位置，我们就继续往左边找；如果要找最后一个出现的位置，我们就继续往右找就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    res[<span class="number">0</span>] = binarySearch(nums,target,<span class="literal">true</span>);</span><br><span class="line">    res[<span class="number">1</span>] = binarySearch(nums,target,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> isFirst)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>, tmp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            tmp = mid;</span><br><span class="line">            <span class="keyword">if</span>(!isFirst) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找旋转排序数组中的最小值">18.6 <a
href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&amp;envId=top-interview-150">寻找旋转排序数组中的最小值</a></h3>
<p>这道题目官方讲解讲的很好，可以看懂，这里就直接贴<a
href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/698479/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/?envType=study-plan-v2&amp;envId=top-interview-150">官方讲解</a>了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找两个正序数组的中位数">18.7 <a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-interview-150">寻找两个正序数组的中位数</a></h3>
<p>——暴力解法
其实就是将两个数组合并成一个数组，然后，求出新数组的中位数。但是没想到超过
100%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length, i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) arr[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> arr[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) arr[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) arr[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (arr[n / <span class="number">2</span>] + arr[n / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[n / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——二分解法</p>
<p>寻求第 k 小数的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>, right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="堆">19. 堆</h2>
<h3 id="数组中的第-k-个最大元素">19.1 <a
href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">数组中的第
K 个最大元素</a></h3>
<p><strong>——排序</strong></p>
<p>不符合题意要求，这里不贴代码了</p>
<p><strong>——快速排序</strong></p>
<p>回忆一下下面快速排序的代码，其实快速排序实现的是什么，是将一个数组分成两个部分，前半部分小于某个数
base，后半部分大于某个数 base。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = nums[i + j &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span> (nums[i] &lt; base);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span> (nums[j] &gt; base);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从这里入手</span></span><br><span class="line">    _quickSort_(nums, l, j);</span><br><span class="line">    _quickSort_(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在要找到第 K
大的数，怎么利用快速排序来找呢？我们可以从上面代码标记的位置入手。当代码运行到此处是，此时的数组前半部分全是小于
base 的数，后半部分全是大于 base 的数，我们要找第 k
大，只需要看看前半部分有没有 k
个数，有的话，在前半部分找；没有则到后半部分找。看看实现代码~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span> (nums[i] &lt; base);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span> (nums[j] &gt; base);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j) <span class="keyword">return</span> quickSort(nums, l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSort(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>——堆排序</strong></p>
<p>所谓的堆排序，就是用到一些在树状数组上进行的操作，建立大根堆，然后不断删除顶部节点。还是得画个图才比较明了
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214625.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        down(nums, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        down(nums, --len, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> len,  <span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">1</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">2</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != u) &#123;</span><br><span class="line">        swap(nums, t, u);</span><br><span class="line">        down(nums, len ,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ipo">19.2 <a
href="https://leetcode.cn/problems/ipo/description/?envType=study-plan-v2&amp;envId=top-interview-150">IPO</a></h3>
<p>——贪心算法
最开始看到这个题目感觉像背包，但是由于成本是随着收益的不断增加改变。所以应该用贪心的思路。具体是先将所有投资按照投资成本进行升序排序，然后根据现有资金决定是否投资对应的项目，将项目的收益按照降序排序存入堆中，每一次取出在当前投资资金所能支持的项目中收益最大的那一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> profits.length;</span><br><span class="line">    <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i][<span class="number">0</span>] = capital[i];</span><br><span class="line">        arr[i][<span class="number">1</span>] = profits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays._sort_(arr, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n &amp;&amp; w &gt;= arr[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            heap.add(arr[cur][<span class="number">1</span>]);</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            w += heap.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找和最小的-k-对数字">19.3 <a
href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&amp;envId=top-interview-150">查找和最小的
K 对数字</a></h3>
<p>使用最小堆存储两个数组的下标，使得对应下标值的和按照升序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; nums1[a[<span class="number">0</span>]] + nums2[a[<span class="number">1</span>]] - nums1[b[<span class="number">0</span>]] - nums2[b[<span class="number">1</span>]]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, k); ++i) &#123;</span><br><span class="line">        heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] idPairs = heap.poll();</span><br><span class="line">        res.add(Arrays.asList(nums1[idPairs[<span class="number">0</span>]], nums2[idPairs[<span class="number">1</span>]]));</span><br><span class="line">        <span class="keyword">if</span>(idPairs[<span class="number">1</span>] + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;idPairs[<span class="number">0</span>], idPairs[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流的中位数">19.4 数据流的中位数</h3>
<h2 id="位运算">20. 位运算</h2>
<h3 id="二进制求和">20.1 <a
href="https://leetcode.cn/problems/add-binary/description/?envType=study-plan-v2&amp;envId=top-interview-150">二进制求和</a></h3>
<p>其实就是高精度的模拟题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">aLen</span> <span class="operator">=</span> a.length(), bLen = b.length(), carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> aLen - <span class="number">1</span>, j = bLen - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">        carry += i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        carry += j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        res.append(carry % <span class="number">2</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(carry &gt; <span class="number">0</span> ? carry : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="颠倒二进制数">20.2 <a
href="https://leetcode.cn/problems/reverse-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">颠倒二进制数</a></h3>
<p>将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n
的每一位，将其倒序添加到翻转结果 res 中。</p>
<p>代码实现中，每枚举一位就将 n 右移一位，这样当前 n
的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。</p>
<p>需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n
的右移操作应使用逻辑右移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        res |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位-1-的个数">20.3 <a
href="https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">位
1 的个数</a></h3>
<p>每次将数右移一位，然后跟 1 做 &amp; 运算，如果存在 1，则计入次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) cnt++;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字">20.4 <a
href="https://leetcode.cn/problems/single-number/submissions/587464649/?envType=study-plan-v2&amp;envId=top-interview-150">只出现一次的数字</a></h3>
<p>——异或运算。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214718.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字-ⅱ">20.5 <a
href="https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">只出现一次的数字
Ⅱ</a></h3>
<p>模拟一下代码逻辑 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214740.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        a = (a ^ num) &amp; ~b;</span><br><span class="line">        b = (b ^ num) &amp; ~a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数字范围按位与">20.6 <a
href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&amp;envId=top-interview-150">数字范围按位与</a></h3>
<p>画个图就明白了，其实很简单。想一下，为什么会除了公共前缀之外，其他部分相与都为
0。无论多少个数相与，只要其中有一个数为 0，是不是所有数字相与都会为
0。那对于给定范围的左右两个数，除了公共前缀部分，后半部分是不是用来区分它们之间的不同，并且它们之前存在的是连续的不同，说明什么，说明不是公共前缀的部分，一定每一个位置上面都存在一个
0，所以相与一定为 0 . <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214801.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &lt;&lt; offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数学">21. 数学</h2>
<h3 id="回文数">21.1 <a
href="https://leetcode.cn/problems/palindrome-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">回文数</a></h3>
<p>简单题，简单做。每次取出给定数字的最后一位，作为新的数新增的一位，最后判断新构造的数和原来的数一不一样就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>, tmp = x;</span><br><span class="line">    <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        num = num * <span class="number">10</span> + tmp % <span class="number">10</span>;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加一">21.2 <a
href="https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&amp;envId=top-interview-150">加一</a></h3>
<p>——高精度加法模拟题</p>
<p>不想回忆，保研面试那会做了半个多小时，基础是太差了。现在 3
分钟就做出来了。不想回忆保研的日子~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">1</span>, n = digits.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        carry += digits[i];</span><br><span class="line">        res.add(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) res.add(carry);</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) ans[res.size() - i - <span class="number">1</span>] = res.get(i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘后的零">21.3 <a
href="https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&amp;envId=top-interview-150">阶乘后的零</a></h3>
<p>因为 2x5 = 10，所以，要有 0，因子中就必须要有 2 和 5。并且因子中的 2
一定会比 5 多。期间需要很多数学证明，这里有兴趣的话看<a
href="https://leetcode.cn/problems/factorial-trailing-zeroes/solutions/1360892/jie-cheng-hou-de-ling-by-leetcode-soluti-1egk/?envType=study-plan-v2&amp;envId=top-interview-150">题解</a>吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">        res += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="x-的平方根">21.4 <a
href="https://leetcode.cn/problems/sqrtx/?envType=study-plan-v2&amp;envId=top-interview-150">x
的平方根</a></h3>
<p>——二分查找</p>
<p>要找到一个整数的平方根，那么退出二分查找的条件则可以定为左右边界相差不能大于
1，这样就能把左右边界压缩到平方根的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x / mid == mid) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x / mid &lt; mid) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="powxn">21.5 <a
href="https://leetcode.cn/problems/powx-n/description/?envType=study-plan-v2&amp;envId=top-interview-150">Pow(x,n)</a></h3>
<p>——快速幂</p>
<p>快速幂的模板题，需要注意的是，当 n&lt;0 时，应该用除法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">long</span>) n;</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> t &gt; <span class="number">0</span>;</span><br><span class="line">    t = t &gt; <span class="number">0</span> ? t : -t;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) res *= x;</span><br><span class="line">            <span class="keyword">else</span> res /= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直线上最多的点数">21.6 <a
href="https://leetcode.cn/problems/max-points-on-a-line/description/?envType=study-plan-v2&amp;envId=top-interview-150">直线上最多的点数</a></h3>
<p>使用 Map
记录直线斜率，但是直线斜率算出来是浮点数，所以把直线斜率的分子和分母使用下划线拼接成字符串，然后作为键进行存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>], x2 = points[j][<span class="number">0</span>], y2 = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x1 - x2, b = y1 - y2;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> gcd(a, b);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (a / k) + <span class="string">&quot;_&quot;</span> + (b / k);</span><br><span class="line">            record.put(key, record.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, record.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">22.动态规划</h2>
<p>动态规划五部曲</p>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ol>
<h3 id="爬楼梯">22.1 <a
href="https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&amp;envId=top-interview-150">爬楼梯</a></h3>
<p>斐波那契数模板题目。 a[i] = a[i-1] + a[i-2]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍">22.2 <a
href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&amp;envId=top-interview-150">打家劫舍</a></h3>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义 <br> dp
数组表示能偷窃到当前房屋的最高金额。其中 dp[i]的下标 i 表示的是第 i+1
间房屋</li>
<li>确定递推公式 <br> 怎么推导递推公式呢？ 对于当前位置 i
来讲，要么就是前一个相邻位置 i-1 取得的收益高，我们此时就需要以 i-1
作为起点；要么就是再前面的一个位置 i - 2 取得的收益 +
当前房屋能取得的收益
的总和收益高。所以对于当前位置，我们的递推公式就是</li>
</ol>
<p><span class="math display">\[
\begin{equation}
max=\left\{
\begin{aligned}
nums[i] + dp[i-2] \\
dp[i-1]
\end{aligned}
\right.
\end{equation}
\]</span></p>
<ol type="1">
<li>dp 数组如何初始化 <br>
根据递推公式我们可以知道，我们需要初始化的值只有两个，dp[0],
dp[1]，dp[0]是什么，是打劫第一间房屋取得的收益，没得选，只有第一家能选。dp[1]是什么，dp[1]是打劫完第一和第二间房屋后，所取得的最大收益，那是什么，肯定是第一间和第二间房屋取得更大收益那个，所以我们的初始化就出来了
dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]);</li>
<li>确定遍历顺序 <br></li>
</ol>
<p>一维数组，基本都是从小到大，只有设计背包问题，两个条件才需要考虑遍历顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math._max_(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        dp[i] = Math._max_(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词拆分">22.3 <a
href="https://leetcode.cn/problems/word-break?envType=study-plan-v2&amp;envId=top-interview-150">单词拆分</a></h3>
<p>——动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——前缀树</p>
<p>被样例整破防了，前缀树压根过不了，这里写一个没有完全通过的版本，题解竟然叫去写前缀树。看来还是我学不够。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node root;</span><br><span class="line">        Trie()&#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertWord</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.subNodes.containsKey(ch))&#123;</span><br><span class="line">                    cur = cur.subNodes.get(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.subNodes.put(ch,<span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                    cur = cur.subNodes.get(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">            <span class="type">boolean</span> isEnd;</span><br><span class="line">            Map&lt;Character,Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordSet) &#123;</span><br><span class="line">            root.insertWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Trie.<span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> root.root;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.subNodes.containsKey(s.charAt(idx)))&#123;</span><br><span class="line">                tmp = tmp.subNodes.get(s.charAt(idx));</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.isEnd) tmp = root.root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换">22.4 <a
href="https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&amp;envId=top-interview-150">零钱兑换</a></h3>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义<br> dp[i]表示的是：当总金额为
i 时，所需的最少的硬币数。</li>
<li>确定递推公式<br> dp[i] = Math._min_(dp[i], dp[i - coins[j]] + 1)
对于总金额为 i 的情况，我们需要考虑第 j 个硬币到底取不取。取的话，应该由
i-coins[j] 的最少硬币数 + 1 来赋值；不取的话，就只能赋回原来的值。</li>
<li>dp 数组如何初始化<br> dp[0] = 0 当总金额为 0
时，我们需要的硬币数也为 0 .</li>
<li>确定遍历顺序<br>
其实，这道题目很像多重背包，但又存在很多不同。首先一个是这道题目想要求解的是计数问题，并不是最大化价值问题；其次是这道题目的遍历顺序跟多重背包的遍历顺序不太一样，多重背包是先遍历物品，再遍历背包。这道题目是先遍历的背包，再遍历物品。因为对于每一个总金额，我们都需要考虑所有的硬币所组成的搭配。并优化器</li>
<li>举例推导 dp 数组<br></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    Arrays._fill_(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                dp[i] = Math._min_(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长递增子序列">22.5 <a
href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150">最长递增子序列</a></h3>
<p>——动态规划 + 二分查找</p>
<p>还是画个图模拟一下代码的整个流程更好理解一点。如下图，二分查找插入的目的是什么？其实目的就是为了让我们的
dp
数组更好插入后面的数。二分查找为新到来的数在新数组中找到一个最合适的插入位置，使得新数组中的数保持递增并尽量小。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111852.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[len] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; dp[len]) dp[++len] = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多维动态规划">23. 多维动态规划</h2>
<h3 id="三角形最小路径和">23.1 <a
href="https://leetcode.cn/problems/triangle/?envType=study-plan-v2&amp;envId=top-interview-150">三角形最小路径和</a></h3>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111914.png" />
从最下面往上面走，第 i 层 第 j 个数的最终结果是什么呢？</p>
<p><span class="math display">\[
dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j];
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">    <span class="comment">// 由底部到顶部</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) dp[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            dp[j] = Math._min_(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和">23.2 <a
href="https://leetcode.cn/problems/minimum-path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">最小路径和</a></h3>
<p>先处理边界格子（下图标绿色的格子），对于非边界的格子，可以由左边和上边推导得到。边缘只能从左边或者上面来，所以没得优化，所以我们对最上面的边和最左面的边，我们使用前缀和算出到每一个格子需要的路径。对于不是最左边和最上边的格子，我们的递推公式为：</p>
<p><span class="math display">\[
dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])
\]</span> 其中 dp[i-1][j] 表示从上面来，dp[i][j-1]表示从左边来 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111936.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="不同路径-ⅱ">23.3 <a
href="https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">不同路径
Ⅱ</a></h3>
<p>其实跟上一道题目思路差不多，都是先处理边界格子。但还是存在差别，本题我们是计算到达格子的路线有几条，不是求最小值，而是求和。另外在处理格子时，对于边界的格子，都只有从左边来或者从上边来一种路线，所以我们初始化为
1，但是，遇到障碍物后，后面的格子都没法到达，所以为 0
。对于非边界的格子，也同样需要对存在障碍物进行处理，存在障碍物不更新，不存在障碍物才更新</p>
<p>递推公式</p>
<p><span class="math display">\[
dp[i][j] = dp[i-1][j] + dp[i][j-1]
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交错字符串">23.4 <a
href="https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">交错字符串</a></h3>
<p>——动态规划</p>
<p>其实题目说了一堆交错组成的概念，真的需要考虑是否是交错组合吗？其实不用，设想一下，当
s3 已经有字符跟 s1 的字符匹配了，下一个字符无论是 s1 的还是 s2
的，都能保证交错组成。最极端的情况便是前半部分由 s1 组成，后半部分由 s2
组成，但这也是交错。所以我们可以大胆的以字符串匹配的想法来做。但是这里会存在一个疑问，为什么不能用双指针呢？如下图所示，当遍历到
s3 这个位置时，我们会发现此时用来遍历 s1 和 s2 的指针都满足与 s3
匹配的要求，所以此时如果走 s1，尚且能通过样例，一旦样例需要先走
s2，那就过不了了。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111959.png" />
再来讲一下动态规划的思路吧。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221112028.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line">    <span class="keyword">if</span> (n + m != t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = dp[i][j] || (s1.charAt(i - <span class="number">1</span>) == s3.charAt(q) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = dp[i][j] || (s2.charAt(j-<span class="number">1</span>) == s3.charAt(q) &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离">23.5 <a
href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&amp;envId=top-interview-150">编辑距离</a></h3>
<p>假设我们有两个字符串 word1 和 word2，我们的目标是将 word1 转换成
word2。设 dp[i][j] 表示的是将 word1 的前 i 个字符转换成 word2 的前 j
个字符所需的最小编辑操作数。</p>
<p>情况 1: 字符相等 如果 word1 的第 i 个字符（即 word1[i-1]）等于 word2
的第 j 个字符（即
word2[j-1]），那么这两个字符之间不需要任何编辑操作，因此 dp[i][j] =
dp[i-1][j-1]。</p>
<p>情况 2: 字符不等 如果 word1[i-1] !=
word2[j-1]，那么我们需要考虑三种编辑操作：</p>
<p>最终，dp[i][j]
应该取这三种情况中的最小值，因为我们要找的是最少编辑操作次数。所以可以得到最终的递推结果</p>
<p><span class="math display">\[
\begin{equation}
dp[i][j]=\left\{
\begin{aligned}
&amp;dp[i-1]&amp; word1[i-1] == word2[j-1] \\
&amp;min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1&amp; word1[i-1] !=
word2[j-1]
\end{aligned}
\right.
\end{equation}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    word1 = <span class="string">&quot;0&quot;</span> + word1;</span><br><span class="line">    word2 = <span class="string">&quot;0&quot;</span> + word2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>][m + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅱ">23.6 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机
Ⅱ</a></h3>
<p>——投机取巧</p>
<p>题目说没有限制一天里只能买或者只能卖，并且也没有限制买卖的次数，我们只需要看有涨幅就进行买卖操作，就能获得最大收益。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[j] &gt; prices[j - <span class="number">1</span>]) res += prices[j] - prices[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——动态规划</p>
<ol type="1">
<li>定义状态</li>
</ol>
<p>dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i
天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p>
<ol start="2" type="1">
<li><p>考虑情况</p>
<ol type="1">
<li>情况一 考虑 dp[i][0]
的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即
dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即
dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i]
的收益。因此为了收益最大化，我们列出如下的转移方程：</li>
<li>再来考虑
dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即
dp[i−1][1]，或者前一天结束时还没有股票，即
dp[i−1][0]，这时候我们要将其买入，并减少 prices[i]
的收益。可以列出如下的转移方程：</li>
</ol>
<p><span class="math display">\[
p[i][1]=max(dp[i−1][1],dp[i−1][0]−prices[i])
\]</span></p></li>
<li><p>对于初始状态</p></li>
</ol>
<p>根据状态定义我们可以知道第 0 天交易结束的时候
dp[0][0]=0，dp[0][1]=−prices[0]。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候
dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为
dp[n−1][0]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅲ">23.7 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅲ</a></h3>
<p>——动态规划</p>
<ol type="1">
<li><p>定义状态</p>
<ol type="1">
<li>j=0 表示第 i 天结束时，未持有任何股票，且购买次数为
2。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][0]=dp[i-1][0];
\]</span></p>
<ol start="2" type="1">
<li>j=1 表示第 i 天结束时，持有股票，且购买次数为
1。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
p[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i-1])
\]</span></p>
<p>（prices[i-1]表示第 i 天的价格，下同）</p>
<ol start="3" type="1">
<li>j=2 表示第 i 天结束时，持有股票，且购买次数为
2。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
p[i][2]=max(dp[i-1][2],dp[i-1][3]-prices[i-1])
\]</span></p>
<ol start="4" type="1">
<li>j=3 表示第 i 天结束时，未持有股票，且购买次数为 1。
可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][3]=max(dp[i-1][3],dp[i-1][1]+prices[i-1])
\]</span></p>
<ol start="5" type="1">
<li>j=4 表示第 i 天结束时，未持有股票，且购买次数为 1
。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][4]=max(dp[i-1][4],dp[i-1][2]+prices[i-1])
\]</span></p></li>
<li><p>对于初始状态</p></li>
</ol>
<p>由于第 1 天卖出股票的情况都是当天买当天卖，因此 0、3、4 状态都为
0，讨论 1、2 状态</p>
<p>第一天第一次买入：</p>
<p><span class="math display">\[
dp[1][1]=-prices[0];
\]</span> 第一天第二次买入（第一次当天买当天卖）：</p>
<p><span class="math display">\[
dp[1][2]=-prices[0];
\]</span> ​ 3. 返回值</p>
<p>考虑到如果最后一天买入并不会使最大值的结果发生变化，因此，答案只会在
3、4 状态产生</p>
<p><span class="math display">\[
max（dp[n][3],dp[n][4]）;
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n][<span class="number">4</span>], dp[n][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅳ">23.8 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅳ</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[][] matrix : dp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : matrix) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MIN_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; ++i) dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">0</span>] = Math.max(dp[i][j][<span class="number">0</span>], dp[i][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">1</span>] = Math.max(dp[i][j][<span class="number">1</span>], dp[i][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计全为-1-的正方形子矩阵">23.9 <a
href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/">统计全为
1 的正方形子矩阵</a></h3>
<p>贴一下官方题解吧，写的很清晰。不过我再解释一下为什么递推公式可以是下面这个</p>
<p><span class="math display">\[
\begin{equation}
dp[i][j]=\left\{
\begin{aligned}
min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1] &amp;  &amp; matrxi[i][j]==1 \\
0 &amp;  &amp; matrix[i][j] == 0 \\
\end{aligned}
\right.
\end{equation}
\]</span></p>
<p>我们画个图讲一下吧 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221112105.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSquares</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(matrix) || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || matrix[i][j] == <span class="number">0</span>) dp[i][j] = matrix[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            res += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大正方形">23.10 <a
href="https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&amp;envId=top-interview-150">最大正方形</a></h3>
<p>这个题目的解法基本跟上面的题目思路一致。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(matrix) || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res = Math.max(dp[i][<span class="number">0</span>], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res = Math.max(dp[<span class="number">0</span>][j], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>面试经典150题</tag>
      </tags>
  </entry>
  <entry>
    <title>生活心得</title>
    <url>/2024/12/17/Life/%E7%94%9F%E6%B4%BB%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="39a3e91f4c5d7c1cb6483996f53257fe2795255f840c0cc7179afd0fb8315f2c">1f6bb8509d126916afe1b073331b8b3022b18b79a6847b5197580c9561aefcdb7ef0d420fd891ef5503bc83738620ef4a03ae5124c312909ce9f60dd3706ecabbc0cd5634cd8567a22be1e022bf0beac66afc389469082db29e3c78737e66c4869d462d61098a196d97f1fb073e9db885418219d96e4bc9e2f913f689beea7090dea7ab83fc87afe9d2ff383fe1e248dbbaf05ac0c1ec0500b944ded297209fe18aff9a11d46d9a4fc6ab496725c433095de62d152a9162636a045a2cdc03161295105e4916ee87e6cc7b11d01b9e3abe31b4547d444f892500e8ec573e8f69aa16e5b86d4b67b40d4ee4c250366d93855d964061885b29695c54d19dd8071a224b942c7c980457c01d379b1a8dddf4a5958e7751778e79b5630b8b05b918843</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统基础知识</title>
    <url>/2025/03/13/Recommend/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>说明：</p>
<ul>
<li>带星号，说明是有效的做法</li>
</ul>
<h2 id="一基本概念">一、基本概念</h2>
<h3 id="消费指标">1、消费指标</h3>
<ul>
<li>点击率 = 点击次数 / 曝光次数</li>
<li>点赞数 = 点赞次数 / 点击次数</li>
<li>收藏率 = 收藏次数/ 点击次数</li>
<li>转发率 = 转发次数 / 点击次数</li>
<li>阅读完成率 = 滑动到底次数 / 点击次数*f（笔记长度）</li>
</ul>
<h3 id="北极星指标最重要的指标">2、北极星指标（最重要的指标）</h3>
<ul>
<li>用户规模：
<ul>
<li>日活用户数（DAU）、月活用户数（MAU）</li>
</ul></li>
<li>消费
<ul>
<li>人均使用推荐的时长、人均阅读笔记的数量</li>
</ul></li>
<li>发布
<ul>
<li>发布渗透率、人均发布量</li>
</ul></li>
</ul>
<h3 id="推荐系统链路">3、推荐系统链路</h3>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211447.png" /></p>
<h4 id="召回通道">（1）召回通道</h4>
<p>协同过滤、双塔模型、关注的作者等等</p>
<h4 id="重排">（4）重排</h4>
<ul>
<li>做多样性抽样（比如MMR、DPP），从几百篇中选出几十篇</li>
<li>用规则打散相似笔记</li>
<li>插入广告和运营推广内容，根据生态要求调整排序</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211457.png" /></p>
<h3 id="ab测试">4、A/B测试</h3>
<h3 id="分层实验">5、分层实验</h3>
<p>同层互斥，不同层正交</p>
<h3 id="holdout机制">6、Holdout机制</h3>
<ul>
<li>每个实验（召回、粗排、精排、重排）独立汇报对业绩指标的提升</li>
<li>公司考察一个部门在一段时间内对业绩指标总体的提升</li>
<li>取10%的用户作为holdout桶，推荐系统使用剩余的90%作为实验，两者互斥</li>
<li>10%的houldout桶和90%实验桶的diff，为整个部门的业务指标收益</li>
</ul>
<h3 id="实验推全">7、实验推全</h3>
<p>新建一个推全层，与其他层正交</p>
<h3 id="反转实验">8、反转实验</h3>
<p>在新的推全层上，保留一个小的反转桶，使用旧策略。长期观察新旧策略的diff</p>
<h2 id="二召回">二、召回</h2>
<h3 id="一普通做法召回">（一）普通做法召回</h3>
<h4 id="基于物品的协同过滤itemcf">1、基于物品的协同过滤（itemCF）</h4>
<h4 id="原理">（1）原理</h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211506.png" /></p>
<h4 id="预估用户对候选物品的兴趣">（2）预估用户对候选物品的兴趣</h4>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211513.png" style="zoom:80%;" /></p>
<h4 id="计算物品相似度">（3）计算物品相似度</h4>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211521.png" style="zoom:80%;" /></p>
<h4 id="itemcf用于召回的完整流程">（4）itemCF用于召回的完整流程</h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211540.png" /></p>
<h4 id="swing模型">2、Swing模型</h4>
<p>主要是多考虑了物品相似度计算过程中重合的用户是否来自同一个圈子</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211548.png" /></p>
<h4 id="基于用户的协同过滤usercf">3、基于用户的协同过滤（UserCF）</h4>
<h5 id="原理-1">（1）原理</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211556.png" /></p>
<h5 id="用户的相似度">（2）用户的相似度</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211605.png" /></p>
<h5 id="usercf用于召回的完成流程">（3）UserCF用于召回的完成流程</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211612.png" />=</p>
<h3 id="二向量召回">（二）向量召回</h3>
<h4 id="离散特征处理">1、离散特征处理</h4>
<h5 id="主要流程">（1）主要流程</h5>
<ol type="1">
<li>建立字典：把类别映射成序号
<ul>
<li>中国 ➡ 1</li>
<li>美国 ➡ 2</li>
</ul></li>
<li>向量化：把序号映射成向量
<ul>
<li>One-hot编码：把序号映射成高维稀疏向量</li>
<li>Embedding：把序号映射成低维稠密向量</li>
</ul></li>
</ol>
<h5 id="one-hot编码">（2）One-hot编码</h5>
<p>类别数量太大的话，一般不用One-hot编码</p>
<h5 id="embedding">（3）Embedding</h5>
<p>就是拿One-hot编码乘以一个矩阵，降低One-hot编码的向量维度</p>
<h4 id="矩阵补充">2、矩阵补充</h4>
<h5 id="概念">（1）概念</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211620.png" /></p>
<p>​
我们需要构建模型，预测出灰色位置的数值。也就是需要预测出没有曝光给用户的物品，用户可能对该物品的兴趣分数，得到这个分数之后再选择进行推荐与否</p>
<h5 id="模型训练">（2）<strong>模型训练</strong>：</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211626.png" /></p>
<h5 id="缺点">（3）<strong>缺点</strong>：</h5>
<ul>
<li>仅用了ID embedding，没有利用物品、用户属性</li>
<li>负样本的选取方式不对</li>
<li>做训练的方法不好
<ul>
<li>内积不如余弦相似度</li>
<li>用平方损失（回归）不如用交叉熵损失（分类）</li>
</ul></li>
</ul>
<h5 id="注意">（4）<strong>注意</strong>：</h5>
<ul>
<li>通常，对于用户数量和物品数量很大的平台，对应的学习矩阵A和B的维度会非常大，这时候对参数的存储需要做改进。通常，对于用户的学习矩阵A，采用key-value的方式，进行存储，key为用户id，value为对应的矩阵列</li>
</ul>
<h5 id="线上服务">（5）线上服务</h5>
<p>从这里可以看出，用户学习矩阵和物品学习矩阵的行数应该是一样的，因为它们要进行内积</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211633.png" /></p>
<h5 id="近似最近邻查找">（6）近似最近邻查找</h5>
<h4 id="双塔模型">3、双塔模型</h4>
<h5 id="用户和物品的embedding">（1）用户和物品的embedding</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211640.png" /></p>
<h5 id="计算用户的对物品的兴趣">（2）计算用户的对物品的兴趣</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211649.png" /></p>
<h5 id="双塔模型的训练">（3）双塔模型的训练</h5>
<ul>
<li>Pointwise：独立看待每个正样本和负样本，做简单的二元分类</li>
<li>Pairwise：每次取出一个正样本、一个负样本</li>
<li>Listwise：每次取出一个正样本、几个负样本</li>
</ul>
<h5 id="pointwise训练">（4）Pointwise训练</h5>
<ul>
<li>把召回看做二元分类任务</li>
<li>对于正样本，鼓励cos(a,b) 接近+1</li>
<li>对于负样本，鼓励cos(a,b) 接近-1</li>
<li>控制正负样本数量为 1:2 或者 1:3</li>
</ul>
<h5 id="pairwise训练">（5）Pairwise训练</h5>
<p>基本想法：鼓励cos(a,b+)大于cos(a,b-)</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211657.png" /></p>
<p>损失函数：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211704.png" /></p>
<h5 id="listwise训练">（6）Listwise训练</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211713.png" /></p>
<h5 id="正负样本">（7）正负样本</h5>
<p>【1】正样本</p>
<ul>
<li>类型：曝光而且有点击的用户—物品二元组</li>
<li>问题：少部分物品占据大部分点击，导致正样本大多是热门物品。</li>
<li>解决方案：过采样冷门物品，或降采样热门物品</li>
</ul>
<p>【2】负样本</p>
<ul>
<li>简单负样本：未被召回的物品（全体抽样），Batch负样本</li>
<li>困难负样本：被粗排淘汰的物品（比较困难）、精排分数靠后的物品（非常困难）</li>
<li><训练数据>：混合几种负样本，50%的负样本是简单负样本、50%的负样本的困难负样本</li>
</ul>
<p>注意：曝光但是没有点击的物品，不能成为负样本，因为很有可能是曝光后，用户没看到。这种负样本给训练排序的模型使用会更加合适</p>
<h4 id="双塔模型线上服务模型更新">4、双塔模型——线上服务、模型更新</h4>
<h5 id="双塔模型的召回">（1）双塔模型的召回</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211720.png" /></p>
<h5 id="模型更新">（2）模型更新</h5>
<ul>
<li>全量更新：今天凌晨，用昨天全天的数据训练模型。在昨天模型参数的基础上训练模型，不是重新初始化参数</li>
<li>增量更新：做online learning更新模型参数，增量更新ID
embedding参数</li>
</ul>
<h4 id="改进双塔模型方法自监督学习">5、改进双塔模型方法—自监督学习</h4>
<p>​
自监督的目的是为了把物品塔的参数训练得更好。自监督训练的原理就是，经过不同变换的物品在由物品塔进行embedding后要尽量的相似，不同物品之间embedding后要尽量不相似。其实感觉这种自监督的学习方法很相似。都是在已知数据条件的情况下，通过变动原有数据，使得经过模型变化后，变换前和变换后的物品依然相似。Bert也是同样的道理</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211727.png" /></p>
<h5 id="特征变化">（1）特征变化</h5>
<ul>
<li><p>Random
Mask：随机选一些离散特征，（比如类目），把它们遮住</p></li>
<li><p>Dropout（仅对多值离散特征生效）：Dropout是随机丢弃特征中50%的值</p></li>
<li><p>互补特征：把物品的特征随机分成两组，然后变换左右，左是随机mask
50%的特征，右则是随机mask 另外50%的特征</p></li>
<li><p>Mask一组关联的特征</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211734.png" /></p></li>
</ul>
<h4 id="deep-retrieval">6、Deep Retrieval</h4>
<p>把物品表征为路径，在线上查找用户最匹配的路径</p>
<h5 id="索引">（1）索引</h5>
<ul>
<li>路径 ➡ List<物品></li>
<li>物品 ➡ List<路径></li>
</ul>
<h5 id="预估模型">（2）预估模型</h5>
<p>神经网络预估用户对路径的兴趣</p>
<h5 id="线上召回">（3）线上召回</h5>
<p>用户➡路径➡物品</p>
<h5 id="训练">（4）训练</h5>
<ul>
<li>学习神经网络参数</li>
<li>学习物品表征（物品➡路径）</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211747.png" /></p>
<h5 id="总结">（5）总结</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211754.png" /></p>
<h4 id="tdm">7、TDM</h4>
<p><a
href="https://github.com/alibaba/x-deeplearning/wiki/%E6%B7%B1%E5%BA%A6%E6%A0%91%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%9E%8B(TDM)">TDM</a></p>
<h4 id="其他召回通道">8、其他召回通道</h4>
<h5 id="地理位置召回通道-geohash">（1）地理位置召回通道 GeoHash</h5>
<ul>
<li>用户可能对附近发生的事感兴趣</li>
<li>GeoHash：对经纬度的编码，地图上一个长方形区域</li>
<li>索引：GeoHash ➡ 优质笔记列表（时间倒排）</li>
<li>这条召回通道没有个性化</li>
</ul>
<h5 id="同城召回通道">（2）同城召回通道</h5>
<ul>
<li>用户可能对同城发生的事感兴趣</li>
<li>索引：同城➡ 优质笔记列表（时间倒排）</li>
<li>这条召回通道没有个性化</li>
</ul>
<h5 id="作者召回">（3）作者召回</h5>
<ul>
<li>用户对关注的作者发布的笔记感兴趣</li>
<li>索引：
<ul>
<li>用户 ➡ 关注的作者</li>
<li>作者 ➡ 发布的笔记</li>
</ul></li>
<li>召回：用户 ➡ 关注的作者 ➡ 最新的笔记</li>
</ul>
<h5 id="有交互的作者召回">（4）有交互的作者召回</h5>
<ul>
<li>如果用户对某笔记感兴趣，那么该用户可能对该作者的其他笔记也感兴趣</li>
<li>索引：用户 ➡ 有交互的作者</li>
<li>召回：用户 ➡ 有交互的作者 ➡ 最新的笔记</li>
</ul>
<h5 id="相似作者召回">（5）相似作者召回</h5>
<ul>
<li>如果用户喜欢某个作者，那么用户也会喜欢相似的作者</li>
<li>索引：作者 ➡ 相似作者</li>
<li>召回：用户 ➡ 感兴趣的作者 ➡ 相似的作者 ➡ 最新的笔记</li>
</ul>
<h5 id="缓存召回">（6）缓存召回</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211836.png" /></p>
<h4 id="曝光过滤-bloom-filter">9、曝光过滤 &amp; Bloom Filter</h4>
<h5 id="曝光过滤">（1）曝光过滤</h5>
<p>​ 其实就是，如果物品对用户曝光过，就不再推荐这个物品给用户</p>
<h5 id="bloom-filter">（2）Bloom Filter</h5>
<ul>
<li>判断一个物品ID是否在已曝光的物品集合中</li>
<li>如果判断为no，则说明一定不在已曝光的物品中</li>
<li>如果为yes，则很有可能在已曝光的物品中，但也有可能是误判
【因为原理用的hash，可能映射到同一位置】</li>
<li>算法实现：【Hash原理】
<ul>
<li>Bloom Filter 把物品集合表征为一个m维二进制向量</li>
<li>每个用户有一个曝光物品的集合，表征为一个向量，需要 m bit的存储</li>
<li>Bloom filter有k个哈希函数，每个哈希函数把物品ID映射成介于 0 和 m -
1之间的整数</li>
</ul></li>
</ul>
<h3 id="三排序">三、排序</h3>
<h4 id="多目标模型">1、多目标模型</h4>
<h5 id="模型原理图">（1）模型原理图</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211844.png" /></p>
<h5 id="模型训练-1">（2）模型训练</h5>
<ul>
<li><p>损失函数：交叉熵损失函数，就是一个分类拟合问题</p></li>
<li><p>困难：</p>
<ul>
<li>问题：会存在样本不平衡的情况，正样本会比负样本少</li>
<li>解决：负样本降采样（down
sample）。就是减少负样本，同时也可以减少计算量</li>
</ul></li>
<li><p>预估值校准</p></li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211852.png" /></p>
<h4 id="多任务学习模型mmoe">2、多任务学习模型（MMOE）</h4>
<h5 id="模型原理图-1">（1）模型原理图</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211859.png" /></p>
<p><img src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20241114212021361.png" alt="image-20241114212021361" style="zoom:33%;" /></p>
<h5 id="极化现象">（2）极化现象</h5>
<ul>
<li>本质：就是softmax在输出的时候，会偏向于输出的某个数值过大，也就会导致忽视了其他神经网络的输出</li>
<li>解决：在实际中，可以使用dropout对softmax的输出做调整
<ul>
<li>softmax输出的n个数值被mask的概率都是10%，也就是每个专家被忽视的概率都为10%</li>
</ul></li>
</ul>
<h4 id="预估分数的融合">3、预估分数的融合</h4>
<p>（1）简单的加权融合</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211908.png" /></p>
<p>国外某短视频</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211914.png" /></p>
<p>快手：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211920.png" /></p>
<p>国内某电商</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211927.png" /></p>
<h4 id="视频播放建模">4、视频播放建模</h4>
<h5 id="播放时长">（1）播放时长</h5>
<p>实际上，我们会用exp(z)，作为最终的视频预估播放时长</p>
<p>​ <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211934.png" /></p>
<h5 id="完播率">（2）完播率</h5>
<ul>
<li>回归：一个视频播放了70%，那它作为真实数据的标签就是0.7，然后用一个交叉熵作为神经网络的损失函数，就能实现拟合的效果</li>
<li>二元分类：先定义好完播指标，然后根据视频的完播率将视频标记为正样本或者负样本，正负样本构成二元分类任务</li>
</ul>
<p>注意：不能直接把预估的完播率用到融合公式中，因为视频越长，完播率越低。用
P(finish) = 预估完播率 / f(视频长度)</p>
<h4 id="排序模型的特征">5、排序模型的特征</h4>
<p>也就是要输入到排序模型的数据，包括以下几个特征：</p>
<h5 id="用户画像">（1）用户画像</h5>
<ul>
<li>用户ID</li>
<li>人口统计学属性：年龄、性别</li>
<li>账号信息：新老、活跃度</li>
<li>感兴趣类目：关键词</li>
</ul>
<h5 id="物品画像">（2）物品画像</h5>
<ul>
<li>物品ID</li>
<li>发布时间</li>
<li>GeoHash、所在城市</li>
<li>标题、类目、关键词、品牌</li>
<li>字数、图片数、视频清晰度、标签数</li>
</ul>
<h5 id="用户统计特征">（3）用户统计特征</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211943.png" /></p>
<h5 id="笔记统计特征">（4）笔记统计特征</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211951.png" /></p>
<h5 id="场景特征">（5）场景特征</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313211957.png" /></p>
<h4 id="特征处理">6、特征处理</h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212005.png" /></p>
<h4 id="粗排">7、粗排</h4>
<p>前期融合模型用于精排，后期融合模型用于粗排</p>
<h5 id="粗排的三塔模型">（1）粗排的三塔模型</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212012.png" /></p>
<h3 id="四特征交叉">四、特征交叉</h3>
<h4 id="factorized-machinefm">1、Factorized Machine（FM）</h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212018.png" /></p>
<p><strong>优点</strong>：</p>
<ul>
<li>线性模型的替代品，能用线性回归和逻辑回归的场景，都可以用FM</li>
<li>使用二级交叉特征，表达能力比线性模型更强</li>
<li>降低了二级交叉特征的数量</li>
</ul>
<p>【扩展】</p>
<ul>
<li>特征交叉，两个特征不仅能相加，还能相乘。这样可以提升模型的表达能力。能更好的反应物品的</li>
</ul>
<h4 id="深度交叉网络dcndeep-cross-network">2、深度交叉网络（DCN）【Deep
&amp; Cross NetWork】</h4>
<p>可以用于排序，也可以用于召回。有点像ResNet</p>
<h5 id="交叉层">（1）交叉层</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212026.png" /></p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314130320.png" /></p>
<h5 id="dcn模型">（2）DCN模型</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212034.png" /></p>
<h4 id="lhuc网络结构">3、LHUC网络结构</h4>
<p>只能用于精排，也就是前期融合。起源于语音识别模型</p>
<h5 id="用于语音识别的lhuc网络">（1）用于语音识别的LHUC网络</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212041.png" /></p>
<h5
id="推荐系统排序模型中的lhuc模型1">（2）推荐系统排序模型中的LHUC模型1</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212047.png" /></p>
<h4 id="senet">4、SENet</h4>
<h5 id="使用senet对-field-做离散特征加权">（1）使用SENet对 Field
做离散特征加权</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212053.png" /></p>
<ul>
<li>其实就是对离散特征做 filed-wise 加权</li>
<li>Field</li>
</ul>
<h5 id="field-间特征交叉">（2）Field 间特征交叉</h5>
<ul>
<li>内积</li>
<li>哈达玛乘积</li>
<li>Bilinear Cross （内积）</li>
<li>Bilinear Cross （哈达玛乘积）</li>
</ul>
<h3 id="五行为序列">五、行为序列</h3>
<h4 id="用户行为序列建模-lastn特征">1、用户行为序列建模 lastN特征</h4>
<ul>
<li>用户最近的n次交互（点击、点赞等）的物品ID</li>
<li>对lastN物品做embedding，得到n个向量</li>
<li>把n个向量取平均，作为用户的一个特征</li>
<li>适用于召回的双塔模型、粗排三塔模型、精排模型</li>
</ul>
<h4 id="din模型">2、DIN模型</h4>
<ul>
<li>DIN用加权平均代替平均，即注意力机制</li>
<li>权重：候选物品与用户LastN物品相似度</li>
</ul>
<p>模型整体流程：</p>
<ul>
<li>对于某候选物品，计算它与用户LastN物品的相似度</li>
<li>以相似度为权重，求用户LastN物品向量的加权和，结果是一个向量</li>
<li>把这个向量作为一种用户特征，输入排序模型，预估（用户、候选物品）的点击率、点赞率等指标</li>
<li>本质是注意力机制</li>
</ul>
<h4 id="sim模型">3、SIM模型</h4>
<ul>
<li>保留用户长期行为记录，n的大小可以是几千</li>
<li>对于每个候选物品，在用户LastN记录中做快速查找，找到k个相似物品</li>
<li>把LastN变成TopK，然后输入到注意力层</li>
<li>SIM减少了计算量（从n降到k）</li>
</ul>
<p><strong>SIM模型具体步骤：</strong></p>
<h5 id="第一步查找">（1）第一步：查找</h5>
<ul>
<li>方法一：Hard Search
<ul>
<li>根据候选物品的类目，保留LastN物品中类目相同的</li>
<li>简单、快速、无需训练</li>
</ul></li>
<li>方法二：Soft Search
<ul>
<li>把物品做embedding，变成向量</li>
<li>把候选物品向量作为query，做k近邻查找，保留LastN物品中最接近的k个</li>
<li>效果更好，编程实现更复杂</li>
</ul></li>
</ul>
<h5 id="第二步注意力机制">（2）第二步：注意力机制</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212101.png" /></p>
<p><strong>小Trick：</strong>使用时间信息</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212107.png" /></p>
<h3 id="六重排">六、重排</h3>
<p>【我感觉重排就是在保证原来物品符合用户爱好的同时，尽可能的保留物品的多样性。为什么叫重排呢？因为重排，重新排序，本来只需要根据用户和物品特征，预测物品对用户的吸引力指标，择优推荐就可以。但是现在需要对这些东西进行重新排序，使得不会导致给用户推荐那些虽然吸引力指标很高，但是它们之间过于相似的物品】</p>
<h4 id="推荐系统中的多样性">1、推荐系统中的多样性</h4>
<p>​
其实可以简单理解为物品需要更符合用户的口味的同时，还要更多样，这样不会导致频繁的给用户推荐单一的物品，这样会导致用户“审美疲劳”</p>
<h5 id="物品相似度的度量">（1）物品相似度的度量</h5>
<ul>
<li>基于物品属性标签</li>
<li>基于物品向量表征</li>
</ul>
<h5 id="提升多样性的方法">（2）提升多样性的方法</h5>
<h4
id="mmr多样性算法maximal-marginal-relevance">2、MMR多样性算法（Maximal
Marginal Relevance）</h4>
<h5 id="原理-2">（1）原理</h5>
<p>​
其实原理就是，将已选中的物品，跟未选中的物品做一个相似度计算，然后根据计算结果抑制为选中物品，相似度越大，就越要抑制。因为这个物品还没被选中推荐，与它相似的物品就已经被选中推荐给用户了，再推荐这个物品就极有可能对用户起不了吸引作用。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212115.png" /></p>
<h5 id="流程">（2）流程</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212123.png" /></p>
<h5 id="滑动窗口">（3）滑动窗口</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212129.png" /></p>
<h4 id="重排的规则">3、重排的规则</h4>
<h5 id="最多连续出现k篇某种笔记">（1）最多连续出现k篇某种笔记</h5>
<h5
id="每k篇笔记最多出现一篇某种笔记">（2）每k篇笔记，最多出现一篇某种笔记</h5>
<h5
id="前t篇笔记最多出现k篇某种笔记">（3）前t篇笔记最多出现k篇某种笔记</h5>
<h4 id="dpp-行列式点过程">4、DPP （行列式点过程）</h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212136.png" /></p>
<p>​
工业上精确求解DPP是不太可能，实际上会使用贪心算法，使得添加的物品要使得推荐系数更大，也不能跟已有的物品过于相似</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212142.png" /></p>
<p>​
如果单纯要用暴力算法，来算出这个这个推荐过程，那么所需要消耗的时间是非常恐怖的，工业上不会采用这种做法，而是采用一种叫Hulu的快速算法，其实就是矩阵分解的思路。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212148.png" /></p>
<h5 id="dpp扩展">DPP扩展</h5>
<ul>
<li>添加滑动窗口</li>
<li>添加规则约束</li>
</ul>
<h3 id="七物品冷启动">七、物品冷启动</h3>
<p>冷启动的意思，是对新发布的物品进行推荐。</p>
<p><strong>优化冷启的目标：</strong></p>
<ul>
<li>精准推荐</li>
<li>激励发布</li>
<li>挖掘高潜</li>
</ul>
<p><strong>冷启动的优化点：</strong></p>
<ul>
<li>优化全链路（包括召回和排序）</li>
<li>流量调控（流量怎么在新物品和老物品中分配）</li>
</ul>
<h4 id="冷启动的评价指标">1、冷启动的评价指标</h4>
<ul>
<li>作者侧指标：
<ul>
<li>发布渗透率、人均发布量</li>
</ul></li>
<li>用户侧指标：
<ul>
<li>新笔记指标：新笔记的点击率、交互率</li>
<li>大盘指标：消费时长、日活、月活</li>
</ul></li>
<li>内容侧指标：
<ul>
<li>高热笔记占比</li>
</ul></li>
</ul>
<h4
id="简单的召回通道基于笔记向量或者标签做推荐">2、简单的召回通道（基于笔记向量或者标签做推荐）</h4>
<h5 id="双塔模型-1">（1）双塔模型</h5>
<ul>
<li>新笔记使用 default embedding</li>
<li>利用相似物品的 embedding 向量</li>
</ul>
<h5 id="类目召回通道">（2）类目召回通道</h5>
<ul>
<li>用户画像</li>
</ul>
<h5 id="基于关键词的召回">（3）基于关键词的召回</h5>
<p>注：类目召回和关键词召回，都存在明显的缺点：</p>
<ol type="1">
<li>只对刚刚发布的新笔记有效
<ul>
<li>因为它们的索引列表中的数据，是根据发布时间倒序排序的，所以在很大程度上会造成比较早发布的作品，被忽视</li>
</ul></li>
<li>弱个性化，不够精准</li>
</ol>
<h4
id="聚类召回基于笔记的图文内容做推荐">3、聚类召回***（基于笔记的图文内容做推荐）</h4>
<h5 id="召回原理">（1）召回原理</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212156.png" /></p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212203.png" /></p>
<h5 id="内容相似度模型">（2）内容相似度模型</h5>
<p>​
这里需要调用一个神经网络，需要把笔记的图文内容，转换成对应的向量，然后还需要在头部添加两个向量之间的余弦相似度计算进行后处理。模型的训练易懂，就是分为正样本笔记、种子笔记、负样本笔记，我们只需要使得种子笔记跟正样本笔记的余弦相似度更大，与负样本的余弦相似度更小就可以。那么怎么选择正样本和负样本呢？</p>
<h5 id="训练数据">（3）训练数据</h5>
<ul>
<li><p>&lt;种子笔记，正样本&gt;</p>
<ul>
<li>方法一：人工标注二元组的相似度</li>
<li>算法自动选取正样本</li>
</ul></li>
<li><p>&lt;种子笔记，负样本&gt;</p>
<p>从全体笔记中随机选出满足条件的</p>
<ul>
<li>字数较多（神经网络提取的文本信息有效）</li>
<li>笔记质量较高，避免图文无关</li>
</ul></li>
</ul>
<h4 id="look-alike人群扩散召回">4、Look-Alike人群扩散召回</h4>
<p>小红书用于新笔记召回</p>
<p><strong>原理大概是这样的</strong>：新笔记发布之后，会有部分用户对该笔记感兴趣，会对该笔记进行点赞，转发等操作。我们把这一类用户称为种子用户，然后计算种子用户的embedding，可以是复用双塔模型的用户embedding，然后对这些用户的embedding求平均，可以得到唯一一个向量，这个向量作为新笔记的表征，存入向量数据库中。当其他用户刷新软件时，我们会将用户的embedding和向量数据库中的新笔记的表征计算相似度，取出相似度靠前的笔记作为召回数据。</p>
<h4 id="流量调控">5、流量调控</h4>
<h5 id="流量调控技术的发展">（1）流量调控技术的发展</h5>
<ol type="1">
<li>在推荐结果中强插新笔记</li>
<li>对新笔记的排序分数做提权（boost），也就是加权，提高新笔记的权重或者得分</li>
<li>【高级】保量。（比如保证每一篇新笔记在近24小时都有近100次的曝光）其实就是保证新笔记的曝光量。通过提权来实现</li>
<li>【更高级】 差异化保量。根据内容质量，确定保量的大小</li>
</ol>
<h5 id="新笔记提权">（2）新笔记提权</h5>
<h5 id="新笔记保量">（3）新笔记保量</h5>
<p>差异化保量。</p>
<ul>
<li>内容质量：用模型评价内容质量高低，基于额外保量目标，再设定一个上限</li>
<li>作者质量：根据作者历史上的笔记质量，给予额外保量目标</li>
</ul>
<h4 id="ab测试-1">6、AB测试</h4>
<h3 id="七涨指标的方法">七、涨指标的方法</h3>
<h4 id="概述">1、概述</h4>
<ol type="1">
<li>改进召回模型，或者添加新的召回模型</li>
<li>改进粗排和精排模型</li>
<li>提升召回、粗排、精排中的多样性</li>
<li>特殊对待新用户、低活用户等特殊人群</li>
<li>利用关注、转发、评论这三种交互行为</li>
</ol>
<h4 id="召回">2、召回</h4>
<ul>
<li>双塔模型和 item-to-item
是最重要的两类召回模型，占据召回的大部分配额</li>
<li>可以适当添加小众的召回模型，虽然占据配额很少，但是提升核心指标会相对比较明显</li>
<li>添加内容池，对召回也有很大的帮助</li>
</ul>
<h5 id="改进双塔模型">（1）改进双塔模型</h5>
<ul>
<li>方向1：优化正样本、负样本</li>
<li>方向2：改进神经网络结构
<ul>
<li>Baseline：</li>
<li>用户塔、物品塔分别使用DCN代替全连接网络</li>
<li>在用户塔中使用用户行为序列（last-n）</li>
<li>使用多向量模型代替单向量模型</li>
</ul></li>
<li>方向3：改进训练方法
<ul>
<li>Baseline：做二分类，让模型快速学习分辨正负样本</li>
<li>结合二分类，batch内负采样</li>
<li>使用自监督学习，让冷门物品的embedding学得更好</li>
</ul></li>
</ul>
<h5 id="item-to-item">（2）Item-to-Item</h5>
<ul>
<li>最常见的用法就是：U2I2I</li>
<li>计算物品相似度
<ul>
<li>方法1：ItemCF及其变体</li>
<li>方法2：基于物品向量表征，计算向量相似度</li>
</ul></li>
</ul>
<h5 id="小众的模型">（3）小众的模型</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212215.png" /></p>
<h5 id="总结-1">总结：<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212222.png" /></h5>
<h4 id="排序模型">3、排序模型</h4>
<p><strong>【精排】</strong></p>
<h5 id="精排模型基座">（1）精排模型：基座</h5>
<ul>
<li>基座的输入包括离散特征和连续特征，输出一个向量，作为多目标预估的输入</li>
<li>改进1：基座加宽加深，计算量更大，预测更准确</li>
<li>改进2：做自动的特征交叉，比如 bilinear 和 LHUC</li>
<li>改进3：特征工程，比如添加统计特征、多模态内容特征等</li>
</ul>
<h5 id="精排模型多目标预估">（2）精排模型：多目标预估</h5>
<ul>
<li>基于基座模型输出的向量，同时预估点击率等多个目标</li>
<li>改进1：增加新的预估目标，并把预估结果加入融合公式中</li>
<li>改进2：MMoE、PLE等结构可能有效，但<strong>往往无效</strong></li>
<li>改进3：纠正position bias，可能有效，也可能无效</li>
</ul>
<p><strong>【粗排】</strong></p>
<h5 id="粗精排一致性建模">（3）粗精排一致性建模</h5>
<ul>
<li>蒸馏精排训练粗排，让粗排与精排更一致</li>
<li>方法1：pointwise蒸馏
<ul>
<li>设y是用户真实行为，设p是精排的预估</li>
<li>用 (y+p)/2 作为粗排拟合的目标</li>
</ul></li>
<li>方法2：pariwise 或 listwise 蒸馏
<ul>
<li>给定 k 个候选物品，按照精排预估做排序</li>
<li>做 learning to rank (LTR)，让粗排拟合物品的序</li>
</ul></li>
<li>优点：粗精排一致性建模可以提升核心指标</li>
<li>缺点：如果精排出 bug，精排预估值p有偏，会污染粗排训练数据</li>
</ul>
<h5 id="用户行为序列建模">（4）用户行为序列建模</h5>
<p>基础建模方法：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313213459.png" /></p>
<ul>
<li>改进1：增加序列长度，让预测更准确，但是会增加计算成本和推理成本。</li>
<li>改进2：筛选，目的是降低序列长度。筛选方法，比如用类目、物品向量表征聚类</li>
<li>改进3：对用户行为序列中的物品，使用除ID以外的一些特征</li>
</ul>
<h5 id="在线学习增量更新">（5）在线学习【增量更新】</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212237.png" /></p>
<h5 id="老汤模型">（6）老汤模型</h5>
<ul>
<li>问题一：如何判断新模型结构优于老模型
<ul>
<li>对于新老模型结构，都随机初始化全连接层</li>
<li>Embedding层可以是随机初始化的，也可以是复用老模型训练好的参数</li>
<li>用 n 天的数据训练新老模型。（从旧到新，训练一个epoch）</li>
<li>如果新模型显著优于老模型，新模型很可能更优</li>
</ul></li>
<li>问题二：如何快速追平线上老模型
<ul>
<li>方法1：尽可能复用老模型训练好的embedding层，避免随机初始化embedding层</li>
<li>方法2：用老模型做teacher，蒸馏新模型。（用户真实行为是y，老模型的预测是p，用(y+p)/2
作为训练新模型的目标）</li>
</ul></li>
</ul>
<h4 id="提升多样性">4、提升多样性</h4>
<h5 id="精排多样性">（1）精排多样性</h5>
<ul>
<li><p>精排阶段，结合兴趣分数和多样性分数对物品i排序</p>
<ul>
<li><p>si：兴趣分数，即融合点击率等多个预估目标</p></li>
<li><p>di：多样性分数，即物品i与已经选中的物品的差异</p></li>
<li><p>用si+di对物品做排序</p></li>
</ul></li>
<li><p>常用
MMR、DPP等方法计算多样性分数，精排使用滑动窗口，粗排不使用滑动窗口</p>
<ul>
<li>精排决定最终的曝光，曝光页面上邻近的物品相似度应该小</li>
<li>粗排要考虑整体多样性，而非一个滑动窗口中的多样性</li>
</ul></li>
<li><p>除了多样性分数，精排还是用打散策略增加多样性</p>
<ul>
<li>就是限制前几个推荐位置不允许出现重复的类目</li>
</ul></li>
</ul>
<h5 id="粗排多样性">（2）粗排多样性</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212245.png" /></p>
<h5 id="召回多样性">（3）召回多样性</h5>
<ul>
<li><p>双塔模型：添加噪声</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212251.png" /></p></li>
<li><p>双塔模型：抽样用户行为序列</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212301.png" /></p></li>
<li><p>U2I2I：抽样用户行为序列</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212308.png" /></p></li>
</ul>
<h5 id="探索流量">（4）探索流量</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212317.png" /></p>
<h4 id="特殊对待特殊人群">5、特殊对待特殊人群</h4>
<h5 id="主流方法">（1）主流方法：</h5>
<ol type="1">
<li>构造特殊内容池，用于特殊用户人群的召回</li>
<li>使用特殊的排序策略，保护特殊的用户</li>
<li>使用特殊的排序模型，消除模型预估的偏差</li>
</ol>
<h5 id="构造特殊内容池">（2）构造特殊内容池</h5>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212325.png" /></p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314130159.png" /></p>
<h5 id="特殊的排序策略">（3）特殊的排序策略</h5>
<ul>
<li>排除低质量物品</li>
<li>差异化的融分公式</li>
</ul>
<h5 id="特殊的排序模型">（4）特殊的排序模型</h5>
<ul>
<li>差异化的排序模型
<ul>
<li>方法1：大模型 + 小模型</li>
<li>方法2：融合多个 experts，类似MMoE</li>
<li>方法3：大模型预估之后，用小模型做校准</li>
</ul></li>
</ul>
<h4 id="交互行为">6、交互行为</h4>
<h5 id="关注">（1）关注</h5>
<ul>
<li><p>关注量对留存的价值</p></li>
<li><p>构造促关内容池和召回通道</p>
<ul>
<li>就是构造递减函数，关注作者数作为自变量。为关注率新增一项权值，调整关注率的数值</li>
</ul></li>
<li><p>粉丝数对促发布的价值</p>
<ul>
<li>也是构造递减函数，粉丝数作为自变量。为被关注率新增一项权值，调整被关注率的数值</li>
</ul></li>
<li><p>隐式关注关系</p>
<ul>
<li>隐式关注关系：用户u喜欢看作者a发布的物品，但是u没关注a</li>
</ul></li>
</ul>
<h5 id="转发分享">（2）转发（分享）</h5>
<ul>
<li>KOL（Key Opinion Leader）建模
<ul>
<li>其他平台的KOL的转发可以吸引大量站外流量</li>
<li>判断用户是否为其他平台的KOL？看用户历史转发，平均能带来多少站外流量</li>
</ul></li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250313212334.png" /></p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250314130143.png" /></p>
<h5 id="评论">（3）评论</h5>
]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本指令</title>
    <url>/2025/03/12/Hexo/hexo%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>  如果只是满足平时写写博客，推送到GitHub方便在各处访问的话，其实这下面这几个命令就够了。但是这篇博文会一直更新，博主有用到别的指令会及时来这里更新。</p>
<ol type="1">
<li><p>首先是创建一个新的页面的指令，在终端敲击。由于博主使用的是WebStorm，所以是在应用里的终端界面敲击的。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;page_name&quot;</span>    <span class="comment"># 创建新的页面</span></span><br></pre></td></tr></table></figure> <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312090453.png" /></p></li>
<li><p>其次是准备部署线上环境需要使用到的指令，三个命令行同时运行，就能将新写的博文推送到GitHub啦，当然部署也需要时间，只要指令运行不报错，就耐心等待一下啦
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo clean   <span class="comment"># 清除之前生成的渲染文件</span></span><br><span class="line"></span><br><span class="line">hexo g   <span class="comment"># 生成新的渲染文件</span></span><br><span class="line"></span><br><span class="line">hexo d   <span class="comment"># 推送到GitHub进行自动部署</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></p></li>
<li><p>在本地查看渲染效果，运行该指令之后直接访问
<code>http://localhost:4000/</code>, 就可以看到渲染后的最新博客
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo s     <span class="comment"># hexo start 的意思，就是开启项目 </span></span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <url>/2024/12/03/Hexo/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>❗本文针对hexo的Next主题的设置有效，其他主题可以看看有没有相同字段
Next默认是会在首页显示全文的，看起来冗长不简洁。要想首页仅展示文章标题或者摘要，请按照以下步骤进行：</p>
<h3 id="修改配置">修改配置</h3>
<p>首先需要在Next主题的<code>_config.yml</code>中把设置打开(默认安装时就打开了):
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="设置展示的内容">设置展示的内容</h3>
<h4 id="方法一写概述">方法一：写概述</h4>
<p>在文章的<code>front-matter</code>中添加<code>description</code>，其中<code>descriptio</code>n中的内容就会被显示在首页上，其余一律不显示。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/Snipaste_2024-12-04_00-04-00.png" /></p>
<p>PS:
这种方法主要是要自己对文章内容进行简单总结，有时候不喜欢写总结介绍的话，可以用下面第二种方法</p>
<h4 id="方法二文章截断">方法二：文章截断</h4>
<p>在需要截断的地方加入： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>
首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p>
<p>这个明显会方便很多，但当然有利有弊，我一般喜欢用方法一，也希望自己写的<code>description</code>能够给读者快速了解文章内容的效果</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
