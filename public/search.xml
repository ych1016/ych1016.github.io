<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【力扣】面试经典150题</title>
    <url>/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一力扣面试经典-150-题">一、力扣面试经典 150 题</h1>
<h2 id="数组字符串">1. 数组/字符串</h2>
<h3 id="合并两个有序数组">1.1 <a
href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">合并两个有序数组</a></h3>
<p>这道题目主要是利用到归并排序的思路，定义两个数组下标，比较数组对应的值，选择小的值插进新数组。需要注意的是，while
循环后还需要把剩下的数组遍历下去。这里还有一个点需要注意，就是 Java
的函数传参和数组赋值问题，Java
函数传递数组时，传进来的是数组地址，所以如果只是简单的给数组赋值新的数组，实际的数组并不会发生改变
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) res[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> res[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) res[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) res[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (m + n &gt;= <span class="number">0</span>) System.arraycopy(res, <span class="number">0</span>, nums1, <span class="number">0</span>, m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.2 <a
href="https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">移除元素</a></p>
<p>这个就是一个简单的双指针问题，我们只需要记录不等于给定值的下标，然后遍历数组，只要数值不等于给定值的数字，我们就使用初始定义的下标记录下来
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.3 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除有序数组中的重复元素</a></p>
<p>这道题目跟上面的题目一样，相当于上面是要记录不等于指定值，也就是重复值为
0。这道题目则是允许重复值为 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!record.contains(nums[i])) &#123;</span><br><span class="line">            record.add(nums[i]);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除有序数组中的重复项-ⅱ">1.4 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除有序数组中的重复项
Ⅱ</a></h3>
<p>这道题目也是跟上面题目一样的思路。上一道题目是允许重复值为
1，这道题目是允许重复值为 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!record.containsKey(nums[i])) &#123;</span><br><span class="line">            record.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(record.get(nums[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">            record.put(nums[i], <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多数元素">1.5 <a
href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">多数元素</a></h3>
<p>多数元素是出现次数超过数组长度一半的数。这道题目可以用相互抵消的思路来理解。因为它出现的次数多于总体一半，所以它与其他数出现次数相互抵消后，就一定还会存在这个数
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num) cnt++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                num = nums[i];   cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.6 <a
href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&amp;envId=top-interview-150">轮转数组</a></p>
<p>这道题目的主要思路是利用到数组反转的原理。其实原理很简单，要将数组中的元素整体向右移
k 个单位，只需要将整个数组，整体反转，然后分别反转前 k 位和后 k 位
<strong>eg：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;  end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.7 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机</a>
这道题目因为给了全部的天数数据，所以具有预知性，所以，我们可以从后开始遍历数组，记录后面哪一天是出价最高的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length, maxNum = prices[n-<span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res = Math.max(res, maxNum - prices[i]);</span><br><span class="line">        maxNum = Math.max(maxNum, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.8 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅱ</a>
因为可以多次购买，多次出售。这道题目跟前面的题目就不一样了。我们并不需要考虑什么时候出售，我们只需要在有差价，能挣钱的时候出售就可以
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>]) res += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.9 <a
href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&amp;envId=top-interview-150">跳跃游戏</a>
初看题目像是要遍历很多次，其实不用。我们只需要维护一个距离变量。表示从当前所在下标能到达的最远距离即可。若当前下标比最远距离还要大，说明前面的点，没办法到达当前下标的位置，也就是不可能完成这个跳跃任务，我们直接返回
false 即可 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.10 <a
href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">跳跃游戏
Ⅱ</a> 这一道题目的主要思路就是看当前所在位置能到达多远的距离，end
暂存下来，相当于从当前位置跳到 end
只需要一步，然后逐步更新能到达的最远距离。当当前位置到达 end
时，说明这一步能到达的最远距离已经更新完了，也就是需要再跳一次了，这样就能记录下所需要的最少跳数
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            res++;   end = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="h-指数">1.11 <a
href="https://leetcode.cn/problems/h-index/?envType=study-plan-v2&amp;envId=top-interview-150">H
指数</a></h3>
<p>这道题目其实用的是一个桶计数思路，但是这里有一个需要注意的是，当一篇文章的被引用次数超过实际数组长度时，我们只需要把它看成引用次数是数组长度就可以，这样可以减少很大的内存空间。然后桶主要记录的是引用次数对应出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> citation : citations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citation &gt; n) cnt[n]++;</span><br><span class="line">        <span class="keyword">else</span> cnt[citation]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        total += cnt[i];</span><br><span class="line">        <span class="keyword">if</span>(total &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="o1时间插入删除和获取随机元素">1.12 <a
href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&amp;envId=top-interview-150">O(1)时间插入、删除和获取随机元素</a></h3>
<p>这道题目主要用到一个 Hash 映射，通过可变数数组进行实现。但是这里用到
HashMap 集合，会让人感觉不是在 O(1)的时间内完成的操作。其实是 O(1)，因为
HashMap 的插入和删除，都是围绕下标进行，而 hash
获取下标只需要一个函数的映射操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(val);</span><br><span class="line">        map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.set(map.get(val), nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        map.put(nums.get(nums.size() - <span class="number">1</span>), map.get(val));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get(random.nextInt(nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除自身以外数组的乘积">1.13 <a
href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&amp;envId=top-interview-150">除自身以外数组的乘积</a></h3>
<p>这道题目本来可以用前缀积做，但是题目要求不能使用除法，所以这道题目需要在前缀积的基础上稍加改变一下。我们只需要定义一个中间变量，先将最终答案置为这个中间变量再进行前缀积，实现在当前位置赋值时，是前面变量的乘积。同时由于题目要求，是除当前位置的其他所有变量的乘积，所以需要从左向右走一遍，然后再从右向左走一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res[i] = left;</span><br><span class="line">        left = left * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        res[i] *= right;</span><br><span class="line">        right = right * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加油站">1.14 <a
href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&amp;envId=top-interview-150">加油站</a></h3>
<p>这道题目其实并不需要去每一个点进行探索，只需要计算 gas 和 cost
的差值的前缀和就能解决这个问题。<strong>因为只要差值
&gt;=0，就一定能绕圈走。</strong>所以我们的解题的最终目标变成了，探索从哪一个点开始出发。探索从哪个点开始出发也比较简单，我们看前缀和在哪里
&lt;0
了，说明在它前面的点出发是走不到当前的点的，所以出发点肯定需要从这个点的下一个点开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length, run = <span class="number">0</span>, sum = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        run += gas[i] - cost[i];</span><br><span class="line">        sum += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span> (run &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            run = <span class="number">0</span>;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= <span class="number">0</span> ? start : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分发糖果">1.15 <a
href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&amp;envId=top-interview-150">分发糖果</a></h3>
<p>两者兼顾很容易顾此失彼。如果想用一次遍历就解决问题，就必须时刻注意当前数左右两边的数，并且如果从左到右遍历，没发预测右边还未遍历的数字是否还会受到奖励。所以我们需要分开考虑，先走一遍从左到右，考虑左边数字对右边数字的影响，然后再走一遍从右到左，考虑右边数字对左边数字的影响。然后需要满足左边走得通，右边也得走得通，怎么办呢，各个位置上的数取从左到右，从右到左的最大值，就能实现两边都满足。</p>
<table>
<tr>
<td>
[1 0 2]<br/>[1 1 1] <br/>[1 1 2]<br/>[2 1 1]<br/>[2 1 2] 2+1+2 = 5<br/>
</td>
</tr>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        num1[i] = num2[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num1[i] = num1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            num2[i] = num2[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res += Math._max_(num1[i], num2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接雨水">1.16 <a
href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h3>
<p>这道题目的求解思路主要是，遍历数组，我们需要当前遍历位置，左边和右边最高的数值，然后对于这两个数值，去它们当中更小的那个数值（木桶效应），取出来之后需要减去当前位置的高度，算出差值。按照这种思路，我们需要多定义两个数组，分别记录当前位置左边的最大高度
leftMax[n]，和当前位置右边最大的高度
rightMax[n]，这样在遍历到当前位置时，当前位置的蓄水值为
min{rightMax[i],leftMax[i]} -
heigh[i]。然后我们会发现这种思路其实有一种更简洁的做法，我们不需要多定义两个额外的数组，只需要定义两个变量即可，分别记录
0...i 左边的最大高度 leftMax，和 i+1 ... n-1 的最大高度 rightMax，这样当
leftMax &lt; rightMax 时，我们更新左边；当 leftMax &gt; rightMax
时，我们更新右边；当 leftMax = rightMax
时，我们两边都更新。因为每次计算蓄水值时，我们都是拿 leftMax 和 rightMax
更小的那个值去更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, res = <span class="number">0</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightMax &lt; leftMax)&#123;</span><br><span class="line">            res += rightMax - height[right--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 两边都更新</span></span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right) &#123;</span><br><span class="line">                res += rightMax - height[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="罗马数字转整数">1.17 <a
href="https://leetcode.cn/problems/roman-to-integer/submissions/521990974/?envType=study-plan-v2&amp;envId=top-interview-150">罗马数字转整数</a></h3>
<p>比较简单的模拟题目...</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(array[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; map.get(array[i]) &lt; map.get(array[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            temp = map.get(array[i+<span class="number">1</span>]) - map.get(array[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数转罗马数字">1.18 <a
href="https://leetcode.cn/problems/integer-to-roman/?envType=study-plan-v2&amp;envId=top-interview-150">整数转罗马数字</a></h3>
<p>经典打表问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">            roman.append(symbols[i]);</span><br><span class="line">            num -= values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roman.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后一个单词的长度">1.19 <a
href="https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&amp;envId=top-interview-150">最后一个单词的长度</a></h3>
<p>模拟题，定义一个
StringBuilder，只需要从最后一个字符开始遍历，若不是空格，就开始记录下来，直到再遇到空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] == <span class="string">&#x27; &#x27;</span>) --i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] != <span class="string">&#x27; &#x27;</span>) res.append(charArray[i--]);</span><br><span class="line">    <span class="keyword">return</span> res.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共前缀">1.20 <a
href="https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&amp;envId=top-interview-150">最长公共前缀</a></h3>
<p>模拟问题，只需要算出字符串数组中最短的那个字符串长度，然后遍历这个长度，取出第一个字符串的字符，然后一一比对其他字符，如果一样就记录下来，如果不一样，就直接退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) len = Math.min(len, str.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strs.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != strs[j].charAt(i)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) res.append(ch);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转字符串中的单词">1.21 <a
href="https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">反转字符串中的单词</a></h3>
<p>这是一道简单的模拟题，我们只需要遍历一次给定的字符串，当遇到不是空格的字符时，把它记录下来，当再遇到空字符串时，我们把记录下来的这个字符串用列表记录下来。最后将整个列表反转一下，用
Collections 的 reverse 反转一下列表，就能实现反转单词的效果。然后再用
String 的 join 函数进行拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;String&gt; arr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s.charAt(i)!=<span class="string">&#x27; &#x27;</span> )&#123;</span><br><span class="line">                tmp.append(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections._reverse_(arr);</span><br><span class="line">    <span class="keyword">return</span> String._join_(<span class="string">&quot; &quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="z-字形变换">1.22 <a
href="https://leetcode.cn/problems/zigzag-conversion/description/?envType=study-plan-v2&amp;envId=top-interview-150">Z
字形变换</a></h3>
<p>这道题目看上去很复杂，其实我们只需要记录原字符串每一个字符应该放在哪一行就可以完成这个任务。比如</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/1.png" />
很明显，下标的规律就是先递增到指定 numRows - 1，然后再减少到
0。我们可以定义一个字符串数组，分别记录每一行需要记录的字符，最终将这些字符串数组拼接起来。这里有一个边界问题需要注意一下，就是当
numRows=1 时，实际上就是输出原来的字符串而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) index[i] = idx++;</span><br><span class="line">        <span class="keyword">else</span> index[i] = idx--;</span><br><span class="line">        <span class="keyword">if</span> (idx == numRows) &#123;</span><br><span class="line">            idx -= <span class="number">2</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            idx += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder[] arr = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>[numRows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) arr[i] = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[index[i]].append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) res.append(arr[i]);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出字符串中第一个匹配项的下标">1.23 <a
href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h3>
<p>这道题目是 KMP 的模板题目，抄模板即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> haystack.length(), n = needle.length();</span><br><span class="line">    <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>[] p = <span class="keyword">new</span> <span class="title class_">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) s[i + <span class="number">1</span>] = haystack.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) p[i + <span class="number">1</span>] = needle.charAt(i);</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 求Next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="双指针">2. 双指针</h2>
<h3 id="验证回文串">2.1 <a
href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=top-interview-150">验证回文串</a></h3>
<p>字符串处理的题目，这里可以直接用正则表达式完成。我们只需要定义需要保留字符的正则表达式，然后将不需要的字符替换成空字符串，然后将字符串整体转成小写，遍历一半字符串，看看另一半对应位置是否匹配即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = s.replaceAll(<span class="string">&quot;[^A-Za-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">2.2 <a
href="https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&amp;envId=top-interview-150">判断子序列</a></h3>
<p>这个题目直接用双指针就能完成，一层 for
循环遍历给定串，再定义目标串下标，若字符相同，则目标串下标往后移动；若到达目标串最后一位，则直接输出。需要判断的边界是，当两个字符串存在是空字符串的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.charAt(i) == s.charAt(idx)) idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数之和-ⅱ---输入有序数组">2.3 <a
href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和
Ⅱ - 输入有序数组</a></h3>
<p>这个是经典的双指针问题，因为它是有序数组，所以只需要定义头和尾数组，然后往中间靠就能完成这道题目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] == target) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="盛最多水的容器">2.4 <a
href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-interview-150">盛最多水的容器</a></h3>
<p>木桶效应，我们最终能盛最多水的容器取决于两根柱子中最短的那一根，并且取决于两根柱子之间的距离。使用双指针，定义前后两根柱子的位置，然后通过贪心的方法，取出最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        res = Math.max(Math.min(height[i], height[j]) * (j - i), res);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三数之和">2.5 <a
href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-interview-150">三数之和</a></h3>
<p>这道题目我主要用到两数之和的思想，三数之和为
0，只要把第三个数确定了，实际问题就变成了两数之和问题。因为两数之和给的是有序数组，所以，我们在这里需要先进行一个排序操作。然后枚举第一个数，再用两数之和的方法求出第二三个数出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span> - nums[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) ++i;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) --j;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) ++i;</span><br><span class="line">            <span class="keyword">else</span> --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="滑动窗口">3. 滑动窗口</h2>
<h3 id="长度最小的子数组">3.1 <a
href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">长度最小的子数组</a></h3>
<p>这道题目用到了前后滑动指针和前缀和的原理，设定一个前后指针和一个记录前缀和的变量。前缀和的变量记录前后指针之间的前缀和，当前缀和
&gt;=target 时，我们就记录距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE, l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = Math.min(r - l, res);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无重复字符的最长子串">3.2 <a
href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h3>
<p>有点像双指针的题目，记录一前一后两个指针，当前面的指针遍历到一个字符重复出现两次时，后面的指针往前移动，同时减少后面指针所指字符出现的次数，知道前面指针所指的字符重复出现次数
&lt;2 后，再移动前面的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">    Arrays.fill(cnts,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i)]++;</span><br><span class="line">        <span class="keyword">while</span> (cnts[s.charAt(i)] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            cnts[s.charAt(j)]--;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子串">3.3 <a
href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h3>
<p>两种解题思路，一种是利用动态规划，另外一种是利用双指针。我们一一讲解</p>
<p>——动态规划（五部曲）</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/db927238-7243-42da-b265-cf3c5e695c92.png" />
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/82efdcc2-127a-476b-ba29-579c97b65486.png" /></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">10</span>][s.length() + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; ++j) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i) &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">                res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——双指针</p>
<p>从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extend(s, i, i);</span><br><span class="line">        extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extend</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; str.length() &amp;&amp; str.charAt(l) == str.charAt(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            len = r - l + <span class="number">1</span>;</span><br><span class="line">            left = l;</span><br><span class="line">            right = r;</span><br><span class="line">        &#125;</span><br><span class="line">        --l;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回文子串">3.4 <a
href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a></h3>
<p>双指针直接把题目秒了，从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止。扩散之后如果是回文，结果数就
+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extendStr(s, i, i);</span><br><span class="line">        extendStr(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendStr</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;str.length() &amp;&amp; str.charAt(l) == str.charAt(r))&#123;</span><br><span class="line">        res++;</span><br><span class="line">        --l;  ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找到字符串中所有字母异位词">3.5 <a
href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h3>
<p>滑动窗口题目，在原字符串 s 上进行滑动，滑动窗口的大小是给定字符串 p
的长度，然后设定一个数组，记录滑动窗口中字符出现的个数，再设定一个变量值记录滑动窗口内的字母和给定字符串
p 是否有差别，如果没有差别，则将对应的下标记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length(), differ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30000</span>];</span><br><span class="line">    Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pLen &gt; sLen) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnts[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnts[i] != <span class="number">0</span>) differ++;</span><br><span class="line">    <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnts[ch];</span><br><span class="line">        ch = s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnts[ch];</span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="串联所有单词的子串">3.6 <a
href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&amp;envId=top-interview-150">串联所有单词的子串</a></h3>
<p>这道题目跟上面那道题目很像，但又不太一样。上面那道题目是字母，这题目是单词。官方的题解属实没看懂，放一版最后一个样例会超时的版本的，后续再优化一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), listLen = words.length, wordLen = words[<span class="number">0</span>].length(), totalLen = wordLen * listLen;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - totalLen + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; tmpMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + totalLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; totalLen; k += wordLen) &#123;</span><br><span class="line">            tmpMap.put(tmp.substring(k, k + wordLen), tmpMap.getOrDefault(tmp.substring(k, k + wordLen), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmpMap.equals(map)) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="矩阵">4. 矩阵</h2>
<h3 id="有效数独">4.1 <a
href="https://leetcode.cn/problems/valid-sudoku/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效数独</a></h3>
<p>这道题目有点像八皇后，与八皇后的区别是，现在是局限于一个 9<em>9
的矩阵中。所以我们可以定义一个 3</em>3<em>9 的矩阵，把原来 9</em>9
的矩阵分割成这样子，其中每个 9 代表记录一个 3<em>3
矩阵中的数出现的次数。现在问题在于，我们现在有数在 9</em>9 矩阵中的坐标
(i,j)， 怎么定位到自己独立 3*3 矩阵中？我们会发现
(i/3,j/3)，下面这些坐标 (0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1)
(2,2) 分别对应我们下面这 9 个矩阵的位置 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202532.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span>[][] cols = <span class="keyword">new</span> <span class="title class_">int</span>[n][n], rows = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span>[][][] nine = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">            cols[i][idx]++;</span><br><span class="line">            rows[j][idx]++;</span><br><span class="line">            nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx]++;</span><br><span class="line">            <span class="keyword">if</span> (cols[i][idx] &gt; <span class="number">1</span> || rows[j][idx] &gt; <span class="number">1</span> || nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="螺旋矩阵">4.2 <a
href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-interview-150">螺旋矩阵</a></h3>
<p>这个就是一个模拟题，我们根据题目，先往右，再往下，再往左，再往上。需要先定义方向导致的坐标变更，然后定义走到的坐标，我们先将坐标对应位置上的数加入到结果中，然后再试探性的往下走一步，看会不会越界。这里有个问题需要注意一下，我们走过的点不能再走，所以我们需要定义一个访问的
boolean
数组，表示位置是否被访问。当我们试探性的往下走一步发现走不下去的时候，我们就需要变更方向了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>, colIdx = <span class="number">0</span>, rowIdx = <span class="number">0</span>, newCol = <span class="number">0</span>, newRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n * m; ++i) &#123;</span><br><span class="line">        res.add(matrix[colIdx][rowIdx]);</span><br><span class="line">        vis[colIdx][rowIdx] = <span class="literal">true</span>;</span><br><span class="line">        newCol = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        newRow = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newCol &lt; <span class="number">0</span> || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newRow &gt;= m || vis[newCol][newRow]) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colIdx = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        rowIdx = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转图像">4.3 <a
href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&amp;envId=top-interview-150">旋转图像</a></h3>
<p>这个题目是数字位置变换的题目，我们通过观察可以发现，旋转后的数字位置，其实是原来矩阵先进行上下翻转，然后，再将下三角的数跟其坐标相反的数进行交换。比如
(i,j) 换到 (j,i)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 先上下反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - <span class="number">1</span> - i][j];</span><br><span class="line">            matrix[n - <span class="number">1</span> - i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后再将下三角的数，与横纵坐标相反的位置的数交换位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵置零">4.4 <a
href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&amp;envId=top-interview-150">矩阵置零</a></h3>
<p>直接记录原矩阵数值为 0
的位置，用列表存储对应的(i,j)，然后遍历记录的列表，就能实现题目要求的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; coordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) coordinates.add(Arrays.asList(i, j));</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; coordinate : coordinates) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> coordinate.get(<span class="number">0</span>), col = coordinate.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) matrix[row][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命游戏">4.5 <a
href="https://leetcode.cn/problems/game-of-life/?envType=study-plan-v2&amp;envId=top-interview-150">生命游戏</a></h3>
<p>模拟问题，新建一个新地图，然后根据规则在老地图遍历，并对新地图赋值。最后把新地图的数值复制给老地图即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] newBoard = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; direction.length; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[k][<span class="number">0</span>], col = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= n || col &lt; <span class="number">0</span> || col &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &lt; <span class="number">2</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (cnt == <span class="number">2</span> || cnt == <span class="number">3</span> )) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &gt; <span class="number">3</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第四种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; cnt == <span class="number">3</span>) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; n;++i) <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;m;++j) board[i][j] = newBoard[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="哈希表">5. 哈希表</h2>
<h3 id="赎金信">5.1 <a
href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&amp;envId=top-interview-150">赎金信</a></h3>
<p>这道题目只需要用桶的思路，记录 <code>magazine</code>
每个字符出现的次数，然后再遍历 <code>ransomNote</code>
看出现字符次数是否超过 <code>magazine</code> 字符出现的次数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] magazineCharCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(Character ch : magazine.toCharArray()) magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(Character ch: ransomNote.toCharArray()) &#123;</span><br><span class="line">        magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同构字符串">5.2 <a
href="https://leetcode.cn/problems/isomorphic-strings/?envType=study-plan-v2&amp;envId=top-interview-150">同构字符串</a></h3>
<p>定义两个 Hash 映射就能解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Character&gt; lTor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Character&gt; rTol = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lTor.get(s.charAt(i))!=<span class="literal">null</span> &amp;&amp; lTor.get(s.charAt(i)) != t.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rTol.get(t.charAt(i))!= <span class="literal">null</span> &amp;&amp; rTol.get(t.charAt(i)) != s.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lTor.put(s.charAt(i), t.charAt(i));</span><br><span class="line">        rTol.put(t.charAt(i), s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词规律">5.3 <a
href="https://leetcode.cn/problems/word-pattern/?envType=study-plan-v2&amp;envId=top-interview-150">单词规律</a></h3>
<p>与上一道题目是一样的，只需要将字符串按照空格切分成单词，再定义两个
Hash
映射就能解决问题。不过这里需要注意一下给定单词的长度应该和切分出来的单词列表的长度一致，不然会出现以下这种情况。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202615.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, String&gt; ltoR = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Character&gt; rtoL = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    String[] strList = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(strList.length != pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltoR.get(pattern.charAt(i))!=<span class="literal">null</span> &amp;&amp; !ltoR.get(pattern.charAt(i)).equals(strList[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rtoL.get(strList[i])!=<span class="literal">null</span> &amp;&amp; !rtoL.get(strList[i]).equals(pattern.charAt(i))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ltoR.put(pattern.charAt(i), strList[i]);</span><br><span class="line">        rtoL.put(strList[i], pattern.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有效字母的异位词">5.4 <a
href="https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效字母的异位词</a></h3>
<p>这个题目更简单，跟<a
href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&amp;envId=top-interview-150">赎金信</a>是一样的，只需要把第一个单词中每个字母出现的次数记录下来，在第二个单词遍历的时候减去对应字母的次数，最后再遍历一下记录数组，看是否全为
0，即可判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (Character ch : t.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (Character ch : s.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字母异位词分组">5.5 <a
href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&amp;envId=top-interview-150">字母异位词分组</a></h3>
<p>这道题目按照以往的做法，需要判断各个字符串出现的字母次数是否一致，才能归为一类。但实际上我们可以将字符串中的字母先进行排序，将不通字母排序的字符串变成统一，然后再用
Hash 记录对应的组别。<strong><em>主要是排序</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);     <span class="comment">// 很关键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(sorted, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(sorted, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数之和">5.6 <a
href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;envId=top-interview-150">两数之和</a></h3>
<p>可以使用双指针做，也可以用 Hash
完成。双指针的话，需要先对给定的数组进行排序，然后指针从最左边和最右边开始移动。Hash
的话会比较快，记录目标值 - 当前值，映射当前值对应的下标，等遇到 目标值 -
当前值时，返回对应 Hash 映射和对应的下标即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">        map.put(target - nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快乐数">5.7 <a
href="https://leetcode.cn/problems/happy-number/?envType=study-plan-v2&amp;envId=top-interview-150">快乐数</a></h3>
<p>打表 YYDS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isHappy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        tmp = n;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n += (tmp % <span class="number">10</span>) * (tmp % <span class="number">10</span>);</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>) &#123;</span><br><span class="line">            isHappy = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHappy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在重复元素">5.8 <a
href="https://leetcode.cn/problems/contains-duplicate/">存在重复元素</a></h3>
<p>HashSet
去重，如果不能插入，说明有重复，重复直接返回存在重复元素，返回 True</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) <span class="keyword">if</span>(!set.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在重复元素-ⅱ">5.9 <a
href="https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">存在重复元素
Ⅱ</a></h3>
<p>用 Hash
记录数的下标，遇到重复的就看与之前存入的下标符不符合要求，不符合就更新下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; i - map.get(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长连续序列">5.10 <a
href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-interview-150">最长连续序列</a></h3>
<p>排序 + 哈希。如果比当前数字小 1 的数字在 map
映射中存在的话，当前数字的长度就是比他小的数字的长度 +1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            map.put(num, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> map.put(num, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="区间">6. 区间</h2>
<h3 id="汇总区间">6.1 <a
href="https://leetcode.cn/problems/summary-ranges/?envType=study-plan-v2&amp;envId=top-interview-150">汇总区间</a></h3>
<p>双指针，记录一个能到达最右边的指针，往右走到不再连续。然后判断与原指针是否相等，相等就只新增原来的数；不相等就插入箭头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[high] + <span class="number">1</span> == nums[high + <span class="number">1</span>]) high++;</span><br><span class="line">        <span class="keyword">if</span> (high == i) res.add(String.valueOf(nums[i]));</span><br><span class="line">        <span class="keyword">else</span> res.add(String.valueOf(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + String.valueOf(nums[high]));</span><br><span class="line">        i = high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并区间">6.2 <a
href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&amp;envId=top-interview-150">合并区间</a></h3>
<p>思路跟上面的题目一样，也是遍历给定的数组，然后设定一个最右边能到达的指针下标，然后等这个指针不能再往右边走时，就把对应的区间加入到最终的结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入区间">6.3 <a
href="https://leetcode.cn/problems/insert-interval/?envType=study-plan-v2&amp;envId=top-interview-150">插入区间</a></h3>
<p>这道题目是上面那道题目的扩展，思路很简单，先把要插入的区间插入到给定的数组中，然后再执行一遍上一道题目的那个函数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="comment">// 使用ArrayList创建一个可以修改大小的列表</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intervals));</span><br><span class="line">    tmpList.add(newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将列表转换回数组，并进行排序</span></span><br><span class="line">    intervals = tmpList.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[tmpList.size()][]);</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用最少数量的箭引爆气球">6.4 <a
href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&amp;envId=top-interview-150">用最少数量的箭引爆气球</a></h3>
<p>这道题目也是边界判断延续问题，不同点是我们要尽量让区间右端点尽可能的包含更多的区间。所以我们需要按照区间右端点进行升序排序，然后看当前区间的右端点，能包含多少区间的左端点，被包含的区间直接跳过即可。这里会存在一个数的极限问题，就是一个整数减去一个负数，会爆
Integer 边界，所以在排序的时候应该使用 Integer._compare 比较函数_</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] != b[<span class="number">1</span>] ? Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]) : Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    <span class="type">long</span> <span class="variable">high</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        high = Math.max(high, points[i][<span class="number">1</span>]);</span><br><span class="line">        right = i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; high &gt;= points[right][<span class="number">0</span>]) right++;</span><br><span class="line">        res++;</span><br><span class="line">        i = right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="栈">7. 栈</h2>
<h3 id="有效括号">7.1 <a
href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效括号</a></h3>
<p>存入当前括号对应的反括号，为什么呢？因为如果式子有效的话，当前括号的反括号在当前位置后面一定会出现，当我们比对不匹配时，我们便可以得出当前串存在问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.lastElement() != ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化路径">7.2 <a
href="https://leetcode.cn/problems/simplify-path/?envType=study-plan-v2&amp;envId=top-interview-150">简化路径</a></h3>
<p>用栈存放路径名称，不存放“/”，然后对于 ..
的路径，表示的是返回上一层的路径，所以我们可以把栈顶元素弹出，相当于回到了上一层。最后再用“/”将栈中元素进行拼接即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    String[] strList = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(str) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;.&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;..&quot;</span>.equals(str)) stack.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        res.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        res.insert(<span class="number">0</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.isEmpty()) res.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小栈">7.3 <a
href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&amp;envId=top-interview-150">最小栈</a></h3>
<p>存一个普通栈和一个最小栈，当一个新的数来的时候，普通栈直接压入，最小栈则跟栈顶元素比较一下，压入更小的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; xstack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        xstack.push(val);</span><br><span class="line">        minStack.push(Math.min(val,minStack.lastElement()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆波兰表达式求值">7.4 <a
href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&amp;envId=top-interview-150">逆波兰表达式求值</a></h3>
<p>这个已经将表达式转成后缀表达式了，我们并不需要判断运算符的优先级问题。我们只需要定义一个数字栈，遇到数字入栈，遇到符号，取出栈顶的两个元素，根据运算符号进行计算，把计算结果压入栈中，最后栈顶便为最终计算结果，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;+&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;-&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;*&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">            nums.push(Integer.parseInt(token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums.pop(), num2 = nums.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token)) nums.push(num1 + num2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(token)) nums.push(num2 - num1);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(token)) nums.push(num1 * num2);</span><br><span class="line">            <span class="keyword">else</span> nums.push(num2 / num1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本计算器">7.5 <a
href="https://leetcode.cn/problems/basic-calculator/?envType=study-plan-v2&amp;envId=top-interview-150">基本计算器</a></h3>
<p>这道题目因为只有加减运算，所以可以把它同意看成是加法运算，对于减法运算，我们可以看成是加上减去的那个数的相反数。这样我们只需要定义一个存储符号的栈，遇到(压栈，遇到)弹栈，遇到加号，符号为
1，遇到减号，符号为 0 。遇到数字，加上数字与符号的乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length(), res = <span class="number">0</span>, sign = <span class="number">1</span>;   <span class="comment">// sign 为 1 表示是正数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            sign = stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(sign);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                tmp = tmp * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            res += sign * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="链表">8. 链表</h2>
<h3 id="环形链表">8.1 <a
href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&amp;envId=2cktkvj&amp;page=1">环形链表</a></h3>
<p>这是一道经典的问题，我们只需要定义一快一慢两个指针，快指针每次走两步，慢指针每次走一步。如果链表中存在环，那么快指针一定跟慢指针相遇。如果链表中不存在环，那么快指针一定会以最快的速度到达尾指针，也就是
null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head, high = head;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="literal">null</span>) &#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="keyword">if</span>(high.next!=<span class="literal">null</span> &amp;&amp; high.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                high = high.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(high == low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数相加">8.2 <a
href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">两数相加</a></h3>
<p>其实跟高精度计算是同一个思路。就是模拟数字笔算相加的过程，定义进位变量，存储最终链表头文件，在加上类似于归并排序的合并两个数组的思路，合并两个链表。最后由
add 是否大于 0，在决定是否添加新的结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> l1, n2 = l2, tmp = <span class="literal">null</span>, res = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span> ,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = (n1.val + n2.val + add);</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n1.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n2.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(add &gt; <span class="number">0</span>) tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(add);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个有序链表">8.3 <a
href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&amp;envId=top-interview-150">合并两个有序链表</a></h3>
<p>跟归并排序同一个思路，分别记录两个链表的两个指针，哪个链表的指针指向的值小，就记录哪个值，并移动对应的指针。最后，当两个链表有一方遍历完成，则只需将另一方剩余的链表加入到结果链表中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>, tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(list1) &amp;&amp; Objects.nonNull(list2)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(res)) res = tmp.next;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list1)) tmp.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list2)) tmp.next = list2;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(res)? tmp.next : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机链表的复制">8.4 <a
href="https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&amp;envId=top-interview-150">随机链表的复制</a></h3>
<p>—— 回溯 + 哈希</p>
<p>本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p>
<p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p>
<p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Node, Node&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cacheMap.containsKey(head)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        cacheMap.put(head, newHead);</span><br><span class="line">        newHead.next = copyRandomList(head.next);</span><br><span class="line">        newHead.random = copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheMap.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表">8.5 <a
href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h3>
<p>——模拟</p>
<p>我们只需要定义一前一后两个指针，然后保留后一个指针的 next
地址【newNode】，将后一个指针的 next
指向前一个指针，前一个指针再移动到后一个指针的位置，后一个指针移动到
newNode。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表-ⅱ">8.6 <a
href="https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">反转链表
Ⅱ</a></h3>
<p>——模拟</p>
<p>这道题目思路不复杂，就是根据函数参数提供的位置，把要反转的那部分链表切出来，同时记录要反转的那部分链表的前后节点（因为把反转后的链表放回原链表需要这两个节点）</p>
<p>具体实现需要注意定义虚拟头指针，因为这道题目的数据中，头指针很有可能也是要被反转的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-个一组反转链表">8.7 <a
href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&amp;envId=top-interview-150">K
个一组反转链表</a></h3>
<p>这道题目第一次看上去跟上面的题目是同个思路，基本就是上面题目加个 for
循环的变体。我们在这里只需要知道链表的长度，然后每 k
个单位长度，调用上一问的函数反转一下，然后把反转后的链表重新赋值给
head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 获得链表总长度</span></span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        head = reverseBetween(head, i+<span class="number">1</span>, i + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第-n-个结点">8.8 <a
href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除链表的倒数第
N 个结点</a></h3>
<p>——模拟</p>
<p>先计算链表总共有几个结点，然后遍历到链表的倒数第 N
个结点的前一个结点，然后将结点的 next 赋值为 next.next 就可以。</p>
<p>实现的时候需要注意一下定义虚拟头结点，因为头结点有可能就是要被删除的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    tmp = dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - n; ++i) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = tmp.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素">8.9 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h3>
<p>——模拟</p>
<p>定义前后两个指针，若后指针的下一个指针的值等于当前指针的值，则将前指针的
next 指向后指针的 next。</p>
<p>实现的时候需要定义一个虚拟头结点，因为可能要删除的结点函数传入的
head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(head)) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head, pre = dummyNode;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(curr.next))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素-ⅱ">8.10 <a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?envType=study-plan-v2&amp;envId=top-interview-150">删除排序链表中的重复元素
Ⅱ</a></h3>
<p>这道题目跟上一道题目不太一样，这道题目是不保留如果存在重复的数值，所以我们要先让当前指针
cur 先跨越所有重复值的值，然后再更新前指针 prev 的 next
的值。需要注意的是，如果存在重复的情况的话，不要移动 prev
指针的位置，因为重复后的数字很肯定再次出现重复的情况，所以我们等真的没有重复再移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur) &amp;&amp; Objects.nonNull(cur.next)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(cur.next) &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev = cur; </span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转链表">8.11 <a
href="https://leetcode.cn/problems/rotate-list/?envType=study-plan-v2&amp;envId=top-interview-150">旋转链表</a></h3>
<p>这道题目考察的是一个链表移动的问题，首先进行链表旋转的本质是给链表新的起始点。我们可以先走到链表尾，同时记录下链表的长度，因为旋转如果是链表的倍数的话，其实可以不用旋转，所以我们应该拿旋转次数
k 对链表长度 len 取余。然后走到链表尾的指针需要再往前走 k = len - k%len
步，直到下一次起点的前一个指针，我们记录下当前起点的下一个指针，将当前起点的
next 赋值为
null，表示链表结尾，然后再将刚刚记录的值返回函数，即可实现效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head) || Objects.isNull(head.next) || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp.next)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = head;</span><br><span class="line">    k = len - k % len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) tmp = tmp.next;</span><br><span class="line">    head = tmp.next;</span><br><span class="line">    tmp.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分隔链表">8.12 <a
href="https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&amp;envId=top-interview-150">分隔链表</a></h3>
<p>有点分治思想，但也不是分治，就是一个模拟。思路是这样的，新开两条新链，采用尾插的方式往链表中添加元素。对于小于指定值的节点，我们添加到链表一；对于大于等于指定值，我们添加到链表二。我们需要注意的是记录两条链表的起始位置，等遍历结束时，我们可以进行拼接。最后在返回时还需要注意，可能全部节点都加到了链表二中，所以我们不能直接返回链表一，只有当链表一不为空时，才返回链表一，否则应该返回链表二。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l1Head = <span class="literal">null</span>, l2Head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">            l1.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l1Head)) l1Head = l1.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l2Head)) l2Head = l2.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1.next = l2Head;</span><br><span class="line">    l2.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(l1Head)? l2Head : l1Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lru-缓存">8.13 <a
href="https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&amp;envId=top-interview-150">LRU
缓存</a></h3>
<p>双向链表 + Hash</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/8200f0da-2159-41f1-9fe7-5eb367030884.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉树">9. 二叉树</h2>
<h3 id="二叉树的最大深度">9.1 <a
href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的最大深度</a></h3>
<p>递归，土到极致就是潮。求最大深度，当前节点不存在，则为递归出口，直接返回
0。当前节点存在，则返回当前节点左右子树中比较深的那个数，同时，考虑到当前节点也为一层，所以需要在求出左右子树比较深的那个数值后面
+ 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Math._max_(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相同的树">9.2 <a
href="https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&amp;envId=top-interview-150">相同的树</a></h3>
<p>——递归</p>
<p>比较两棵树，可以看作是比较当前的两个节点的递归实现，我们只需要把比较当前两个节点的逻辑处理通顺，比较两棵树就是递归的活。我们对于当前两个节点，两个节点都为
null，则返回 true。如果只有一方为空，则返回
false；如果都不为空，则比较节点的值，如果值不同，则返回
false；值相同，则需满足他们各自的左右子树都应该相同才能返回
true，此时就用上了递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p) &amp;&amp; Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.val == q.val) <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转二叉树">9.3 <a
href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">翻转二叉树</a></h3>
<p>——后递归原理</p>
<p>先翻转左右子树，再反转左右节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称二叉树">9.4 <a
href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&amp;envId=top-interview-150">对称二叉树</a></h3>
<p>——递归</p>
<p>单个节点作为函数参数很难解决这道题目，我们直接使用<strong>重载</strong>的方式，将使用传入两个参数的形式，按照上面题目的方法，进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode a, TreeNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a) &amp;&amp; Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.val == b.val) <span class="keyword">return</span> isSymmetric(a.left, b.right) &amp;&amp; isSymmetric(a.right, b.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从前序与中序遍历序列构造二叉树">9.5 <a
href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150">从前序与中序遍历序列构造二叉树</a></h3>
<p>由前序和中序构造二叉树有个特点，就是因为前序是最开始访问根节点的，所以前序遍历数组的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历，这样讲有点抽象，我们画个图会清晰点。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202727.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= preorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从中序与后序遍历序列构造二叉树">9.6 <a
href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">从中序与后序遍历序列构造二叉树</a></h3>
<p>由后序和中序构造二叉树有个特点，就是因为后序从右往左第一个是最开始访问根节点的，所以后序遍历数组从右往左的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历。需要注意的是，由后序遍历进行构造的数组，我们需要先构造右子树，再构造左子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        root.left = buildTree(postorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">        root.left = buildTree(postorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="填充每个节点的下一个右侧节点指针-ⅱ">9.7 <a
href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/?envType=study-plan-v2&amp;envId=top-interview-150">填充每个节点的下一个右侧节点指针
Ⅱ</a></h3>
<p>——层序遍历</p>
<p>考察的是二叉树的层序遍历。要使得每一行的二叉树节点的 next
指针都指向它的右边，我们需要对每一层单独做处理。我们通过队列 +
数组来完成。具体实现是先将根节点加入到队列中，然后我们以队列是否为空进行循环，每一次循环都遍历队列中所有元素，因为队列每一次循环弹出的是当前层的节点，每一次插入的是我们下一层的节点。对于当前层的节点，我们需要用一个数组将这些点记录下来，等我们把这一层的节点
next
指针连接完成，即遍历完这一层的节点后，我们再将这一层的孩子节点加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        temp.add(cur);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            cur.next = queue.poll();</span><br><span class="line">            temp.add(cur.next);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node node : temp) <span class="keyword">if</span>(Objects.nonNull(node))&#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.left))&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.right))&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树展开为链表">9.8 <a
href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树展开为链表</a></h3>
<p>第一次看到这道题目想用前序遍历做，但是前序遍历的空间复杂度比较高，就想着能不能边翻遍历边翻转。用递归实在想不出来，看了一下别人题解使用的遍历。大概思路我画个图讲一下。思路主要是下面这样
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202752.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(root)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(root.left))&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(pre.right)) pre = pre.right;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 考虑下一个节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="路径总和">9.9 <a
href="https://leetcode.cn/problems/path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">路径总和</a></h3>
<p>——递归</p>
<p>如果当前节点为空，则无论 targetSum 等不等于 0，都返回
false。如果当前节点左右子树都为空，则说明当前节点为叶子节点，则直接返回当前节点值是否等于
target。若当前节点值不满足，则看看当前节点的左右子树是否满足。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right) ) <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求根节点到叶节点数字之和">9.10 <a
href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">求根节点到叶节点数字之和</a></h3>
<p>——递归</p>
<p>先记录一个临时变量 tmp = 上一个节点的值 num * 10 + 当前节点的值
val，如果当前节点为叶子节点，则直接返回临时变量
tmp，即已经到叶子，不用再拼接数字了。若不是叶子节点，则当前节点的左右子树递归结果相加，可作为最终的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getResult(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right)) <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="keyword">return</span> getResult(root.left, temp) + getResult(root.right, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的直径">9.11 <a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a></h3>
<p>根据题目示例，我们可以知道一条路径的长度等于该路径上的节点数 -
1，所以我们的问题转换成了求路径经过的节点数最大值 - 1。</p>
<p>而路径经过的节点数最大值怎么求呢？递归的主要思路是这样的</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">当前节点所在的路径经过的节点数的最大值 = 当前节点左孩子的最大深度 + 当前节点右孩子的最大深度 + 1</span><br><span class="line">当前节点的最大深度 = max(当前节点左孩子的最大深度, 当前节点右孩子的最大深度)</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    maxNum = <span class="number">1</span>;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> maxNum - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    maxNum = Math.max(maxNum, L + R + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的最大路径和">9.12 <a
href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树中的最大路径和</a></h3>
<p>这道题目跟 <a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
这道题目很像，但是 <a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
这道题目是要算节点的个数的最大值，而这道题目是算节点的值的总和最大。所以在代码实现上还是有一点区别。
<a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
的当前节点的最大值是左右子树的最大深度之和 +
1。这道题目当前节点的最大值，则需要考虑左右子树的最大值是不是为负数，负数的话其实会阻碍当前节点求最大值，我们不应该考虑在内。所以这道题目相比于
<a
href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
，我们需要判断当前节点的左右子树的最大值是否大于 0
，只有左右子树的最大值 &gt;0 时，我们才把它们加入到当前节点的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    res = Integer.MIN_VALUE;</span><br><span class="line">    depthPathSum(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depthPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> Math.max(depthPathSum(root.left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.max(depthPathSum(root.right), <span class="number">0</span>);</span><br><span class="line">    res = Math.max(res, root.val + L + R);</span><br><span class="line">    <span class="keyword">return</span> Math.max(L, R) + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的中序遍历">9.13 <a
href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h3>
<p>按照中序遍历的规则，先遍历左子树，再遍历当前节点，再遍历右子树。由于需要记录节点，所以需要定义一个列表变量，按照顺序记录对应的节点返回即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    res.addAll(inorderTraversal(root.left));</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    res.addAll(inorderTraversal(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树迭代">9.14 <a
href="https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树迭代</a></h3>
<p>——递归</p>
<p>题目讲的有点抽象，不过样例比较清晰，直接看样例可以知道其实就是一个中序遍历的结果输出。我们最简单的做法就是拿一个列表存入中序遍历的结果，然后拿一个下标，随着
next()函数的调用，去访问列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; record;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        record = inorderTraversal(root);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> record.get(idx++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; record.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> res;</span><br><span class="line">        res.addAll(Objects._requireNonNull_(inorderTraversal(root.left)));</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        res.addAll(Objects._requireNonNull_(inorderTraversal(root.right)));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——迭代 其实还有迭代的版本，迭代就是用栈去存储节点，然后随着 next
函数的调用，实现一个将当前节点与对应的左子树入栈，入栈完成后，将栈顶元素弹出，并返回栈顶元素的值，同时返回栈顶节点的值。对于是否还有下一个节点的判定，需要同时存在栈为空且
cur 指针指向
null，才会出现没有下一个节点的情况(下图最有一个图)。讲起来比较抽象，画个图解释一下
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202818.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> TreeNode cur;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.nonNull(cur) || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完全二叉树的节点数">9.15 <a
href="https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&amp;envId=top-interview-150">完全二叉树的节点数</a></h3>
<p>——递归</p>
<p>具体的做法是返回左右子树的节点个数，由于当前节点也算一个节点，所以还需要
+ 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最近公共祖先">9.16 <a
href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的最近公共祖先</a></h3>
<p>最开始看到这道题目，想用并查集来做，也就是并查集压缩路径的方法，将所有节点指向同一个父节点，但是仔细一想，最后可能都指向了根节点，不可行。再仔细一想，感觉就是二叉树的<strong>后序遍历</strong>。左子树遍历一下，看一下左子树有没有节点与
p 或者 q 一样的，再右子树遍历一下，看看右子树有没有节点与 p 或 q
一样的；</p>
<ul>
<li>如果右子树与 p 或 q 节点相等的节点都不存在，说明什么？说明 p、q
两个节点都在左子树，直接返回左子树递归结果。</li>
<li>如果左子树与 p 或 q 节点相等的节点都不存在，说明什么？说明 p、q
两个节点都在右子树，直接返回右子树递归结果。</li>
<li>递归出口是什么，递归出口就是当前节点的值为 null 或者 = p 或者 =
q，直接返回当前节点。</li>
<li>最后实在找不到，直接返回根节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root) || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(right)) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(left)) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉树层次遍历">10. 二叉树层次遍历</h2>
<h3 id="二叉树的右视图">10.1 <a
href="https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的右视图</a></h3>
<p>——层序遍历</p>
<p>层序遍历，取每一层的最右边的节点，加入到返回的数组中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">            <span class="keyword">if</span> (i == len - <span class="number">1</span>) res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层平均值">10.2 <a
href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的层平均值</a></h3>
<p>——层序遍历</p>
<p>对于每一层，求出每一层的节点数和节点值的总和，然后每一层记录下这一层的平均值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> queue.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            sum += cur.val;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(cur.left)) queue.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(cur.right)) queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(sum * <span class="number">1.0</span> / len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层序遍历">10.3 <a
href="https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的层序遍历</a></h3>
<p>——层序遍历模板题，写模板，每一层用一个列表存储即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的锯齿形层次遍历">10.4 <a
href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的锯齿形层次遍历</a></h3>
<p>——层次遍历</p>
<p>跟上一题几乎一样的模板，只是多加了一个判断。当在遍历的层数为奇数层（根节点算第
0 层）时，我们需要翻转存储该层数的列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.reverse(level);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉搜索树">11. 二叉搜索树</h2>
<h3 id="二叉搜索树的最小绝对差">11.1 <a
href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树的最小绝对差</a></h3>
<p>首先，我们如何获取到一棵二叉搜索树的所有节点数值，并且按照升序排序？答案是中序遍历。对于这道题目，一棵二叉树中序遍历出来的结果，min(arr[i]
- arr[i+1])
的结果就是答案。怎么写代码呢？很明显这个公式是两个值，所以我们需要额外的一个变量
pre
记录前一个节点的值。然后呢？按照中序遍历的顺序，先遍历左子树；然后处理当前节点，取当前节点与上一个节点的值的差值；最后遍历右子树。
其实每一道题目讲起来都是抽象的，我画个图解释一下吧。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202900.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    pre = -<span class="number">1</span>;</span><br><span class="line">    res = Integer.MAX_VALUE;</span><br><span class="line">    inorderPrint(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span>;</span><br><span class="line">    inorderPrint(root.left);</span><br><span class="line">    <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = Math.min(res, root.val - pre); <span class="comment">// 这里只需要用当前数 - 前一个数； 因为中序遍历的结果就是递增的，所以相减一定是正数</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderPrint(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="验证二叉搜索树">11.2 <a
href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">验证二叉搜索树</a></h3>
<p>跟上一道题目一样的模板。上一道题目是记录前后两个值的差的最小值，这道题目是判断上一个值是否大于等于当前值，如果是，说明不是二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long._MIN_VALUE_;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    inorderPrint(root);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span>;</span><br><span class="line">    inorderPrint(root.left);</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre == Long._MIN_VALUE_) &#123;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= root.val) flag = <span class="literal">false</span>;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderPrint(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树中第-k-小的元素">11.3 <a
href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树中第
k 小的元素</a></h3>
<p>——中序遍历</p>
<p>其实就是取二叉搜索树中序遍历的结果列表中的第 k 个小标的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        inorderPrint(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span>;</span><br><span class="line">        inorderPrint(root.left);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) res = root.val;</span><br><span class="line">        inorderPrint(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="图">12. 图</h2>
<h3 id="岛屿的最大面积">12.1 <a
href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) res = Math.max(res, getAreaOfIsland(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getAreaOfIsland(grid, r + <span class="number">1</span>, c) + getAreaOfIsland(grid, r - <span class="number">1</span>, c) + getAreaOfIsland(grid, r, c - <span class="number">1</span>) + getAreaOfIsland(grid, r, c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿数量">12.2 <a
href="https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&amp;envId=top-interview-150">岛屿数量</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                traverseArea(grid, i, j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGrid(grid, r, c)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    traverseArea(grid,r,c+<span class="number">1</span>);</span><br><span class="line">    traverseArea(grid,r,c-<span class="number">1</span>);</span><br><span class="line">    traverseArea(grid,r-<span class="number">1</span>,c);</span><br><span class="line">    traverseArea(grid,r+<span class="number">1</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿的周长">12.3 <a
href="https://leetcode.cn/problems/island-perimeter/description/">岛屿的周长</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> traverseArea(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverseArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGrid(grid, r, c)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseArea(grid, r, c + <span class="number">1</span>) + traverseArea(grid, r, c - <span class="number">1</span>) + traverseArea(grid, r + <span class="number">1</span>, c) + traverseArea(grid, r - <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="所有可能的路径">12.4 <a
href="https://leetcode.cn/problems/all-paths-from-source-to-target/">所有可能的路径</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line">    Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">    stack.offerLast(<span class="number">0</span>);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dfs(graph, <span class="number">0</span>, graph.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> idx, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> target : graph[idx]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[target]) <span class="keyword">continue</span>;</span><br><span class="line">        stack.offerLast(target);</span><br><span class="line">        vis[target] = <span class="literal">true</span>;</span><br><span class="line">        dfs(graph, target, n);</span><br><span class="line">        stack.removeLast();</span><br><span class="line">        vis[target] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被围绕的区域">12.5 <a
href="https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&amp;envId=top-interview-150">被围绕的区域</a></h3>
<p>从边缘开始搜起，把边缘的‘O’先打上标记，然后再遍历一下数组，没有打上标记的‘O’则是我们需要进行替换的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(board) || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">edge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == n - <span class="number">1</span> || j == m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克隆图">12.6 <a
href="https://leetcode.cn/problems/clone-graph/description/?envType=study-plan-v2&amp;envId=top-interview-150">克隆图</a></h3>
<p>——DFS</p>
<p>还是用 DFS 进行爆搜。递归两个要点，一个是出口，一个是递归语句。</p>
<p>（1）出口：</p>
<ul>
<li>第一个出口：根据题目所给用例，我们可以很快找到一个递归出口，那就是当传入的结点为
null 时，返回 null。</li>
<li>第二个出口：我们会发现题目所给用例中是一个无向图，会有环的存在，如果这个不加以限制就会无线递归下去，无限创建节点。那怎么办呢？可以用一个
map 去接我们创建出来的节点，把节点值作为 key，节点本身作为
value。每一次创建节点前，都先看看之前是否已经创建过该节点，创建过了就不需要再创建了。</li>
</ul>
<p>（2）递归语句。我们需要明确的是，对于当前节点的邻居，我们应该在进入递归时加入还是递归返回时加入。答案很明显，需要在递归返回时加入。为什么因为对于当前节点的邻居，它们也有自己的邻居，先将当前节点的邻居用递归的方式创建，把它们的邻居也克隆好后，再将它们加入到当前节点的邻居位置。这个问题涉及递归前执行和递归后执行的问题，读者可以参考一下二叉树的前中后序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(node)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(node.val)) <span class="keyword">return</span> map.get(node.val);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">    map.put(node.val, newNode);</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">        newNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除法求值">12.7 <a
href="https://leetcode.cn/problems/evaluate-division/description/?envType=study-plan-v2&amp;envId=top-interview-150">除法求值</a></h3>
<p>两种做法：1. DFS； 2. 并查集</p>
<p>——DFS</p>
<p>这是我看到这道题目第一时间想到的做法。对于这道题目，第一时间想到的是建图，然后遍历给定的
queries，用 DFS 爆搜图。这种做法我们需要明确几个点：1.
图结构用什么存储？ 2. 怎么将数据存入图中 3. 递归出口是什么？4.
递归执行逻辑是什么？</p>
<p>接下来我们一一回答这个问题。</p>
<ol type="1">
<li>首先是图结构用什么存储，回答是 Map 或者结构体。我的代码用的是
Map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>怎么把数据存入图。</li>
</ol>
<p>我们先对题目所给的变量对以下定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">被除数 --&gt;   num1</span><br><span class="line">除数   --&gt;   num2</span><br></pre></td></tr></table></figure>
<p>回答是 被除数 num1 作为 key，除数 num2 和对应两个数的商构建 map 作为
value。然后需要再存入两个数位置相反的关系，也就是第二个数 num2
作为被除数，第一个数 num1 作为除数，对应值则为 1.0 /
value。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----&gt; Map&lt;num1, Map&lt;num2, value&gt;</span><br><span class="line">num1</span><br><span class="line">|</span><br><span class="line">---&gt; (num2,value)</span><br><span class="line"></span><br><span class="line">-----&gt; Map&lt;num2, Map&lt;num1, value&gt;</span><br><span class="line">num2</span><br><span class="line">|</span><br><span class="line">---&gt; (num1,<span class="number">1.0</span> / value)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>递归出口是什么？</li>
</ol>
<p>（1）当图中不存在查询数对的两个值时，需要返回 -1.0</p>
<p>（2）当图中存在查询数对，并且数对的两个值相等时，需要返回 1.0；因为
a/a = 1.0</p>
<p>（3）当图中存在查询数对，并且符合图结构，也就是 num1 下的 map 中含有
num2，则直接返回对应的数值</p>
<ol type="1">
<li>递归逻辑</li>
</ol>
<p>先找当前 num1 下的 map 的 key，如果能找到对应 num2，则直接返回对应的
value；若找不到，则递归 num1 下的 map 的 key，然后将当前 num1 下的 map
的 value 与 key 的递归结果相乘返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    <span class="type">double</span>[] res = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line">    <span class="comment">// 建图</span></span><br><span class="line">    createGraph(equations, values);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">        List&lt;String&gt; query = queries.get(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> query.get(<span class="number">0</span>), num2 = query.get(<span class="number">1</span>);</span><br><span class="line">        res[i] = dfs(num1, num2, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>), num2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">        graph.computeIfAbsent(num1, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()).put(num2, values[i]);</span><br><span class="line">        graph.computeIfAbsent(num2, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()).put(num1, <span class="number">1.0</span> / values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">dfs</span><span class="params">(String num1, String num2, Set&lt;String&gt; path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(num1) || !graph.containsKey(num2)) <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(num1, num2)) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    Map&lt;String, Double&gt; doubleMap = graph.get(num1);</span><br><span class="line">    <span class="keyword">if</span> (doubleMap.containsKey(num2)) <span class="keyword">return</span> doubleMap.get(num2);</span><br><span class="line">    path.add(num1);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; child : doubleMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.contains(child.getKey())) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> child.getValue();</span><br><span class="line">        <span class="type">double</span> <span class="variable">childValue</span> <span class="operator">=</span> dfs(child.getKey(), num2, path);</span><br><span class="line">        <span class="keyword">if</span>(childValue != -<span class="number">1.0</span>) <span class="keyword">return</span> tmp * childValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/?envType=study-plan-v2&amp;envId=top-interview-150">——并查集</a></p>
<p>这里贴一下官方题解吧，写的挺好的。官方题解采用路径压缩，会比 DFS
快一些。</p>
<h3 id="课程表">12.8 <a
href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-interview-150">课程表</a></h3>
<p>就是判断图中有没有环。</p>
<ol type="1">
<li>像什么？像拓扑排序。</li>
<li>怎么做？记录节点入度，用队列存储入度为 0 的节点。</li>
<li>出口在哪？如果图中没有环，则图中每个节点都会进入队列一次；如果图中有环，则环上的节点是不会进入队列的。</li>
<li>只有数组记录节点之间的关系怎么办？建图。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(prerequisites) || prerequisites.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] inSpend = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Arrays.fill(inSpend, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        inSpend[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        graph.computeIfAbsent(prerequisite[<span class="number">1</span>], k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) <span class="keyword">if</span> (inSpend[i] == <span class="number">0</span>) queue.addLast(i);</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(graph.get(it))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer target : graph.get(it)) &#123;</span><br><span class="line">            inSpend[target]--;</span><br><span class="line">            <span class="keyword">if</span> (inSpend[target] == <span class="number">0</span>) queue.addLast(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课程表-ⅱ">12.9 <a
href="https://leetcode.cn/problems/course-schedule-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">课程表
Ⅱ</a></h3>
<p>上一道题目的变体，存入拓扑图序列就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] inSpend = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Arrays.fill(inSpend, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        inSpend[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        graph.computeIfAbsent(prerequisite[<span class="number">1</span>], k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) <span class="keyword">if</span> (inSpend[i] == <span class="number">0</span>) queue.addLast(i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">        numCourses--;   res[idx++] = it;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(graph.get(it))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer target : graph.get(it)) &#123;</span><br><span class="line">            inSpend[target]--;</span><br><span class="line">            <span class="keyword">if</span> (inSpend[target] == <span class="number">0</span>) queue.addLast(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>? res: <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="图的广度优先搜索">13. 图的广度优先搜索</h2>
<h3 id="蛇梯棋">13.1 <a
href="https://leetcode.cn/problems/snakes-and-ladders/description/?envType=study-plan-v2&amp;envId=top-interview-150">蛇梯棋</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] p = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nxt</span> <span class="operator">=</span> p[<span class="number">0</span>] + i;</span><br><span class="line">            <span class="keyword">if</span> (nxt &gt; n * n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span>[] rc = id2rc(nxt, n);</span><br><span class="line">            <span class="keyword">if</span> (board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nxt = board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt == n * n) &#123;</span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[nxt]) &#123;</span><br><span class="line">                vis[nxt] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nxt, p[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> id, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (id - <span class="number">1</span>) / n, c = (id - <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        c = n - <span class="number">1</span> - c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n-<span class="number">1</span>-r, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小基因变化">13.2 <a
href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">最小基因变化</a></h3>
<p>有点像二叉树的层序遍历。哦不，BFS
就是多叉树的层序遍历版本。那么我们换种思想，把这道题目想象成多叉树，然后像二叉树的层序遍历那样，遍历这颗多叉树可以吗。答案是可以。继续往下看，我们需要解决以下几个问题。
1. 这颗多叉树是几叉？ 2. 题目要求的结果是遍历的什么结果？ 3.
层序遍历的队列应该存什么？</p>
<ol type="1">
<li>这颗多叉树是几叉？ 回答是 8*3 = 24。为什么？因为每一个基因序列都有 8
个字母，在一次变换中，每一个字母都有 3
种其他变化，所以，对于每一次变化，我们都需要考虑 24 种可能。</li>
<li>要求的结果是遍历的什么结果？
回答是树的深度，树的每一层代表每一次递进的变换，所以，当真的遇到最终序列时，树有几层，就应该对应几次变换。</li>
<li>层序遍历的队列应该存什么？
回答是，存基因库中的基因序列。显然，对于我们上述的 24
种变化，真正有效的变化只会出现在基因库中，所以，队列里面存的一定是基因库中的序列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">    <span class="type">char</span>[] keys = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (startGene.equals(endGene)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt.contains(endGene)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offer(startGene);</span><br><span class="line">    vis.add(startGene);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.charAt(i) != keys[j]) &#123;</span><br><span class="line">                        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(cur);</span><br><span class="line">                        sb.setCharAt(i, keys[j]);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                        <span class="keyword">if</span> (cnt.contains(target) &amp;&amp; !vis.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endGene.equals(target)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> step;</span><br><span class="line">                            &#125;</span><br><span class="line">                            queue.offer(target);</span><br><span class="line">                            vis.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词接龙">13.3 <a
href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词接龙</a></h3>
<p>跟上一道题目思路一模一样。把写死的长度换成可变长度就行。另外，题目的接龙中，第一个单词和最后一个单词也算进序列长度里面，所以我们需要给答案再加一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] keys = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>.toCharArray();</span><br><span class="line">    Set&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">    Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(!cnt.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    vis.add(beginWord);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; beginWord.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; keys.length; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.charAt(i) != keys[j]) &#123;</span><br><span class="line">                        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(cur);</span><br><span class="line">                        sb.setCharAt(i, keys[j]);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">nxt</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                        <span class="keyword">if</span> (cnt.contains(nxt) &amp;&amp; !vis.contains(nxt)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endWord.equals(nxt)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            queue.offer(nxt);</span><br><span class="line">                            vis.add(nxt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="字典树">14. 字典树</h2>
<h3 id="实现-trie前缀树">14.1 <a
href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">实现
Trie（前缀树）</a></h3>
<p>前缀树，也称字典树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加与搜索单词---数据结构设计">14.2 <a
href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&amp;envId=top-interview-150">添加与搜索单词
- 数据结构设计</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        maxLen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        maxLen = Math.max(maxLen, word.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.subNodes.containsKey(c)) &#123;</span><br><span class="line">                node = node.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                node = node.subNodes.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(word,<span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word, <span class="type">int</span> index, Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(node.subNodes.containsKey(c)) &#123;</span><br><span class="line">            node = node.subNodes.get(c);</span><br><span class="line">            <span class="keyword">if</span>(search(word, index+<span class="number">1</span>, node)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Node&gt; characterNodeEntry : node.subNodes.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(search(word, index+<span class="number">1</span>, characterNodeEntry.getValue())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索-ⅱ">14.3 <a
href="https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索
Ⅱ</a></h3>
<p>一顿操作猛如虎，交上超时二百五。破防了</p>
<p>——
最有一个样例没过版本。这个版本是先造出单词，然后再通过前缀树查找是否在前缀树中。很慢。下面的版本的是参考了官方题解的。直接把前缀树的查找过程顺着原来地图的
dfs 进行，很快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        Node root;</span><br><span class="line"></span><br><span class="line">        Trie() &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">                path.append(board[i][j]);</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(i, j, board, trie, visited);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j,<span class="type">char</span>[][] board, Trie trie, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length() &gt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (trie.search(path.toString())) &#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[<span class="number">0</span>], col = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isGrap(row, col, board) &amp;&amp; !visited[row][col]) &#123;</span><br><span class="line">                path.append(board[row][col]);</span><br><span class="line">                visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">                dfs(row, col, board, trie, visited);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">                visited[row][col] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——题解版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, Trie&gt; subNodes;</span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line">        Trie() &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    node = node.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">                    node = node.subNodes.get(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node.isEnd = <span class="literal">true</span>;</span><br><span class="line">            node.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(i, j, board, trie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, Trie trie)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!trie.subNodes.containsKey(board[i][j])) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        trie = trie.subNodes.get(c);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(trie.word)) &#123;</span><br><span class="line">            res.add(trie.word);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + direction[<span class="number">0</span>], y = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isGrap(x, y, board) &amp;&amp; board[x][y] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                dfs(x, y, board, trie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="回溯">15. 回溯</h2>
<h3 id="电话号码的字母组合">15.1 <a
href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">电话号码的字母组合</a></h3>
<p>——DFS</p>
<p>先打表，记录数字和字母组合的映射，然后再遍历数字序列 DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    put(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">    put(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">    put(<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    put(<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">    put(<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">    put(<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">    put(<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(digits) || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dfs(<span class="number">0</span>, digits);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == digits.length()) &#123;</span><br><span class="line">        res.add(path.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">combines</span> <span class="operator">=</span> map.get(digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : combines.toCharArray()) &#123;</span><br><span class="line">        path.append(c);</span><br><span class="line">        dfs(i + <span class="number">1</span>, digits);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合">15.2 <a
href="https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&amp;envId=top-interview-150">组合</a></h3>
<p>——DFS</p>
<p>DFS 模板题，但是这道题目需要注意的是，对于这个
List&lt;List<Integer>&gt; 变量类型，要将 List<Integer>
加进这个变量时，要 new 一下！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        dfs(i + <span class="number">1</span>, n, k);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全排列">15.3 <a
href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-interview-150">全排列</a></h3>
<p>组合跟全排列是不一样的。按最浅显的理解，可以认为全排列能回头，但是得标记是否已访问；组合不能回头，只能往前走。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    n = nums.length;</span><br><span class="line">    vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    dfs(<span class="number">0</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(start + <span class="number">1</span>, nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合总和">15.4 <a
href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">组合总和</a></h3>
<p>能重复，但是不能回头，那就把当前位置继续传入即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>, candidates, target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> num, <span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        dfs(i, num + candidates[i], candidates, target);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n-皇后-ⅱ">15.5 <a
href="https://leetcode.cn/problems/n-queens-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">N
皇后 Ⅱ</a></h3>
<p>——DFS</p>
<p>怎么理解呢？N 皇后是一个在边长为 n 的方阵上的问题，我们用 DFS
的时候一般都是把题目看成是树的解决方案来进行。【以后有时间一定开个 DFS
专题讲讲】。落实到这道题目，我们需要明确几个点，1. 树的深度是什么？ 2.
树的每个节点有几个孩子节点 3. 出口是什么？</p>
<ol type="1">
<li>树的深度？</li>
</ol>
<p>n。这道题目树的深度是矩阵的行，有几行就多深</p>
<ol type="1">
<li>树的每个节点有几个孩子节点？</li>
</ol>
<p>n。 有多少列，就有几个孩子节点。</p>
<ol type="1">
<li>出口是什么？</li>
</ol>
<p>到叶子节点</p>
<p>最后我们需要怎么满足彼此不攻击？
其实对于每一个位置的横竖撇捺方向，都可以转换成一个数组进行标记是否可行。怎么说呢？</p>
<ul>
<li>横——不用数组，因为我们 DFS
就是一行一行去试探，所以一定能保证行不会冲突。</li>
<li>竖——col 数组</li>
<li>撇——ueg 数组 当前位置[i,j]的撇怎么标记 ueg[i+j]</li>
<li>捺——eg 数组 当前位置[i,j]的撇怎么标记 eg[j-i+n]</li>
</ul>
<p>上图 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203004.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] col, eg, ueg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    eg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    ueg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    dfs(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="number">0</span> &amp;&amp; eg[i + u] == <span class="number">0</span> &amp;&amp; ueg[i - u + n] == <span class="number">0</span>) &#123;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>, n);</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八皇后">15.6 <a
href="https://leetcode.cn/problems/eight-queens-lcci/description/">八皇后</a></h3>
<p>与上面的题目一模一样，不过这道题需要先初始化一下地图，然后边 DFS
边改地图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] col, eg, ueg;</span><br><span class="line"><span class="type">char</span>[][] board;</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    eg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    ueg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, n, board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        List&lt;String&gt; rowStr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rowStr.add(String.valueOf(board[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(rowStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="number">0</span> &amp;&amp; eg[u + i] == <span class="number">0</span> &amp;&amp; ueg[i - u + n] == <span class="number">0</span> &amp;&amp; board[u][i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">            board[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>, n, board);</span><br><span class="line">            board[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索">15.7 <a
href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索</a></h3>
<p>——DFS</p>
<p>只有跟单词一样开头的字母才开始爆搜，只要长度超过目标单词就退出，不然就字母四周继续搜。需要标记是否已经遍历过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                path.append(board[i][j]);</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">                board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, board, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = tmp;</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (word.contentEquals(path)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (path.length() &gt; word.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + direction[<span class="number">0</span>], newY = y + direction[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isGrap(newX, newY, board) &amp;&amp; board[newX][newY] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            path.append(board[newX][newY]);</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[newX][newY];</span><br><span class="line">            board[newX][newY] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(newX, newY, board, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            board[newX][newY] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号生成">15.8 <a
href="https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&amp;envId=top-interview-150">括号生成</a></h3>
<p>对于每一次添加，左括号剩余的个数一定要大于或等于右括号的个数，这样可以保证不会出现类似
<code>())</code>
这种情况存在。我们初始化左右括号个数为最大，每次加，都减掉对应的个数，当左右括号剩余个数都为
0 时，加入最终的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) res.add(str);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">0</span>) dfs(str + <span class="string">&quot;(&quot;</span>, l - <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>) dfs(str + <span class="string">&quot;)&quot;</span>, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="分治">16. 分治</h2>
<h3 id="将有序数组转换为二叉搜索树">16.1 <a
href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">将有序数组转换为二叉搜索树</a></h3>
<p>有序数组取出中间值，左边数组构建左子树，右边数组构建右子树。前序遍历版建树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> creatTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">creatTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">    root.left = creatTree(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = creatTree(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序链表">16.2 <a
href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">排序链表</a></h3>
<p>——迭代版归并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead, curr = dummyHead.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> curr.next;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> merge(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead, temp1 = head1, temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">null</span> &amp;&amp; temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">                temp.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建立四叉树">16.3 <a
href="https://leetcode.cn/problems/construct-quad-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">建立四叉树</a></h3>
<p>先建树根，然后用递归填树的四个孩子，每次递归，都把矩阵用下标分割成对应的子矩阵。那递归出口是什么呢？是当左上角和右下角重合时，也就是当前矩阵只有一个数时，或者当矩阵中的树一样时，我们需要建立树的叶子节点返回。分割矩阵的下标填写可以参考下面的图
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203044.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> createTree(grid,<span class="number">0</span>,<span class="number">0</span>,n-<span class="number">1</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2 || isSameNumber(grid,x1,y1,x2,y2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(grid[x1][y1] == <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midX</span> <span class="operator">=</span> x1 + x2 &gt;&gt; <span class="number">1</span>, midY = y1 + y2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        root.topLeft = createTree(grid, x1, y1, midX, midY);</span><br><span class="line">        root.topRight = createTree(grid, x1, midY + <span class="number">1</span>, midX, y2);</span><br><span class="line">        root.bottomLeft = createTree(grid, midX + <span class="number">1</span>, y1, x2, midY);</span><br><span class="line">        root.bottomRight = createTree(grid, midX + <span class="number">1</span>, midY + <span class="number">1</span>, x2, y2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameNumber</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> grid[x1][y1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x1; i &lt;= x2; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> y1; j &lt;= y2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 16.4 <a
href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-interview-150">合并
K 个升序链表</a></p>
<p>——暴力版本</p>
<p>实践证明，暴力真的能过这道题目。只需要每一次都遍历一遍链表数组，把最小的那一个值取出来，插入到结果链表中即可。这也是我自己第一时间想到和写出来的结果。
还是看看下面用类似于归并排序的分治版本吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(lists) || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, maxNum = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(lists[i]) &amp;&amp; lists[i].val &lt; maxNum) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                maxNum = lists[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxNum == Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line">        cur.next = lists[idx];</span><br><span class="line">        lists[idx] = lists[idx].next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—— 分治版本</p>
<p>对于分治，给 up 的题感都跟 树的遍历或者归并排序的思路基本一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(l1) || Objects._isNull_(l2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects._isNull_(l1) ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy, l1Head = l1, l2Head = l2;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l1Head) &amp;&amp; Objects._nonNull_(l2Head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1Head.val &lt; l2Head.val) &#123;</span><br><span class="line">            cur.next = l1Head;</span><br><span class="line">            l1Head = l1Head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2Head;</span><br><span class="line">            l2Head = l2Head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l1Head)) &#123;</span><br><span class="line">        cur.next = l1Head;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        l1Head = l1Head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l2Head)) &#123;</span><br><span class="line">        cur.next = l2Head;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        l2Head = l2Head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="kadane算法">17. Kadane算法</h2>
<h3 id="最大子数组和">17.1 <a
href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&amp;envId=top-interview-150">最大子数组和</a></h3>
<p>定义一个变量 maxNum
记录当前位置之前的子数组和，然后比较要不要从当前位置开始新的子数组，还是继续把当前位置纳入到子数组中，比较的方式就是，
Math.max(nums[i], nums[i] + maxNum) 。 也就是当前位置之前的子数组和 +
当前位置的数值，会不会比当前位置的数大。会的话就将当前位置纳入子数组，不会的话，就从当前位置开始。每次更新都要记录子数组和的最大值，所以最终求出来的结果就是最大子数组和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        maxNum = Math.max(nums[i], maxNum + nums[i]);</span><br><span class="line">        res = Math.max(res, maxNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环形子数组的最大和">17.2 <a
href="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&amp;envId=top-interview-150">环形子数组的最大和</a></h3>
<p>题解参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minS</span> <span class="operator">=</span> Integer.MAX_VALUE, maxS = Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minF</span> <span class="operator">=</span> <span class="number">0</span>, maxF = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        minF = Math.min(minF,<span class="number">0</span>) + num;</span><br><span class="line">        maxF = Math.max(maxF,<span class="number">0</span>) + num;</span><br><span class="line">        minS = Math.min(minS, minF);</span><br><span class="line">        maxS = Math.max(maxS, maxF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minS == sum? maxS : Math.max(maxS, sum - minS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二分查找">18. 二分查找</h2>
<h3 id="搜索插入位置">18.1 <a
href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&amp;envId=top-interview-150">搜索插入位置</a></h3>
<p>二分查找经典题目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l] &gt;= target ? l : l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索二维矩阵">18.2 <a
href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-interview-150">搜索二维矩阵</a></h3>
<p>首先把二维矩阵拉成一维矩阵来看待，然后把对应一维的矩阵下标转换成二维矩阵对应的下标即可。画个图讲一下怎么转换.
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203141.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[mid / m][mid % m];</span><br><span class="line">        <span class="keyword">if</span> (tmp == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="寻找峰值">18.3 <a
href="https://leetcode.cn/problems/find-peak-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">寻找峰值</a></h3>
<p>由于题目说了，可以假设
<code>nums[-1] = nums[n] = -∞</code>，那么在数组中，只要有一个数比它相邻的元素大，那就顺着大的元素的方向继续往下找，就一定能找到峰值。因为极端情况边缘数字就是峰值。</p>
<ul>
<li>根据上述结论，我们就可以使用二分查找找到峰值。</li>
<li>查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件</li>
<li>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m
较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m +
1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索旋转排序数组">18.4 <a
href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">搜索旋转排序数组</a></h3>
<p>虽然数组旋转了，但还是会有有序的部分。数组中点一定会把数组分割成两部分，一部分一定是有序的，我们只需要在有序的部分继续使用二分查找，那就一定能找到目标值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在排序数组中查找元素的第一个和最后一个位置">18.5 <a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">在排序数组中查找元素的第一个和最后一个位置</a></h3>
<p>其实这道题目就是 acwing 的二分查找的模板题目，但是 up
当时看完视频还是不懂，知道看了这篇<a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/?envType=study-plan-v2&amp;envId=top-interview-150">题解</a>，确实不需要去判断哪个地方得等于，哪个地方又得
+
1。我们只需要当找到目标值的时候，如果要找第一个出现的位置，我们就继续往左边找；如果要找最后一个出现的位置，我们就继续往右找就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    res[<span class="number">0</span>] = binarySearch(nums,target,<span class="literal">true</span>);</span><br><span class="line">    res[<span class="number">1</span>] = binarySearch(nums,target,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> isFirst)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>, tmp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            tmp = mid;</span><br><span class="line">            <span class="keyword">if</span>(!isFirst) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找旋转排序数组中的最小值">18.6 <a
href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&amp;envId=top-interview-150">寻找旋转排序数组中的最小值</a></h3>
<p>这道题目官方讲解讲的很好，可以看懂，这里就直接贴<a
href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/698479/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/?envType=study-plan-v2&amp;envId=top-interview-150">官方讲解</a>了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找两个正序数组的中位数">18.7 <a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-interview-150">寻找两个正序数组的中位数</a></h3>
<p>——暴力解法
其实就是将两个数组合并成一个数组，然后，求出新数组的中位数。但是没想到超过
100%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length, i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) arr[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> arr[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) arr[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) arr[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (arr[n / <span class="number">2</span>] + arr[n / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[n / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——二分解法</p>
<p>寻求第 k 小数的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>, right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="堆">19. 堆</h2>
<h3 id="数组中的第-k-个最大元素">19.1 <a
href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">数组中的第
K 个最大元素</a></h3>
<p><strong>——排序</strong></p>
<p>不符合题意要求，这里不贴代码了</p>
<p><strong>——快速排序</strong></p>
<p>回忆一下下面快速排序的代码，其实快速排序实现的是什么，是将一个数组分成两个部分，前半部分小于某个数
base，后半部分大于某个数 base。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = nums[i + j &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span> (nums[i] &lt; base);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span> (nums[j] &gt; base);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从这里入手</span></span><br><span class="line">    _quickSort_(nums, l, j);</span><br><span class="line">    _quickSort_(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在要找到第 K
大的数，怎么利用快速排序来找呢？我们可以从上面代码标记的位置入手。当代码运行到此处是，此时的数组前半部分全是小于
base 的数，后半部分全是大于 base 的数，我们要找第 k
大，只需要看看前半部分有没有 k
个数，有的话，在前半部分找；没有则到后半部分找。看看实现代码~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span> (nums[i] &lt; base);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span> (nums[j] &gt; base);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j) <span class="keyword">return</span> quickSort(nums, l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSort(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>——堆排序</strong></p>
<p>所谓的堆排序，就是用到一些在树状数组上进行的操作，建立大根堆，然后不断删除顶部节点。还是得画个图才比较明了
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214625.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        down(nums, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        down(nums, --len, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> len,  <span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">1</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">2</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != u) &#123;</span><br><span class="line">        swap(nums, t, u);</span><br><span class="line">        down(nums, len ,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ipo">19.2 <a
href="https://leetcode.cn/problems/ipo/description/?envType=study-plan-v2&amp;envId=top-interview-150">IPO</a></h3>
<p>——贪心算法
最开始看到这个题目感觉像背包，但是由于成本是随着收益的不断增加改变。所以应该用贪心的思路。具体是先将所有投资按照投资成本进行升序排序，然后根据现有资金决定是否投资对应的项目，将项目的收益按照降序排序存入堆中，每一次取出在当前投资资金所能支持的项目中收益最大的那一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> profits.length;</span><br><span class="line">    <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i][<span class="number">0</span>] = capital[i];</span><br><span class="line">        arr[i][<span class="number">1</span>] = profits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays._sort_(arr, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n &amp;&amp; w &gt;= arr[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            heap.add(arr[cur][<span class="number">1</span>]);</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            w += heap.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找和最小的-k-对数字">19.3 <a
href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&amp;envId=top-interview-150">查找和最小的
K 对数字</a></h3>
<p>使用最小堆存储两个数组的下标，使得对应下标值的和按照升序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; nums1[a[<span class="number">0</span>]] + nums2[a[<span class="number">1</span>]] - nums1[b[<span class="number">0</span>]] - nums2[b[<span class="number">1</span>]]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, k); ++i) &#123;</span><br><span class="line">        heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] idPairs = heap.poll();</span><br><span class="line">        res.add(Arrays.asList(nums1[idPairs[<span class="number">0</span>]], nums2[idPairs[<span class="number">1</span>]]));</span><br><span class="line">        <span class="keyword">if</span>(idPairs[<span class="number">1</span>] + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;idPairs[<span class="number">0</span>], idPairs[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流的中位数">19.4 数据流的中位数</h3>
<h2 id="位运算">20. 位运算</h2>
<h3 id="二进制求和">20.1 <a
href="https://leetcode.cn/problems/add-binary/description/?envType=study-plan-v2&amp;envId=top-interview-150">二进制求和</a></h3>
<p>其实就是高精度的模拟题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">aLen</span> <span class="operator">=</span> a.length(), bLen = b.length(), carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> aLen - <span class="number">1</span>, j = bLen - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">        carry += i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        carry += j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        res.append(carry % <span class="number">2</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(carry &gt; <span class="number">0</span> ? carry : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="颠倒二进制数">20.2 <a
href="https://leetcode.cn/problems/reverse-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">颠倒二进制数</a></h3>
<p>将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n
的每一位，将其倒序添加到翻转结果 res 中。</p>
<p>代码实现中，每枚举一位就将 n 右移一位，这样当前 n
的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。</p>
<p>需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n
的右移操作应使用逻辑右移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        res |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位-1-的个数">20.3 <a
href="https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">位
1 的个数</a></h3>
<p>每次将数右移一位，然后跟 1 做 &amp; 运算，如果存在 1，则计入次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) cnt++;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字">20.4 <a
href="https://leetcode.cn/problems/single-number/submissions/587464649/?envType=study-plan-v2&amp;envId=top-interview-150">只出现一次的数字</a></h3>
<p>——异或运算。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214718.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字-ⅱ">20.5 <a
href="https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">只出现一次的数字
Ⅱ</a></h3>
<p>模拟一下代码逻辑 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214740.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        a = (a ^ num) &amp; ~b;</span><br><span class="line">        b = (b ^ num) &amp; ~a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数字范围按位与">20.6 <a
href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&amp;envId=top-interview-150">数字范围按位与</a></h3>
<p>画个图就明白了，其实很简单。想一下，为什么会除了公共前缀之外，其他部分相与都为
0。无论多少个数相与，只要其中有一个数为 0，是不是所有数字相与都会为
0。那对于给定范围的左右两个数，除了公共前缀部分，后半部分是不是用来区分它们之间的不同，并且它们之前存在的是连续的不同，说明什么，说明不是公共前缀的部分，一定每一个位置上面都存在一个
0，所以相与一定为 0 . <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214801.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &lt;&lt; offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数学">21. 数学</h2>
<h3 id="回文数">21.1 <a
href="https://leetcode.cn/problems/palindrome-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">回文数</a></h3>
<p>简单题，简单做。每次取出给定数字的最后一位，作为新的数新增的一位，最后判断新构造的数和原来的数一不一样就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>, tmp = x;</span><br><span class="line">    <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        num = num * <span class="number">10</span> + tmp % <span class="number">10</span>;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加一">21.2 <a
href="https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&amp;envId=top-interview-150">加一</a></h3>
<p>——高精度加法模拟题</p>
<p>不想回忆，保研面试那会做了半个多小时，基础是太差了。现在 3
分钟就做出来了。不想回忆保研的日子~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">1</span>, n = digits.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        carry += digits[i];</span><br><span class="line">        res.add(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) res.add(carry);</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) ans[res.size() - i - <span class="number">1</span>] = res.get(i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘后的零">21.3 <a
href="https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&amp;envId=top-interview-150">阶乘后的零</a></h3>
<p>因为 2x5 = 10，所以，要有 0，因子中就必须要有 2 和 5。并且因子中的 2
一定会比 5 多。期间需要很多数学证明，这里有兴趣的话看<a
href="https://leetcode.cn/problems/factorial-trailing-zeroes/solutions/1360892/jie-cheng-hou-de-ling-by-leetcode-soluti-1egk/?envType=study-plan-v2&amp;envId=top-interview-150">题解</a>吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">        res += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="x-的平方根">21.4 <a
href="https://leetcode.cn/problems/sqrtx/?envType=study-plan-v2&amp;envId=top-interview-150">x
的平方根</a></h3>
<p>——二分查找</p>
<p>要找到一个整数的平方根，那么退出二分查找的条件则可以定为左右边界相差不能大于
1，这样就能把左右边界压缩到平方根的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x / mid == mid) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x / mid &lt; mid) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="powxn">21.5 <a
href="https://leetcode.cn/problems/powx-n/description/?envType=study-plan-v2&amp;envId=top-interview-150">Pow(x,n)</a></h3>
<p>——快速幂</p>
<p>快速幂的模板题，需要注意的是，当 n&lt;0 时，应该用除法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">long</span>) n;</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> t &gt; <span class="number">0</span>;</span><br><span class="line">    t = t &gt; <span class="number">0</span> ? t : -t;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) res *= x;</span><br><span class="line">            <span class="keyword">else</span> res /= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直线上最多的点数">21.6 <a
href="https://leetcode.cn/problems/max-points-on-a-line/description/?envType=study-plan-v2&amp;envId=top-interview-150">直线上最多的点数</a></h3>
<p>使用 Map
记录直线斜率，但是直线斜率算出来是浮点数，所以把直线斜率的分子和分母使用下划线拼接成字符串，然后作为键进行存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>], x2 = points[j][<span class="number">0</span>], y2 = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x1 - x2, b = y1 - y2;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> gcd(a, b);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (a / k) + <span class="string">&quot;_&quot;</span> + (b / k);</span><br><span class="line">            record.put(key, record.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, record.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">22.动态规划</h2>
<p>动态规划五部曲</p>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ol>
<h3 id="爬楼梯">22.1 <a
href="https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&amp;envId=top-interview-150">爬楼梯</a></h3>
<p>斐波那契数模板题目。 a[i] = a[i-1] + a[i-2]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍">22.2 <a
href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&amp;envId=top-interview-150">打家劫舍</a></h3>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义 <br> dp
数组表示能偷窃到当前房屋的最高金额。其中 dp[i]的下标 i 表示的是第 i+1
间房屋</li>
<li>确定递推公式 <br> 怎么推导递推公式呢？ 对于当前位置 i
来讲，要么就是前一个相邻位置 i-1 取得的收益高，我们此时就需要以 i-1
作为起点；要么就是再前面的一个位置 i - 2 取得的收益 +
当前房屋能取得的收益
的总和收益高。所以对于当前位置，我们的递推公式就是</li>
</ol>
<p><span class="math display">\[
\begin{equation}
max=\left\{
\begin{aligned}
nums[i] + dp[i-2] \\
dp[i-1]
\end{aligned}
\right.
\end{equation}
\]</span></p>
<ol type="1">
<li>dp 数组如何初始化 <br>
根据递推公式我们可以知道，我们需要初始化的值只有两个，dp[0],
dp[1]，dp[0]是什么，是打劫第一间房屋取得的收益，没得选，只有第一家能选。dp[1]是什么，dp[1]是打劫完第一和第二间房屋后，所取得的最大收益，那是什么，肯定是第一间和第二间房屋取得更大收益那个，所以我们的初始化就出来了
dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]);</li>
<li>确定遍历顺序 <br></li>
</ol>
<p>一维数组，基本都是从小到大，只有设计背包问题，两个条件才需要考虑遍历顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math._max_(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        dp[i] = Math._max_(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词拆分">22.3 <a
href="https://leetcode.cn/problems/word-break?envType=study-plan-v2&amp;envId=top-interview-150">单词拆分</a></h3>
<p>——动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——前缀树</p>
<p>被样例整破防了，前缀树压根过不了，这里写一个没有完全通过的版本，题解竟然叫去写前缀树。看来还是我学不够。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node root;</span><br><span class="line">        Trie()&#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertWord</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.subNodes.containsKey(ch))&#123;</span><br><span class="line">                    cur = cur.subNodes.get(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.subNodes.put(ch,<span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                    cur = cur.subNodes.get(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">            <span class="type">boolean</span> isEnd;</span><br><span class="line">            Map&lt;Character,Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordSet) &#123;</span><br><span class="line">            root.insertWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Trie.<span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> root.root;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.subNodes.containsKey(s.charAt(idx)))&#123;</span><br><span class="line">                tmp = tmp.subNodes.get(s.charAt(idx));</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.isEnd) tmp = root.root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换">22.4 <a
href="https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&amp;envId=top-interview-150">零钱兑换</a></h3>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义<br> dp[i]表示的是：当总金额为
i 时，所需的最少的硬币数。</li>
<li>确定递推公式<br> dp[i] = Math._min_(dp[i], dp[i - coins[j]] + 1)
对于总金额为 i 的情况，我们需要考虑第 j 个硬币到底取不取。取的话，应该由
i-coins[j] 的最少硬币数 + 1 来赋值；不取的话，就只能赋回原来的值。</li>
<li>dp 数组如何初始化<br> dp[0] = 0 当总金额为 0
时，我们需要的硬币数也为 0 .</li>
<li>确定遍历顺序<br>
其实，这道题目很像多重背包，但又存在很多不同。首先一个是这道题目想要求解的是计数问题，并不是最大化价值问题；其次是这道题目的遍历顺序跟多重背包的遍历顺序不太一样，多重背包是先遍历物品，再遍历背包。这道题目是先遍历的背包，再遍历物品。因为对于每一个总金额，我们都需要考虑所有的硬币所组成的搭配。并优化器</li>
<li>举例推导 dp 数组<br></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    Arrays._fill_(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                dp[i] = Math._min_(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长递增子序列">22.5 <a
href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150">最长递增子序列</a></h3>
<p>——动态规划 + 二分查找</p>
<p>还是画个图模拟一下代码的整个流程更好理解一点。如下图，二分查找插入的目的是什么？其实目的就是为了让我们的
dp
数组更好插入后面的数。二分查找为新到来的数在新数组中找到一个最合适的插入位置，使得新数组中的数保持递增并尽量小。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111852.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[len] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; dp[len]) dp[++len] = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多维动态规划">23. 多维动态规划</h2>
<h3 id="三角形最小路径和">23.1 <a
href="https://leetcode.cn/problems/triangle/?envType=study-plan-v2&amp;envId=top-interview-150">三角形最小路径和</a></h3>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111914.png" />
从最下面往上面走，第 i 层 第 j 个数的最终结果是什么呢？</p>
<p><span class="math display">\[
dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j];
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">    <span class="comment">// 由底部到顶部</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) dp[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            dp[j] = Math._min_(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和">23.2 <a
href="https://leetcode.cn/problems/minimum-path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">最小路径和</a></h3>
<p>先处理边界格子（下图标绿色的格子），对于非边界的格子，可以由左边和上边推导得到。边缘只能从左边或者上面来，所以没得优化，所以我们对最上面的边和最左面的边，我们使用前缀和算出到每一个格子需要的路径。对于不是最左边和最上边的格子，我们的递推公式为：</p>
<p><span class="math display">\[
dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])
\]</span> 其中 dp[i-1][j] 表示从上面来，dp[i][j-1]表示从左边来 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111936.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="不同路径-ⅱ">23.3 <a
href="https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">不同路径
Ⅱ</a></h3>
<p>其实跟上一道题目思路差不多，都是先处理边界格子。但还是存在差别，本题我们是计算到达格子的路线有几条，不是求最小值，而是求和。另外在处理格子时，对于边界的格子，都只有从左边来或者从上边来一种路线，所以我们初始化为
1，但是，遇到障碍物后，后面的格子都没法到达，所以为 0
。对于非边界的格子，也同样需要对存在障碍物进行处理，存在障碍物不更新，不存在障碍物才更新</p>
<p>递推公式</p>
<p><span class="math display">\[
dp[i][j] = dp[i-1][j] + dp[i][j-1]
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交错字符串">23.4 <a
href="https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">交错字符串</a></h3>
<p>——动态规划</p>
<p>其实题目说了一堆交错组成的概念，真的需要考虑是否是交错组合吗？其实不用，设想一下，当
s3 已经有字符跟 s1 的字符匹配了，下一个字符无论是 s1 的还是 s2
的，都能保证交错组成。最极端的情况便是前半部分由 s1 组成，后半部分由 s2
组成，但这也是交错。所以我们可以大胆的以字符串匹配的想法来做。但是这里会存在一个疑问，为什么不能用双指针呢？如下图所示，当遍历到
s3 这个位置时，我们会发现此时用来遍历 s1 和 s2 的指针都满足与 s3
匹配的要求，所以此时如果走 s1，尚且能通过样例，一旦样例需要先走
s2，那就过不了了。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111959.png" />
再来讲一下动态规划的思路吧。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221112028.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line">    <span class="keyword">if</span> (n + m != t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = dp[i][j] || (s1.charAt(i - <span class="number">1</span>) == s3.charAt(q) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = dp[i][j] || (s2.charAt(j-<span class="number">1</span>) == s3.charAt(q) &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离">23.5 <a
href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&amp;envId=top-interview-150">编辑距离</a></h3>
<p>假设我们有两个字符串 word1 和 word2，我们的目标是将 word1 转换成
word2。设 dp[i][j] 表示的是将 word1 的前 i 个字符转换成 word2 的前 j
个字符所需的最小编辑操作数。</p>
<p>情况 1: 字符相等 如果 word1 的第 i 个字符（即 word1[i-1]）等于 word2
的第 j 个字符（即
word2[j-1]），那么这两个字符之间不需要任何编辑操作，因此 dp[i][j] =
dp[i-1][j-1]。</p>
<p>情况 2: 字符不等 如果 word1[i-1] !=
word2[j-1]，那么我们需要考虑三种编辑操作：</p>
<p>最终，dp[i][j]
应该取这三种情况中的最小值，因为我们要找的是最少编辑操作次数。所以可以得到最终的递推结果</p>
<p><span class="math display">\[
\begin{equation}
dp[i][j]=\left\{
\begin{aligned}
&amp;dp[i-1]&amp; word1[i-1] == word2[j-1] \\
&amp;min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1&amp; word1[i-1] !=
word2[j-1]
\end{aligned}
\right.
\end{equation}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    word1 = <span class="string">&quot;0&quot;</span> + word1;</span><br><span class="line">    word2 = <span class="string">&quot;0&quot;</span> + word2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>][m + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅱ">23.6 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机
Ⅱ</a></h3>
<p>——投机取巧</p>
<p>题目说没有限制一天里只能买或者只能卖，并且也没有限制买卖的次数，我们只需要看有涨幅就进行买卖操作，就能获得最大收益。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[j] &gt; prices[j - <span class="number">1</span>]) res += prices[j] - prices[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——动态规划</p>
<ol type="1">
<li>定义状态</li>
</ol>
<p>dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i
天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p>
<ol start="2" type="1">
<li><p>考虑情况</p>
<ol type="1">
<li>情况一 考虑 dp[i][0]
的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即
dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即
dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i]
的收益。因此为了收益最大化，我们列出如下的转移方程：</li>
<li>再来考虑
dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即
dp[i−1][1]，或者前一天结束时还没有股票，即
dp[i−1][0]，这时候我们要将其买入，并减少 prices[i]
的收益。可以列出如下的转移方程：</li>
</ol>
<p><span class="math display">\[
p[i][1]=max(dp[i−1][1],dp[i−1][0]−prices[i])
\]</span></p></li>
<li><p>对于初始状态</p></li>
</ol>
<p>根据状态定义我们可以知道第 0 天交易结束的时候
dp[0][0]=0，dp[0][1]=−prices[0]。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候
dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为
dp[n−1][0]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅲ">23.7 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅲ</a></h3>
<p>——动态规划</p>
<ol type="1">
<li><p>定义状态</p>
<ol type="1">
<li>j=0 表示第 i 天结束时，未持有任何股票，且购买次数为
2。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][0]=dp[i-1][0];
\]</span></p>
<ol start="2" type="1">
<li>j=1 表示第 i 天结束时，持有股票，且购买次数为
1。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
p[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i-1])
\]</span></p>
<p>（prices[i-1]表示第 i 天的价格，下同）</p>
<ol start="3" type="1">
<li>j=2 表示第 i 天结束时，持有股票，且购买次数为
2。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
p[i][2]=max(dp[i-1][2],dp[i-1][3]-prices[i-1])
\]</span></p>
<ol start="4" type="1">
<li>j=3 表示第 i 天结束时，未持有股票，且购买次数为 1。
可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][3]=max(dp[i-1][3],dp[i-1][1]+prices[i-1])
\]</span></p>
<ol start="5" type="1">
<li>j=4 表示第 i 天结束时，未持有股票，且购买次数为 1
。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][4]=max(dp[i-1][4],dp[i-1][2]+prices[i-1])
\]</span></p></li>
<li><p>对于初始状态</p></li>
</ol>
<p>由于第 1 天卖出股票的情况都是当天买当天卖，因此 0、3、4 状态都为
0，讨论 1、2 状态</p>
<p>第一天第一次买入：</p>
<p><span class="math display">\[
dp[1][1]=-prices[0];
\]</span> 第一天第二次买入（第一次当天买当天卖）：</p>
<p><span class="math display">\[
dp[1][2]=-prices[0];
\]</span> ​ 3. 返回值</p>
<p>考虑到如果最后一天买入并不会使最大值的结果发生变化，因此，答案只会在
3、4 状态产生</p>
<p><span class="math display">\[
max（dp[n][3],dp[n][4]）;
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n][<span class="number">4</span>], dp[n][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅳ">23.8 <a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅳ</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[][] matrix : dp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : matrix) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MIN_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; ++i) dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">0</span>] = Math.max(dp[i][j][<span class="number">0</span>], dp[i][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">1</span>] = Math.max(dp[i][j][<span class="number">1</span>], dp[i][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计全为-1-的正方形子矩阵">23.9 <a
href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/">统计全为
1 的正方形子矩阵</a></h3>
<p>贴一下官方题解吧，写的很清晰。不过我再解释一下为什么递推公式可以是下面这个</p>
<p><span class="math display">\[
\begin{equation}
dp[i][j]=\left\{
\begin{aligned}
min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1] &amp;  &amp; matrxi[i][j]==1 \\
0 &amp;  &amp; matrix[i][j] == 0 \\
\end{aligned}
\right.
\end{equation}
\]</span></p>
<p>我们画个图讲一下吧 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221112105.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSquares</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(matrix) || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || matrix[i][j] == <span class="number">0</span>) dp[i][j] = matrix[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            res += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大正方形">23.10 <a
href="https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&amp;envId=top-interview-150">最大正方形</a></h3>
<p>这个题目的解法基本跟上面的题目思路一致。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(matrix) || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res = Math.max(dp[i][<span class="number">0</span>], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res = Math.max(dp[<span class="number">0</span>][j], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>面试经典150题</tag>
      </tags>
  </entry>
  <entry>
    <title>单一职责原则</title>
    <url>/2025/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单一职责原则</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2025/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="工厂模式">工厂模式</h1>
<h2 id="引言">1、引言</h2>
<p>  在面向对象编程中，创建对象实例最常用的方式就是通过 new
操作符构造一个对象实例，但在某些情况下，new
操作符直接生成对象会存在一些问题。举例来说，对象的创建需要一系列的步骤：可能需要计算或取得对象的初始位置、选择生成哪个子对象实例、或在生成之前必须先生成一些辅助对象。
在这些情况，新对象的建立就是一个
“过程”，而不仅仅是一个操作，就像一部大机器中的一个齿轮传动。</p>
<p>  针对上面这种情况，我们如何轻松方便地构造对象实例，而不必关心构造对象示例的细节和复杂过程？解决方案就是使用一个<strong>工厂类来创建对象</strong>。</p>
<h2 id="什么是工厂模式">2、什么是工厂模式</h2>
<p>  工厂模式的主要目的是将创建对象的具体过程屏蔽隔离起来，从而达到更高的灵活性。工厂模式可以分为三类：</p>
<ul>
<li><strong>简单工厂模式（Simple
Factory）：</strong>只有唯一工厂（简单工厂），一个产品接口/抽象类，根据简单工厂中的静态方法来创建具体产品对象。适用于产品较少，几乎不扩展的情景</li>
<li><strong>工厂方法模式（Factory
Method）：</strong>有多个工厂（抽象工厂+多个具体工厂），一个产品接口/抽象类，根据继承抽象工厂中的方法来多态创建具体产品对象。适用于一个类型的多个产品</li>
<li><strong>抽象工厂模式（Abstract
Factory）：</strong>有多个工厂（抽象工厂+多个具体工厂），多个产品接口/抽象类，对产品子类进行分组，根据继承抽象工厂中的方法多态创建同组的不同具体产品对象。适用于多个类型的多个产品</li>
</ul>
<p>举个生产电脑的栗子介绍一下这几个工厂模式：</p>
<p>（1）在没有工厂的时代，如果客户需要一款MBP电脑，那么就需要客户去创建一款MBP电脑，然后拿来用。</p>
<p>（2）简单工厂模式：后来出现了工厂，用户不再需要去创建MBP电脑，由工厂进行创建，想要什么MBP电脑，直接通过工厂创建就可以了。比如想要M3系列的MBP电脑，工厂就创建这个系列的电脑。</p>
<p>（3）工厂方法模式：为了满足客户，MBP系列越来越多，如M3、M4等等系列，一个工厂无法创建所有的MBP系列，于是又单独分出来多个具体的工厂，每个具体工厂创建一种系列，即具体工厂类只能创建一个具体产品。但是MBP电脑工厂还是个抽象，你需要指定某个具体的工厂才能生产电脑出来。</p>
<p>（4）抽象工厂模式：随着客户要求越来越高，MBP电脑车必须配置鼠标，于是这个工厂开始生产MBP电脑和需要的鼠标。最终是客户只要对宝马的销售员说：我要M3的带有鼠标的MBP电脑，销售员就直接给他M3的带有鼠标的MBP电脑了。而不用自己去创建M3的带有鼠标的MBP电脑。</p>
<h2 id="无工厂模式实现">3、无工厂模式实现</h2>
<p>  如果没有工厂模式，那么用户要获得MBP电脑就得自己去创建，想要什么型号，就得找到对应的型号去new。以下是对应类图以及实现。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312203232.png" style="zoom: 33%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">        customer.createMBPM3();</span><br><span class="line">        customer.createMBPM4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MBPM3 <span class="title function_">createMBPM3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MBPM4 <span class="title function_">createMBPM4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产---&gt; MBPM3电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MBPM4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产MBPM4电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单工厂模式">4、简单工厂模式</h2>
<p>  简单工厂模式有叫做静态工厂方法模式（static Factory Method
pattern），它时通过使用静态方法接受不同的参数来返回不同的实例对象。简单工厂模式的核心是定义一个创建对象的接口，将对象的创建和本身的业务逻辑分离，降低系统的耦合度，使得以后需要改变时，只需要修改工厂类即可。</p>
<h3 id="简单工厂实现原理及uml图">（1）简单工厂实现原理及UML图</h3>
<p>  其实实现的主要原理还是利用到了多态的概念，可以用父类去接子类的对象，这就非常方便我们将创建对象的方法进行抽象，我们只需要定义一个公共的MBP父类，用不同型号的子类去继承它。对于创建子类对象的过程交给工厂完成，最后用父类去接创建出来的子类对象即可。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312205351.png" style="zoom:50%;" /></p>
<h3 id="实现代码">（2）实现代码</h3>
<p>产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBP</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBPM3</span> <span class="keyword">extends</span> <span class="title class_">MBP</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产M-----&gt;MBP3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBPM4</span> <span class="keyword">extends</span> <span class="title class_">MBP</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MBPM4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产M-----&gt;MBP4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MBP <span class="title function_">createMBP</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M3&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M4&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态工厂</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> MBP <span class="title function_">createMBPStatic</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M3&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM3</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M4&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MBPM4</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m3</span> <span class="operator">=</span> factory.createMBP(<span class="string">&quot;M3&quot;</span>);</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m4</span> <span class="operator">=</span> factory.createMBP(<span class="string">&quot;M4&quot;</span>);</span><br><span class="line">		<span class="comment">// 静态工厂</span></span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m31</span> <span class="operator">=</span> Factory.createMBPStatic(<span class="string">&quot;M3&quot;</span>);</span><br><span class="line">        <span class="type">MBP</span> <span class="variable">m41</span> <span class="operator">=</span> Factory.createMBPStatic(<span class="string">&quot;M4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优缺点">（3）优缺点</h3>
<ul>
<li>优点：简单工厂可以使客户端免除直接创建对象的职责，能够根据需要创建出对应的产品。实现客户端可产品类的代码分离。此外，可以通过配置文件来实现不修改客户端代码的情况下添加新的具体产品类</li>
<li>缺点：<strong>违背了开闭原则</strong>，如果需要新增其他产品类，就必须在工厂类中新增类似<code>if-else</code>的条件判断（上面的演示代码用了<code>switch</code>），虽然可以用配置文件来改进，但是整体上而言，系统扩展相对于其他工厂模式要困难很多。
<ul>
<li>关于如何使用配置文件改进简单工厂，在这里描述一下：其实就是将创建工厂的条件，上述代码中的<code>String type</code>，改成是根据类路径来创建对象。再详细点就是，将类路径写在配置文件中，然后工厂在创建对象的时候，根据获取到的类路径，用反射创建出对象。这样，即使有了新的产品，我们也只需要在新建产品类并继承产品父类，然后在配置文件中添加新建产品类的类路径。</li>
</ul></li>
</ul>
<h3 id="简单工厂和静态工厂">（4）简单工厂和静态工厂</h3>
<p>可以看到上面用户类中使用了两种方法创建实例对象，一种是类方法，一种是类的静态方法。那使用类的静态方法有什么好处呢？</p>
<ul>
<li>使用静态方法可以不需要使用<code>new</code>的方法创建对象，方便调用</li>
<li>控制实例的创建，如缓存实例，延迟初始化</li>
<li>减少客户端对具体类的依赖</li>
</ul>
<h3 id="简单工厂在实际中的应用">（5）简单工厂在实际中的应用</h3>
<p>【1】如<code>DataFormat</code>中这个方法就使用了简单工厂</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312212636.png" style="zoom: 67%;" /></p>
<p>【2】对于数据库连接池，如业务需要连接数据库时，需要支持不同的数据库，如<code>dbcp</code>、<code>c3p0</code>、<code>druid</code>等等，这个时候数据库连接方式有限，而且比较固定不容易更改，所以可以尝试采用简单工厂模式来进行管理数据库连接对象。</p>
<p>【3】在<code>spring</code>源码中以Factory为后缀的方法或者类都用到工厂模式</p>
<h2 id="工厂方法模式">5、 工厂方法模式</h2>
<p>  工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个？将对象的创建与实例化延迟到子类，这样工厂的设计就符合”开闭原则“了，扩展时不必去修改原来的代码。</p>
<h3
id="工厂方法模式实现原理及uml图">（1）工厂方法模式实现原理及UML图</h3>
<p>其实也很好理解，就是在简单工厂模式中，会存在判断语句的情况，相当于在工厂类中，一个生产类的方法</p>
<h2 id="抽象工厂模式">6、 抽象工厂模式</h2>
<h2 id="总结">7、总结</h2>
<p>  无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p>
<p>  所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到即可。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2025/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一设计模式总述">一、设计模式总述</h1>
<h2 id="什么是设计模式">1、什么是设计模式</h2>
<p>  
设计模式是一套经过反复使用的代码设计经验，目的是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<p>  项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相对应的原理与之对应，每种模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p>
<p>  总体而言，设计模式分为三大类：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312144024.png" style="zoom:60%;" /></p>
<h2 id="设计模式的六大原则">2、设计模式的六大原则</h2>
<p>设计模式主要有六大设计原则，分别是：单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特原则。<br><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312193040.png" style="zoom:67%;" /></p>
<h3
id="单一职责原则single-responsibility-principle">（1）单一职责原则（Single
Responsibility Principle）</h3>
<ol type="1">
<li>定义：一个接口或者类只有一个原因引起变化。</li>
<li>定义解释：即一个接口或者一个类只有一个职责，负责一件事情。（此原则同样适用于方法）</li>
<li>好处：① 复杂性降低 ② 可读性提高 ③可维护性提高 ④变更风险降低</li>
</ol>
<h3 id="开闭原则-open-close-principle">（2）开闭原则 <strong>(Open Close
Principle)</strong></h3>
<ol type="1">
<li>定义：软件实体对扩展开放，对修改关闭。</li>
<li>定义解释：也就是应该通过扩展来实现业务需求和变化，而不是通过修改已有的代码来实现变化。</li>
<li>好处：① 强系统的稳定性和可扩展性 ②减少对现有代码的影响</li>
</ol>
<h3 id="里氏替换原则-liskov-substitution-principle">（3）里氏替换原则
<strong>(Liskov Substitution Principle)</strong></h3>
<ol type="1">
<li>定义：任何基类可以出现的地方，子类一定可以出现。</li>
<li>定义解释：
<ul>
<li>子类必须完全实现弗雷的方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或者实现父类方法时，输入参数可以被放大</li>
<li>覆盖或者实现父类方法时，输出结果可以被缩小</li>
</ul></li>
<li>好处：① 提升代码的可靠性和复用性 ②减少继承带来的问题</li>
</ol>
<h3 id="依赖倒置原则-dependence-inversion-principle">（4）依赖倒置原则
<strong>(Dependence Inversion Principle)</strong></h3>
<ol type="1">
<li>定义：高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。</li>
<li>定义解释：简单点来说，就是面向接口编程。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系时通过接口或者抽象类产生。</li>
<li>好处：① 降低模块间的耦合 ②提升系统的可扩展性和可维护性</li>
</ol>
<h3 id="接口隔离原则-interface-segregation-principle">（5）接口隔离原则
<strong>(Interface Segregation Principle)</strong></h3>
<ol type="1">
<li>定义：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li>
<li>定义解释：应该为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</li>
<li>好处：① 提高系统的灵活性和可维护性 ② 减少接口间的耦合。</li>
</ol>
<h3 id="迪米特原则-demeter-principle">（6）迪米特原则 <strong>(Demeter
Principle)</strong></h3>
<ol type="1">
<li>定义：<strong>只与直接的朋友通信。</strong>一个类应该对其他类保持最少的了解</li>
<li>定义解释：也就是说一个类对自己依赖的类知道的越少越好。即对于被依赖的类，无论逻辑多复杂，都尽量地讲逻辑封装在类的内部，对外除了提供的public方法，不对外泄露任何信息。</li>
<li>好处：① 提高模块的独立性 ② 减少依赖 ③
增强系统的可维护性和可复用性。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本指令</title>
    <url>/2025/03/12/Hexo/hexo%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>  如果只是满足平时写写博客，推送到GitHub方便在各处访问的话，其实这下面这几个命令就够了。但是这篇博文会一直更新，博主有用到别的指令会及时来这里更新。</p>
<ol type="1">
<li><p>首先是创建一个新的页面的指令，在终端敲击。由于博主使用的是WebStorm，所以是在应用里的终端界面敲击的。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;page_name&quot;</span>    <span class="comment"># 创建新的页面</span></span><br></pre></td></tr></table></figure> <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250312090453.png" /></p></li>
<li><p>其次是准备部署线上环境需要使用到的指令，三个命令行同时运行，就能将新写的博文推送到GitHub啦，当然部署也需要时间，只要指令运行不报错，就耐心等待一下啦
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo clean   <span class="comment"># 清除之前生成的渲染文件</span></span><br><span class="line"></span><br><span class="line">hexo g   <span class="comment"># 生成新的渲染文件</span></span><br><span class="line"></span><br><span class="line">hexo d   <span class="comment"># 推送到GitHub进行自动部署</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></p></li>
<li><p>在本地查看渲染效果，运行该指令之后直接访问
<code>http://localhost:4000/</code>, 就可以看到渲染后的最新博客
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo s     <span class="comment"># hexo start 的意思，就是开启项目 </span></span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis应用</title>
    <url>/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="一使用redis实现登录校验">一、使用Redis实现登录校验</h1>
<p> 
主要验证是校验码验证和密码验证，我觉得可以这样设计，把验证码存入到Redis中，用户信息使用JWT生成对应的token，然后将JWT生成的token存入到Redis中（替代直接将用户信息存入Redis中），这样可以减少Redis的内存负担。具体流程图如下方所示，<br />
 
下图的具体做法是将用户的信息采用JWT进行加密保存了，出于安全考虑，我觉得对于前端页面上用户的基本信息可以使用JWT存储，这样在解析的时候也会比去Redis中再获取一次要快。但是对于用户一些常用的敏感信息，我觉得还是有必要放在Redis中的。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309103254.png" style="zoom:50%;" /></p>
<h1 id="二缓存">二、缓存</h1>
<p>使用缓存主要会存在几种问题：缓存雪崩，缓存击穿，缓存穿透。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309110729.png" style="zoom:50%;" /></p>
<h2 id="缓存雪崩">1、 缓存雪崩</h2>
<h3 id="什么是缓存雪崩">（1）什么是缓存雪崩？</h3>
<p>如果缓存在某一个时刻出现大规模key失效，那么就会导致大量的请求打在数据库上面，导致数据库压力巨大，如果高并发的情况下，可能瞬间就会导师数据库宕机。这时如果运维马上又重启数据库，马上又会有新的流量把数据库打死，这就是缓存雪崩。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203618.png" style="zoom:70%;" /></p>
<h3 id="问题分析">（2）问题分析：</h3>
<p>存在这种情况的问题所在：</p>
<ul>
<li>Redis宕机</li>
<li>大量缓存采用了相同的过期时间</li>
</ul>
<h3 id="解决方案">（3）解决方案：</h3>
<h4 id="事前">&lt;1&gt; 事前：</h4>
<ol type="1">
<li><p>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问</p></li>
<li><p>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不相同</p></li>
<li><p>热点数据永远不过期</p>
<blockquote>
永不过期实际包含两层意思：
<ul>
<li>物理不过期：针对热点key不设置过期时间</li>
<li>逻辑过期：把过期时间存在key对应的value中，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</li>
</ul>
</blockquote></li>
<li><p>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用
主从 + 哨兵，Redis集群来避免Redis全盘崩溃的情况</p></li>
</ol>
<h4 id="事中">&lt;2&gt; 事中：</h4>
<ol type="1">
<li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读写数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他线程，此时系统的吞吐量会下降</li>
<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果</li>
</ol>
<h4 id="事后">&lt;3&gt; 事后：</h4>
<p> 
开启Redis持久化机制，尽快回复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p>
<h2 id="缓存击穿">2、缓存击穿</h2>
<h3 id="什么是缓存击穿">（1）什么是缓存击穿</h3>
<p> 
缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿则是某个热点key失效，大规模并发对其进行请求，就会导致大量请求读缓存读取不到数据，从而导致大规模请求直接打到数据库，引起数据库压力剧增，这就是缓存击穿。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135734.png" style="zoom:70%;" /></p>
<h3 id="问题分析-1">（2）问题分析</h3>
<p> 
关键在于某个热点key失效了，导致大并发集中打在数据库上。所以要从两个方面解决。第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量</p>
<h3 id="解决方案-1">（3）解决方案</h3>
<h4 id="互斥锁或者队列">&lt;1&gt; 互斥锁或者队列</h4>
<p> 
在缓存失效后，通过<strong>互斥锁或者队列</strong>来控制读数据写缓存的线程数量
#### &lt;2&gt; 永不过期   热点数据缓存<strong>永不过期</strong></p>
<h2 id="缓存穿透">3、缓存穿透</h2>
<h3 id="什么是缓存穿透">（1）什么是缓存穿透</h3>
<p> 
缓存穿透是指用户请求的数据在<strong>缓存中不存在</strong>，即读请求时没有命中缓存，同时<strong>数据库也不存在该数据</strong>。导致用户每次请求该数据都要去数据库查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间内大量请求直接打在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135630.png" style="zoom:70%;" /></p>
<h3 id="问题分析-2">（2）问题分析</h3>
<p> 
缓存穿透的关键在于在Redis中查不到key值。一般导致缓存穿透主要有两种情况：一个是业务误操作，删除了数据库和redis中的缓存；另外一个是黑客恶意攻击。假如有黑客传进大量的不存在key，那么大量的请求打在数据库上是很致命的问题。所以在日常开发中要对参数做好校验，一些非法参数，不可能存在的key就直接返回错误提示。</p>
<h3 id="解决方案-2">（3）解决方案</h3>
<h4 id="非法请求的限制">&lt;1&gt; 非法请求的限制</h4>
<p> 
在API入口处判断请求参数是否合理，请求参数是否含有非法值，请求字段是否存在，如果判断出是恶意请求则直接返回错误，避免进一步访问缓存和数据库</p>
<h4 id="将无效key存放在redis中">&lt;2&gt; 将无效key存放在Redis中</h4>
<p> 
当出现Redis查不到数据，数据库也查不到数据的情况，则把这个key保存到Redis中，这是value=“null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，不再需要查询数据库。但该方法存在一定的问题，假如传进来的不存在的key每次都是随机的，那存入Redis也没有意义</p>
<h4 id="使用布隆过滤器">&lt;3&gt; 使用布隆过滤器</h4>
<p> 
在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询key是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<blockquote>
<p>什么是布隆过滤器？</p>
<p>布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好得多，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<p>布隆过滤器原理：</p>
<ul>
<li>第一步，使用N个哈希函数分贝对数据做哈希计算，得到N个哈希值；</li>
<li>第二步，将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为1。</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203643.png" style="zoom:80%;" /></p>
<blockquote>
<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机的，若采用缓存空对象方案会缓存大量不存在key的数据，并不合适。所以需要采用布隆过滤器方案，布隆过滤器先过滤掉不存在的key。针对key异常多、请求重复率比较低的数据，优先使用布隆过滤器方案。对于空数据的key有限，重复率比较高的，则优先采用缓存空对象方案</p>
</blockquote>
<h2 id="汇总">汇总</h2>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309181748.png" style="zoom:80%;" /></p>
<h2 id="缓存预热">4、缓存预热</h2>
<h3 id="什么是缓存预热">（1）什么是缓存预热</h3>
<p> 
缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，再将数据缓存的问题，用户可以直接查询事先被预热的缓存数据。若不进行预热，则Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。</p>
<h3 id="缓存预热实现方案">（2）缓存预热实现方案</h3>
<ul>
<li>数据量不大时，工程启动的时候进行加载缓存动作</li>
<li>数据量大时，设置一个定时任务脚本，进行缓存的刷新</li>
<li>数据量非常大时，优先保证热点数据进行提前加载到缓存</li>
</ul>
<h2 id="缓存降级">5、缓存降级</h2>
<p> 
缓存降级指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般时有损的操作，所以尽量减少降级对业务的影响程度。
在项目实战中，通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p>
<h1 id="三数据库缓存保持一致性">三、数据库缓存保持一致性</h1>
<blockquote>
<p>先说结论：大多数业务采用的都是<strong>【先更新数据库，再删除缓存】</strong>的
Cache
Aside（旁路缓存）策略，同时给缓存设定过期时间，防止在第二步，删除缓存数据失败导致数据不一致的问题。</p>
<p>若业务对缓存命中率有很高的要求，则可以采用【先更新数据库，再更新缓存】的方案，因为主动更新缓存可以减少缓存未命中的情况</p>
</blockquote>
<h2 id="先更新数据库还是先更新缓存">1、先更新数据库还是先更新缓存</h2>
<p> 
<strong>都不可行。</strong>无论是【先更新数据库，再更新缓存】，还是【先更新缓存，再更新数据库】，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能出现数据库和缓存中的数据不一致的情况。常见的缓存更新策略主要有三种：Cache
Aside（旁路缓存）策略；Read/Write Through（读穿 / 写穿）策略；Write
Back（写回）策略；</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309190713.png" style="zoom:50%;" /></p>
<p>但在实际开发中，Redis和MySQL的更新策略用的是Cache
Aside策略，另外两种主要是用在操作系统中。</p>
<h2 id="cache-aside旁路缓存策略">2、 Cache Aside（旁路缓存）策略</h2>
<p> 
先更新数据库数据，然后不更新缓存，直接删除缓存中的数据。等客户端要读取数据时，发现缓存中没有，再从数据库中读取数据放到缓存中。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203658.png" style="zoom:50%;" /></p>
<h3 id="写策略">（1）写策略</h3>
<ul>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ul>
<h3 id="读策略">（2）读策略</h3>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据</li>
<li>如果读取的数据未命中缓存，则直接读取数据库中的数据，再将数据放入缓存。</li>
</ul>
<h2 id="先更新数据库还是先删缓存">2.1 先更新数据库还是先删缓存</h2>
<p> 
先说结论，<strong>先更新数据库，再删缓存</strong>。理论上来说，无论是【先更新数据库，再删除缓存】，还是【先删除缓存，再更新数据库】都会导致数据库与缓存数据不一致的问题。但为什么还是推崇【先更新数据库，再删除缓存】呢？
 
主要原因还是在【先更新数据库，再更新缓存】出现数据库与缓存数据不一致的情况较少。因为缓存的写入通常要远远快于数据库的写入。具体例子参考：<a
href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98">小林coding</a></p>
<h2 id="readwrite-through读穿-写穿策略">3、 Read/Write Through（读穿 /
写穿）策略</h2>
<p>  Read / Write
Through（读穿/写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是有缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p>
<h3 id="read-through">（1）Read Through</h3>
<p> 
先查询缓存中数据是否存在，如果存在则直接返回；如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用</p>
<h3 id="write-through">（2）Write Through</h3>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul>
<li>如果缓存中数据已存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li>
<li>如果缓存中数据不存在，则直接更新数据库，然后返回。</li>
</ul>
<h2 id="write-back写回策略">4、Write Back（写回）策略</h2>
<p>  Write
Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。【主要用于操作系统】</p>
<h2 id="小结">5、小结</h2>
<h3
id="使用先删除缓存再更新数据库">（1）使用【先删除缓存，再更新数据库】</h3>
<p>  针对【先删除缓存，再更新数据库】方案在【读 +
写】并发请求而造成缓存不一致的解决办法是<strong>【延迟双删】</strong>。就是等更新数据库的线程更新完数据库之后先睡眠一段时间，然后再删一次缓存，可以避免由于高并发使缓存中放入脏数据。但是这个睡眠时间需要大于另外一个读取数据的时间（查数据库
+ 将数据放入缓存）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br><span class="line"><span class="comment"># 更新数据库		</span></span><br><span class="line">db.update(X)</span><br><span class="line"><span class="comment"># 睡眠一段时间</span></span><br><span class="line">thread.sleep(N)</span><br><span class="line"><span class="comment"># 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure>
<h3
id="保证先更新数据库再删除缓存成功">（2）保证【先更新数据库，再删除缓存】成功</h3>
<p>为了保证【先更新数据库，再删除缓存】的第二个步骤，也就是删除缓存能成功，可以使用：</p>
<ul>
<li>消息队列重试缓存的删除，优点是保证缓存一致性问题，缺点是对业务代码入侵</li>
<li>订阅MySQL binlog + 消息队列 +
重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题。缺点是引入的组件较多，对团队的运维能力有比较高要求。</li>
</ul>
<h1 id="四redis持久化机制">四、Redis持久化机制</h1>
<p>Redis持久化数据的主要方式有两个，分别是：RDB快照和AOF日志。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309112643.png" /></p>
<h2 id="rdb快照">1、 RDB快照</h2>
<h3 id="相关概念">【1】相关概念</h3>
<h4 id="概念和启用">（1）概念和启用</h4>
<p>记录某一瞬间的内存数据【全量快照】，记录的是实际全部数据。所以相比于AOF文件记录命令操作日志，RDB恢复数据的效率要高很多，因为直接将RDB文件读入内存即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bgsave指令</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span>     <span class="comment"># 900秒之内，对数据库进行了至少1次修改</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>		<span class="comment"># 300秒之内，对数据库进行了至少10次修改</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>	<span class="comment"># 60秒之内，对数据库进行了至少10000次修改</span></span><br></pre></td></tr></table></figure>
<p>只要满足上面条件的任意一个，就会执行bgsave。</p>
<h4 id="使用指令">（2）使用指令</h4>
<ul>
<li><code>save</code>指令，使用主线程。若写入RDB文件的时间太长，会阻塞主线程</li>
<li><code>bgsave</code>指令，使用子线程。可以避免主线程的阻塞</li>
</ul>
<h3 id="执行快照时数据能被修改吗">【2】执行快照时，数据能被修改吗</h3>
<p>（1）save指令。不行，当执行save指令时，使用的是主线程生成快照，所以此时的主线程会被阻塞，然后去执行快照操作</p>
<p>（2）bgsave指令。
可以，bgsave使用的是子线程，主线程基本不会被阻塞。</p>
<h3
id="子线程如何拥有主线程相同的数据副本">【3】子线程如何拥有主线程相同的数据副本</h3>
<p><strong>写时复制。</strong>主进程通过<code>fork</code>系统调用生成子进程。同时，操作系统会把主进程的【页表】复制一份给子进程，这个页面记录着虚拟地址和物理地址的映射关系，而不会复制物理内存，即两者的虚拟空间不同，但指向的都是同一块物理空间。当父进程或子进程在向这块物理内存发起写操作时，由于这块内存父子进程只有只读共享权限，所以CPU会触发写保护中断，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制（需要注意的是这里只会复制主进程修改的物理内存数据，没修改的物理内存数据还是和子进程共享的）</p>
<h3
id="能否保证快照和数据库数据一致性">【4】能否保证快照和数据库数据一致性</h3>
<p><strong>不能</strong>，快照只能保存快照执行那一刻的Redis所有数据。</p>
<h2 id="aof日志">2、AOF日志</h2>
<h3 id="相关概念-1">【1】相关概念</h3>
<h4 id="概念和启用-1">（1）概念和启用</h4>
<p>对于Redis的每一次<strong>写操作</strong>，都会将这次写操作追加到一个文件里。在Redis中AOF持久化功能默认是不开启的，需要我们修改
redis.conf 配置文件中的以下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// redis.conf</span><br><span class="line">appendonly       yes   // 表示是否开启AOF持久化（默认no，关闭）</span><br><span class="line">appendfilename   &quot;appendonly.aof&quot;   // AOF持久化文件的名称</span><br></pre></td></tr></table></figure>
<h4 id="先写后记录">（2）先写后记录</h4>
<p>Redis只先执行了相关的写操作指令后，才将该指令写入到aof文件中的，这样子有多个好处：</p>
<ul>
<li><p>避免额外的检查开销</p>
<p>先执行，再写。执行不通过就不写。语法有问题，或者逻辑有问题，在运行的时候就能检测出来，减少了写进aof文件前的检查时间</p></li>
<li><p>不会阻塞当前写操作命令的执行</p>
<p>当前写操作指令执行成功后，才会将命令记录到AOF日志中。</p></li>
</ul>
<h4 id="潜在风险">（3）潜在风险</h4>
<ul>
<li><p>丢失风险</p>
<p>执行写操作命令和记录日志是两个过程，并不是原子操作。若Redis在还没来得及将命令写入硬盘时，服务器宕机，这个数据就会有丢失的风险</p></li>
<li><p>可能会给【下一个】命令带来阻塞风险</p>
<p>由于Redis在写AOF文件时，是以串行的方式进行，所以对当前的写Redis的执行不会阻塞，但是后面在写AOF文件的时候一旦发生阻塞，那下一个写Redis的命令就会有阻塞风险。</p></li>
</ul>
<h3 id="三种写回策略">【2】三种写回策略</h3>
<h4 id="aof写回">（1）AOF写回</h4>
<p>在介绍AOF写回策略之前，需要先介绍一下Redis将命令写入AOF的过程。如下图所示：</p>
<p>① Redis执行完写操作命令后，会将命令追加到
<code>server.aof_buf</code>缓冲区；<br>②
通过write()系统调用，将<code>aof_buf</code>
缓冲区的数据写入到AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区<code>page cache</code>，等待内核将数据写入硬盘;
<br>③ 具体内核缓冲区的数据什么时候写入到硬盘。由内核决定。</p>
<p><img src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311141509633.png" alt="image-20250311141509633" style="zoom:50%;" /></p>
<h4 id="三种写回策略-1">（2）三种写回策略</h4>
<p>Redis主要有三种写回策略，如下图思维导图所示：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311135343.png" /></p>
<h4 id="优化局限">（3）优化局限</h4>
<p>这3种写回策略都无法完美解决【主进程阻塞】和【减少数据丢失】的问题，因为两个问题对立，就像算法题优化时间和空间一样，有得有失。具体原因如下：</p>
<ul>
<li>Always
策略，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将
AOF 内容写回硬盘，所以是不可避免会影响主进程的性能; 【适合高可靠】</li>
<li>No 策略，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于
Always 策略性能较好但是操作系统写回硬盘的时机是不可预知的，如果 AOF
日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。【适合高性能】</li>
<li>Everysec 策略的话，是折中的一种方式，避免了 Always
策略的性能开销，也比 No
策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。【折中选择】</li>
</ul>
<h4 id="实现原理">（4）实现原理</h4>
<p>在查看源码时，会发现三种策略的实现都是建立在控制<code>fsync()</code>函数的调用时机。若想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用<code>fsync()</code>函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回</p>
<ul>
<li>Always策略：每次写入AOF文件数据，都会调用<code>fsync</code>函数</li>
<li>Everysec策略：创建一个异步任务调用<code>fsync</code>函数</li>
<li>No策略：永不调用<code>fsync</code>函数</li>
</ul>
<h3 id="aof重写机制">【3】AOF重写机制</h3>
<p> 其实就是压缩AOF文件，减少AOF文件中的执行代码。AOF重写机制在重写时，会读取当前Redis中的所有键值对，然后对每一个键值s生成一条命令记录到【新的AOF文件】，等全部记录完成，将新的AOF文件替换掉现在的AOF文件。</p>
<p> 举个栗子：假如现在王五要在redis种记录自己的名字，最开始记录名字为<code>zs</code>，发现记录错了，又改成<code>lisi</code>，结果发现还是错的，又改成<code>wangwu</code>，几番折腾，此时的AOF就需要记录3条写语句，这样很多写操作都是荣冗余的。在经过AOF重写后，AOF文件只需要保存最后一条写操作就可以。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311144321.png" style="zoom:67%;" /></p>
<h3 id="aof-后台重写">【4】AOF 后台重写</h3>
<h4 id="为什么是后台完成重写">（1）为什么是后台完成重写</h4>
<p> 为什么是后台重写呢？在上文我们可以看到，Redis在写AOF的时候，都是使用了主进程，（即写Redis操作和写AOF操作都是主进程在执行）。那为什么AOF的重写需要后台执行呢？因为AOF重写，是需要从Redis中读取所有键值对，然后对再为每一个键值对生成对应的Redis写指令，写进新的AOF文件中，再替换原来的AOF文件，这个过程非常耗时，所以需要系统在后台进行，不然很容易就阻塞了实际的写Redis操作。所以Redis在进行重写的时候是<strong>由后台子进程bgrewriteaof来完成</strong>。</p>
<h4 id="为什么是子进程">（2）为什么是子进程</h4>
<p> 进程才是操作系统的资源分配最小单位。如果使用线程，那么多线程之间会共享内存，那么在修改共享内存数据时，需要通过加锁来保证数据的安全，这样会降低性能。而使用子进程，创建子进程时，父子进程是以<strong>只读</strong>的方式共享内存数据的。当父子进程任意一方修改了该共享内存，就会发生【写时复制】（复制的也只是要写入或者修改的部分），于是父子进程就有了独立的数据副本，而不用加锁来保证数据安全。</p>
<h4
id="子进程如何拥有主进程相同的数据副本">（3）子进程如何拥有主进程相同的数据副本</h4>
<p><strong>整个过程：</strong></p>
<p>① 主进程通过<code>fork</code>系统调用生成bgrewriteaof子进程。</p>
<p>②
同时，操作系统会把主进程的【页表】复制一份给子进程，这个页面记录着虚拟地址和物理地址的映射关系，而不会复制物理内存，即两者的虚拟空间不同，但指向的都是同一块物理空间。</p>
<p>③
当父进程或子进程在向这块物理内存发起写操作时，由于这块内存父子进程只有只读共享权限，所以CPU会触发写保护中断，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制（需要注意的是这里只会复制主进程修改的物理内存数据，没修改的物理内存数据还是和子进程共享的）<br>
同时，由于此时子进程还处于重写AOF状态，读取的是还是之前的Redis中的数据，所以当主进程完成写操作时，会导致子进程读取的Redis数据与最新的数据不一致，也就是有“脏读”的现象。对于这种现象，Redis也有应对措施。那就是将AOF重写期间，主进程执行的所有写指令，都写进<strong>AOF重写缓冲区</strong>。另外，Redi也会写一份在<strong>AOF缓冲区</strong>（这个是为了防止子进程宕机，原来的AOF也不会少在AOF重写时候的写指令）</p>
<p>④ 等子进程重写完成时，主进程会将 AOF
重写缓冲区的指令，追加到新的AOF文件中，然后用新的AOF文件替换原来的AOF文件，这样也就保证了AOF文件和Redis的数据一致性。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311201538.png" style="zoom:60%;" /></p>
<p><strong>问题：</strong></p>
<p>整个过程会有风险吗？有。整个过程期间会有两个阶段会导致阻塞父进程：</p>
<ul>
<li>创建子进程期间，由于要复制父今晨更多页表等数据结构，阻塞时间跟页表的大小有关，页表越大，阻塞时间越长</li>
<li>创建子进程后，若子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，若内存越大（会有大Key问题），自然阻塞的时间越长。</li>
</ul>
<h2 id="rdb和aof合体">3、RDB和AOF合体</h2>
<h3 id="相关概念-2">【1】相关概念</h3>
<p>即将RDB和AOF合体使用，该方法也叫做<strong>混合使用AOF日志和内存快照</strong>，也叫<strong>混合持久化</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes	</span><br></pre></td></tr></table></figure>
<h3 id="过程">【2】过程</h3>
<p>缓和持久化工作在<strong>AOF日志重写过程</strong>。<br>当开启了混合持久化，在AOF重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，然后主线程的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以AOF方式写入到AOF文件，写入完成后通知主进程将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。</p>
<p>换句话说，使用了混合持久化，AOF文件的前半部分时RDB格式的全量数据，后半部分时AOF格式的增量数据。</p>
<h1 id="五redis实现秒杀">五、Redis实现秒杀</h1>
<h2 id="全局唯一id">1、 全局唯一id</h2>
<p>在分布式系统中，生成全局唯一id是一个常见且重要的需求，唯一ID的生成需要满足高并发、全局唯一性和高可用性。</p>
<h3 id="需要具备的特点">（1）需要具备的特点</h3>
<ul>
<li>全局唯一性：生成的ID在整个系统中必须是唯一的，避免冲突。</li>
<li>高可用性：生成ID的服务必须具备高可用性，确保在高并发场景下不出现性能瓶颈</li>
<li>有序性：在某些场景下，需要生成的ID有一定的顺序性，以便进行排序和分析</li>
<li>高性能：生成ID的过程需要高效，能够支持高并发请求</li>
<li>安全性：生成ID要不容易被摸索出规律，防止网络攻击</li>
</ul>
<p>Redis生成全局唯一id，这是用Redis自增的方法，我们还需要拼接上其他东西，比如时间戳之类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);	</span><br></pre></td></tr></table></figure>
<h2 id="超卖问题">2、超卖问题</h2>
<h3 id="问题描述">（1）问题描述</h3>
<p> 
一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是最基本的问题。</p>
<h3 id="产生原因">（2）产生原因</h3>
<p> 
在多个用户同时发起对同一个商品的下单请求时，先查询商品库存，再修改商品库存，会出现资源竞争问题，导致库存的最终结果出现异常。问题：
当商品A一共有库存15件，用户甲先下单10件，用户乙下单8件，这时候库存只能满足一个人下单成功，如果两个人同时提交，就出现了超卖的问题。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310094729.png" style="zoom:67%;" /></p>
<h3 id="解决方案-3">（3） 解决方案</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310095101.png" style="zoom: 60%;"></p>
<h4 id="悲观锁">【1】 悲观锁</h4>
<p> 
悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁</p>
<h4 id="乐观锁">【2】 乐观锁</h4>
<p> 会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1
，如果大1
，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1
，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas.</p>
<p> 乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5
是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 ==
内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值。 其中do
while
是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CAS一般是Java虚拟机在实现JUC的时候使用的，Java在UnSafe文件中编写了很多直接调用系统底层函数的功能方法，该类中就实现了CAS。</p>
<p>对于一般的超卖问题，主流方法还是使用乐观锁或者基于Redis的lua脚本进行解决</p>
</blockquote>
<h3 id="衍生改良">（4）衍生改良</h3>
<h4 id="问题">【1】问题</h4>
<p> 对于电商的超卖问题，如果只是简单让程序在扣减库存时，判断库存与操作前的数值是否一致，会导致其他大量并发操作失败。比如现在有100个进程打进来，查询到剩余的库存都是1000个，经过一顿操作后，现在要执行扣减库存的操作。此时我们采用了乐观锁进行更新，如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set 库存 = 库存 - 1 where id = 1 and 库存 = 1000</span><br></pre></td></tr></table></figure>
<p> 如果更新方式如上所述，那么程序在运行时，因为我们的程序并没有像CAS那样子实现自旋操作，所以这打进来的100个进程就只有一个会成功。这对用户的使用体验是非常不好的。</p>
<h4 id="解决">【2】解决</h4>
<p>我们需要改良一下数据库的执行操作，对于库存而言，只要库存大于0，我们就能卖。所以，没必要每个线程更新时都要确保当前库存跟操作前的库存一样，于是可以调整代码成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set 库存 = 库存 - 1 where id = 1 and 库存 &gt; 0</span><br></pre></td></tr></table></figure>
<h2 id="一人一单">3、一人一单</h2>
<h3 id="问题描述-1">（1）问题描述</h3>
<p>  很多时候有些商家要拿出一部分好用且贵重的产品来做促销引流，而将该物品进行低价售出，此时为了防止有人恶意低买高卖以及保证引流的效果，我们要保证一个用户只能买一次，也就一人一单.</p>
<h3 id="产生原因-1">（2）产生原因</h3>
<p> 一人一单的实现步骤是在原来下单逻辑的判断库存是否足够之后去查询数据库看是否该用户的是否已经存在订单，如果存在则不能下单成功，如果不存在则继续下单。</p>
<p> 由于该物品的特殊性，当开始秒杀时的并发量是极高的，这就会产生这样的问题，多个线程查询库存后判断该用户是否存已经存在订单时，此时这些线程都没有查询到订单信息说明该用户未下过单，让这些线程进行后续下单操作，但是在查询后有线程下单成功了，但是其他线程已经判断为未下过单，还在进行后续的下单操作，这就导致一个用户下单好几次</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310134922.png" style="zoom:50%;" /></p>
<h3 id="解决方案-4">（3）解决方案</h3>
<p>【1】解决一</p>
<p> 可以将上述的<strong>查询是否下过单与后续的库存扣减操作进行加锁</strong>。但在加锁时需要控制好锁的粒度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="comment">// 查询是否已经下单</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【2】问题一</p>
<p> 如果给方法加锁，对于每一个用户进程，进入程序时都需要进行锁竞争，这样对导致同一时间只有一个用户的进程可以执行操作，直接把并发执行变成了用户排队执行（串行执行）</p>
<p>【3】解决二</p>
<p> 一人一单的线程安全问题，其实是单个用户在同一时间触发了多个线程访问的问题，所以我们加锁的粒度可以针对单个用户进行加锁，那么，我们可以获取用户id，对用户id进行加锁。需要注意的时，用户id是一个String的字符串变量，如果我们直接使用userId.toString()
他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法。我们的代码就可以修改成如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactionl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 查询是否已经下单</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 扣减库存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【4】问题二</p>
<p>  上述加锁在很大程度上保证了一人一单的线程安全问题，但是还有一种情况，就是上述我们提到的线程1进行操作后把锁释放了，但是事务还没提交也就是数据库中已下单还没有订单信息，此时线程2获取到了锁，查询数据库中是否存在订单信息时没有查询到，于是又去进行了扣减库存操作，此时该用户一个人又下了多单。</p>
<p>【5】解决三</p>
<p>  上述问题产生的原因是，锁释放在事务提交之前。我们需要做的就是保证锁释放在事务提交之后，我们可以将加锁的位置进行修改，在调用该方法的地方进行加锁。修改后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询库存判断是否足够</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 查询是否已下单与扣减库存</span></span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        createVoucherOrder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Transactionl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询是否已经下单</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 扣减库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式问题">（4）分布式问题</h3>
<p> 上述悲观锁解决思路可以解决单机环境下的线程安全问题，但是在集群模式下就不行了，在不同的服务器进行部署该服务时，由于不同服务器有着不同的JVM，其线程锁的监视器也不同，所以加锁不能解决集群环境下的安全问题</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141541.png" style="zoom:50%;" /></p>
<h2 id="分布式锁">4、分布式锁</h2>
<h3 id="基本原理">（1）基本原理</h3>
<p> 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁需要具备多进程可见、互斥、高可用、高性能、安全性等特点。分布式锁的核心思想是让各个服务器使用同一把锁，只要使用的都是同一把锁，就能锁住线程，不让线程执行。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141854.png" style="zoom:50%;" /></p>
<h3 id="基本方法">（2）基本方法</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310142616.png" style="zoom:67%;" /></p>
<h3 id="实现代码">（3）实现代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁，并设置超时时间，防止死锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在问题">（4）存在问题</h3>
<h4 id="redis分布式锁误删">【1】Redis分布式锁误删</h4>
<p><strong>问题：</strong>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143057.png" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143251.png" style="zoom:50%;" /></p>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分布式锁原子性问题">【2】分布式锁原子性问题</h4>
<p><strong>问题：</strong>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143500.png" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>那就是使用Redis提供的Lua脚本，把<strong>判断锁和释放锁变成一个原子操作</strong></p>
<p>实现代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- &lt; unlick.lua &gt;</span></span><br><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分布式锁--redission">5、分布式锁--Redission</h2>
<h3 id="引言">（1）引言</h3>
<p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指
获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong>
如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144256.png" style="zoom:50%;" /></p>
<h3 id="什么是redission">（2）什么是Redission</h3>
<p> Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory
Data
Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144414.png" style="zoom: 80%;" /></p>
<h3 id="分布式锁redisson---可重入锁原理">（3）分布式锁Redisson--
可重入锁原理</h3>
<blockquote>
<p>ReentrantLock实现可重入锁原理：借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1
。</p>
<p>如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1
，直到减少成0 时，表示当前这把锁没有被人持有。</p>
</blockquote>
<p> 其实实现的原理跟ReentrantLock是一样的，都是借助计数变量，记录重入次数，实现可重入。实现原理大致是这样的：采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，最终的value记录的就是重入次数。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310145407.png" style="zoom:50%;" /></p>
<p><strong>代码实现：</strong>Redission底层实现可重入锁，也是借助了Lua脚本实现的，这样可以保证其执行的原子性。</p>
<p>——加锁实现代码：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310151049.png" style="zoom: 67%;" /></p>
<p>——释放锁实现代码：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311140348.png" style="zoom:67%;" /></p>
<h3 id="分布式锁ression-锁重试和watchdog机制">（4）分布式锁Ression ——
锁重试和WatchDog机制</h3>
<blockquote>
<p>获取锁失败，就会启动【锁重试】机制，不断询问锁是否释放。
获取锁成功，就会启动【WatchDog机制】，保证当前线程的任务执行完成。</p>
</blockquote>
<h4 id="原理">【1】原理</h4>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310165123.png" style="zoom:67%;" /></p>
<h4 id="源码解析">【2】源码解析</h4>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span></span><br></pre></td></tr></table></figure>
<p>waitTime –
获取锁的最大等待时间，<strong>不设置就只尝试获取锁一次，不会重试</strong>
leaseTime –
租约时间，约定使用锁时间，到期锁自动释放。不设定则会自动采用看门狗机制，自动续费
unit – 时间单位</p>
</blockquote>
<p>①
抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这线程已经抢锁完毕，或者可重入完毕。但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，可以发现有个while(
true) 再次进行tryAcquire进行抢锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② tryAcquire中有条件分支，如果 leaseTime 为
-1，则表示不设定租锁时间，也就是这把锁得借到当前进程执行完成后才能释放。那Redission是怎么实现的呢？Redission也是照常会去获取锁，有所区别的是，如果不设定租锁时间(leaseTime)，那么Redission
会启动看门狗机制，自动延长租锁时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设定了租锁时间，那就将其设置为借锁的时间，到期锁自动释放</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不设置，就启用看门狗机制</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                                         commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                                         TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 看门狗机制刷新租锁时间</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③
看门狗逻辑：因为【看门狗机制】锁的失效时间是30s，当10s之后，此时这个timeTask
就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约。那么假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式锁redission-mutilock原理">（5）分布式锁Redission ——
MutiLock原理</h3>
<blockquote>
<p>解决主从一致性问题！</p>
</blockquote>
<h4 id="原理-1">【1】原理</h4>
<p> 为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例。此时我们去写命令，写在主机上，
主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163322.png" style="zoom:50%;" /></p>
<p> 为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的，
这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163403.png" style="zoom:40%;" /></p>
<h4 id="源码解析-1">【2】源码解析</h4>
<p>① 创建联锁 multilock，就是将传入的lock用一个数组去存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;RLock&gt; locks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedissonMultiLock</span><span class="params">(RLock... locks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (locks.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Lock objects are not defined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.locks.addAll(Arrays.asList(locks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 获取锁时，会挨个访问每个节点，对每个节点，都获取一遍锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">// 若获取锁失败，则会释放掉已经获取的那些节点的锁</span></span><br><span class="line">    <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">        time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            unlockInner(acquiredLocks);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置了重试机制</span></span><br><span class="line">    <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        unlockInner(acquiredLocks);</span><br><span class="line">        <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有设置等待获取锁时间，表示只想获取一次，则获取失败的话直接退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是了等待时间</span></span><br><span class="line">        failedLocksLimit = failedLocksLimit();</span><br><span class="line">        acquiredLocks.clear();</span><br><span class="line">        <span class="comment">// reset iterator</span></span><br><span class="line">        <span class="comment">// 重试的时候重新开始</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">            iterator.previous();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        failedLocksLimit--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取锁成功</span></span><br><span class="line"><span class="comment">// 若设置了租锁时间，会对每一个节点上的锁，设置一个锁的有效时间</span></span><br><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(acquiredLocks.size());</span><br><span class="line">    <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span><br><span class="line">        RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">        futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class="line">        rFuture.syncUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="六redis消息队列">六、Redis消息队列</h1>
<h2 id="认识消息队列">1、 认识消息队列</h2>
<p>即存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310172219.png" /></p>
<p>使用队列的好处在于<strong>解耦</strong>：所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message
Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<h2 id="基于list实现消息队列">2、 基于List实现消息队列</h2>
<h3 id="实现原理-1">（1）实现原理</h3>
<p>消息队列（Message
Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者
RPUSH 结合
LPOP来实现。不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310213814.png" /></p>
<h3 id="优缺点">（2）优缺点</h3>
<p>优点：① 利用Redis存储，不受限于JVM内存上限； ②
基于Redis的持久化机制，数据安全性有保证； ③ 可以满足消息有序性</p>
<p>缺点：① 无法避免消息丢失； ②只支持单消费者</p>
<h2 id="基于pubsub的消息队列">3、基于PubSub的消息队列</h2>
<h3 id="实现原理-2">（1）实现原理</h3>
<p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p>SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg
：向一个频道发送消息 PSUBSCRIBE pattern[pattern]
：订阅与pattern格式匹配的所有频道</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310213954.png" /></p>
<h3 id="优缺点-1">（2）优缺点</h3>
<p>优点：采用发布订阅模型，支持多生产、多消费</p>
<p>缺点：① 不支持数据持久化； ② 无法避免消息丢失； ③
消息堆积有上限，超出时数据丢失</p>
<h2 id="基于stream的消息队列">4、基于Stream的消息队列</h2>
<p>Stream 是 Redis 5.0
引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311084806.png" /></p>
<p>例如</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085207.png" /></p>
<p>读取消息的方式之一：XREAD</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085146.png" /></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085241.png" /></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085304.png" /></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<figure>
<img
src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311085324492.png"
alt="image-20250311085324492" />
<figcaption aria-hidden="true">image-20250311085324492</figcaption>
</figure>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h2
id="基于stream的消息队列消费者组">5、基于Stream的消息队列—消费者组</h2>
<p>消费者组（Consumer
Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311091741.png" /></p>
<p>创建消费者组：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311091835.png" /></p>
<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其他命令：</p>
<p><strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>
<p><strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>
<p><strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>
<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：
<ul>
<li>"&gt;"：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul></li>
</ul>
<p>消费者监听消息的基本思路：</p>
<p><img src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311092621147.png" alt="image-20250311092621147" style="zoom:50%;" /></p>
<p>列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<h2 id="对比">6、对比</h2>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311092658.png" /></p>
<h1 id="七点赞收藏和关注">七、点赞、收藏和关注</h1>
<p>实现方式比较简单，都是通过利用Redis的set集合判断是否已经点赞、或者已经收藏、或者已经关注</p>
<p>这里贴一个demo代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关注实现</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">followUser</span><span class="params">(FollowAddVO addVO)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">channel</span> <span class="operator">=</span> addVO.getChannel();</span><br><span class="line">    <span class="comment">// 构造redis的key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">currentId</span> <span class="operator">=</span> ThreadLocalUtil.getCurrentId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FollowConstant.followKey + addVO.getUid();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">zScore</span> <span class="operator">=</span> redisUtils.zScore(key, currentId);</span><br><span class="line">    <span class="comment">// 先判断能不能关注</span></span><br><span class="line">    <span class="keyword">if</span> ((Objects.nonNull(zScore) &amp;&amp; CollectionConstant.OperateEnum.ON_COLL.getCode().equals(channel))</span><br><span class="line">        || (Objects.isNull(zScore) &amp;&amp; CollectionConstant.OperateEnum.DOWN_COLL.getCode().equals(addVO.getChannel()))) &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CollectionConstant.OperateEnum.ON_COLL.getCode().equals(channel)) &#123;</span><br><span class="line">        <span class="comment">// 实现关注逻辑，并将关注的关系加入到redis中</span></span><br><span class="line">        <span class="keyword">return</span> redisUtils.zAdd(key, currentId, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消关注</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionConstant.OperateEnum.DOWN_COLL.getCode().equals(addVO.getChannel())) &#123;</span><br><span class="line">        <span class="comment">// 实现取消关注的数据库逻辑，并将redis中的关注关系删除</span></span><br><span class="line">        <span class="keyword">return</span> redisUtils.zRemove(key, currentId) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八geo数据结构计算距离">八、GEO数据结构计算距离</h1>
<blockquote>
<p>使用Redis的GEO数据机构进行统计</p>
</blockquote>
<h2 id="geo数据结构基本用法">1、 GEO数据结构基本用法</h2>
<p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。
6.2.新功能</li>
</ul>
<h2 id="存入redis中的数据结构定义">2、存入Redis中的数据结构定义</h2>
<p> GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p> 但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105501.png" style="zoom:50%;" /></p>
<h1 id="九redis实现签到功能">九、Redis实现签到功能</h1>
<blockquote>
<p>使用Redis的BitMap实现</p>
</blockquote>
<h2 id="bitmap数据机构基本用法">1、BitMap数据机构基本用法</h2>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD
：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h2 id="实现原理-3">2、实现原理</h2>
<p> 我们按月来统计用户签到信息，签到记录为1，未签到则记录为0。把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示。Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是
2^32个bit位。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105928.png" /></p>
<h2 id="功能点实现">3、功能点实现</h2>
<p><strong>问题1：</strong>什么叫做连续签到天数？
从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311110039.png" /></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1
才是1，其他数字都是0
，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<h2
id="关于使用bitmap来解决缓存穿透的方案">4、关于使用BitMap来解决缓存穿透的方案</h2>
<p>实现原理跟布隆过滤器是基本一样的，都是通过Hash，将物料的主键id映射成位图能够记录的idx，然后在位图中标识出来。等要判断是当前查询主键id是否存在时，再将当前主键id进行Hash，看是否在位图中被标注。若被标注，则可以访问，若没有，则拒绝访问。布隆过滤器的区别主要是，可能布隆过滤器会多用几个Hash函数。</p>
<h1 id="十uv统计">十、UV统计</h1>
<h2 id="uv和pv">1、UV和PV</h2>
<ul>
<li>UV：全称Unique
Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page
View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<h2 id="hyperloglog-算法原理">2、HyperLogLog 算法原理</h2>
<p><a
href="https://juejin.cn/post/6844903785744056333#heading-0">参考文章</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>【力扣】热题100</title>
    <url>/2025/03/02/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E7%83%AD%E9%A2%98100/</url>
    <content><![CDATA[<blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一力扣热题100">一、力扣热题100</h1>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2025/02/24/Java/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一基础知识复习">一、基础知识复习</h1>
<h2 id="从start一个线程说起">1、 从start一个线程说起</h2>
<p>​ Java的线程启动是调用了线程变量start函数，而在源码中 start
函数调用的是 start0() （native修饰）的系统函数，start0
的系统函数是结合了Java的JVM和主机系统的线程函数是实现的。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309202911.png" style="zoom:50%;" /></p>
<h2 id="java多线程相关概念">2、Java多线程相关概念</h2>
<h3 id="概念">（1）概念</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309202950.png" style="zoom: 67%;" /></p>
<h3
id="java线程分为用户线程和守护线程">（2）Java线程分为用户线程和守护线程</h3>
<ol type="1">
<li><p>一般情况下，不做任何配置都是用户线程。</p></li>
<li><p>用户线程（User Thread）
是系统的工作线程，它会完成这个程序需要完成的业务操作。</p></li>
<li><p>守护线程（Daemon
Thread）是一种特殊的线程，是为其它线程服务的，在后台默默完成一些系统性的服务，比如垃圾回收线程就是一种典型的守护线程。当系统只剩下守护线程时，Java虚拟机会自动退出。</p></li>
</ol>
<h3 id="daemon属性">（3）Daemon属性</h3>
<p>线程中会存在Daemon属性，调用isDaemon函数可以判断当前线程是否为守护线程，调用setDaemon可以设置当前线程为守护线程。</p>
<h3 id="小总结">（4）小总结</h3>
<p>​
如果用户线程全部结束意味着程序需要完成的业务操作已经结束了，守护线程随着JVM一同结束工作。setDaemon(true)方法必须在start()之前设置，否则报IIIegalThreadStateException异常</p>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程正在运行~~~~&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().isDaemon()? <span class="string">&quot;守护线程&quot;</span>:<span class="string">&quot;用户线程&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 系统线程正在运行~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="二completablefuture">二、CompletableFuture</h1>
<h2 id="future理论知识复习">1、Future理论知识复习</h2>
<p>​
Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p>
<p>多线程需要满足三个特点：多线程/有返回/异步任务</p>
<h3 id="futuretask实现类">（1）FutureTask实现类</h3>
<p>​
Future实现了RunnableFutur接口，而RunnableFutur又继承了Runnable和Future接口，满足了多线程和异步任务的特性，同时采用构造注入的方式，使得FutureTask实现类具备有返回的特性，只要这个实现类构造注入Callable就能有返回值。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203019.png" style="zoom:67%;" /></p>
<p>代码示范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Mythread</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;come in call ~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="future编码实战和优缺点">（2）Future编码实战和优缺点</h3>
<ol type="1">
<li>优点：
<ul>
<li>future + 线程池异步多线程任务配合，能显著提高程序的执行效率。</li>
</ul></li>
<li>缺点：
<ul>
<li>get方法阻塞</li>
<li>isDone() 轮询更容易导致CPU中断。
isDone函数可以返回当前线程是否执行完成</li>
</ul></li>
</ol>
<h2 id="completablefuture">2、CompletableFuture</h2>
<h3
id="completablefuture对future的改进">（1）CompletableFuture对Future的改进</h3>
<p>主要内容：CompletableFuture提供了一种观察者模式类似的机制，可以让任务完成后通知监听的一方</p>
<ol type="1">
<li>继承关系</li>
</ol>
<p>CompletableFuture继承了Future和CompletionStage接口，所以Future拥有的功能，它也有。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203030.png" style="zoom:80%;" /></p>
<ol start="2" type="1">
<li>CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。有点类似Linux系统的管道分隔符传参数</li>
<li>CompletableFuture不需要再另外创造新的线程变量或者线程池执行异步任务。FutureTask并没有内置线程池，所以在进行声明后，需要使用线程对象去执行这个异步编程，但是CompletableFuture在没有为它传入线程池时，它会调用自身内置的ForkJoinPool.commonPool()线程池完成异步任务，但是需要注意的是，ForkJoinPool执行任务的线程是守护线程，所以在main函数执行结束时，还没有完成的线程会被强制中断。对于这种情况，解决方法是，使用自己的线程池，在程序末尾，添加线程池关闭动作。</li>
</ol>
<h3
id="completablefuture之四大静态方法">（2）CompletableFuture之四大静态方法</h3>
<ol type="1">
<li><p>runAsync 无返回值</p>
<ol type="1">
<li>```java public static CompletableFuture<Void> runAsync(Runnable
runnable, Executor executor) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```java</span><br><span class="line">   public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>supplyAsync 有返回值</p>
<pre><code>1. ```java
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,
                                                   Executor executor)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	2. ```java</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li>
</ol>
<p>如果没有传入线程池，那么会默认使用ForkJoinPool.commonPool()
作为它的线程池执行异步代码。如果调用了需要传入线程池的构造函数，则会使用我们传入的线程池来执行对应的异步代码。</p>
<p>demo代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName() + &quot; ========= &quot;);</span></span><br><span class="line"><span class="comment">//            try &#123;  TimeUnit.SECONDS.sleep(2);  &#125; catch (InterruptedException e) &#123;  throw new RuntimeException(e);  &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println(completableFuture.get());</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ========= &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;今天是个好日子！&quot;</span>;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3
id="completablefuture之通用异步编程">（3）CompletableFuture之通用异步编程</h3>
<p>​
会有返回值，并且可以分阶段完成，为了调用whenComplete监听线程完成，异步任务完成后将调用该方法，该方法可以使用lambda函数获取异步任务的返回值。</p>
<p>优点：</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法</li>
<li>主线程设置好回调后，不需要关心异步任务的执行，异步任务之间可以顺序执行</li>
<li>异步任务出错时，会自动回调某个对象的方法</li>
</ul>
<p>demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 使用自己的线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结束啦，计算后最终的结果是：&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;, executorService).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;终于计算结束了？ 恭喜啦&quot;</span>);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;异常情况是&quot;</span> + e.getCause() + <span class="string">&quot;异常信息为 ： &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展">（4）拓展</h3>
<ol type="1">
<li>通用函数接口</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;">函数式接口名称</th>
<th style="text-align: center;">方法名称</th>
<th style="text-align: center;">参数</th>
<th style="text-align: center;">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Runnable</td>
<td style="text-align: center;">run</td>
<td style="text-align: center;">无参数</td>
<td style="text-align: center;">无返回值</td>
</tr>
<tr>
<td style="text-align: center;">Function</td>
<td style="text-align: center;">apply</td>
<td style="text-align: center;">1个参数</td>
<td style="text-align: center;">有返回值</td>
</tr>
<tr>
<td style="text-align: center;">Consume</td>
<td style="text-align: center;">accept</td>
<td style="text-align: center;">1个参数</td>
<td style="text-align: center;">无返回值</td>
</tr>
<tr>
<td style="text-align: center;">Supplier</td>
<td style="text-align: center;">get</td>
<td style="text-align: center;">没有参数</td>
<td style="text-align: center;">有返回值</td>
</tr>
<tr>
<td style="text-align: center;">BiSummer</td>
<td style="text-align: center;">accept</td>
<td style="text-align: center;">2个参数</td>
<td style="text-align: center;">没有返回值</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li><p>get函数和join函数的区别</p>
<p>get函数会抛出异常，join函数不会抛出异常</p></li>
</ol>
<h2 id="实际案例">3、实际案例</h2>
<p>电商获取对应价格案例，使用stream和chain还有CompletableFuture进行实现</p>
<p>demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureMallDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;NetMall&gt; netMallList = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;京东&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;淘宝&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;当当&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; netMallList, String productName, ExecutorService executorService)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> netMallList.stream().map(netMall -&gt; CompletableFuture.supplyAsync(() -&gt;</span><br><span class="line">                String.format(productName + <span class="string">&quot; in %s price is %.2f &quot;</span>, netMall.getNetMallName(), netMall.calcPrice(productName), executorService)</span><br><span class="line">        )).collect(Collectors.toList()).stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; prices = getPriceByCompletableFuture(netMallList, <span class="string">&quot;mysql&quot;</span>, executorService);</span><br><span class="line">        <span class="keyword">for</span> (String price : prices) &#123;</span><br><span class="line">            System.out.println(price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="completablefuture常用方法">4、 CompletableFuture常用方法</h2>
<h3 id="获得结果和触发计算">（1）获得结果和触发计算</h3>
<ol type="1">
<li>获得结果
<ol type="1">
<li>get 不见不散</li>
<li>定时get 过时不候</li>
<li>join 不见不散但不抛异常</li>
<li>getNew 没有计算完成，给一个提前设定的结果</li>
</ol></li>
<li>主动触发计算
<ol type="1">
<li>complete 是否打算get方法，立即返回括号值</li>
</ol></li>
</ol>
<h3 id="对计算结果进行处理">（2）对计算结果进行处理</h3>
<ol type="1">
<li><p>thenApply</p>
<p>计算结果存在依赖关系，这两个线程串行化</p>
<p>异常相关：由于存在依赖（当前步错，不走下一步），当前步骤有异常的话就叫停</p></li>
<li><p>handle</p>
<p>计算结果存在依赖关系，这两个线程串行化</p>
<p>异常相关：有异常也可以往下一步走，根据带的异常参数可以进一步处理</p></li>
</ol>
<h3 id="对计算结果进行消费">（3）对计算结果进行消费</h3>
<ol type="1">
<li><p>接收任务的处理结果，并消费处理，无返回结果。</p></li>
<li><p>thenAccept 可以接收上一步的结果，但是不用返回</p></li>
<li><p>对比补充</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203046.png" style="zoom:80%;" /></p></li>
</ol>
<h3 id="对计算速度进行选用">（4）对计算速度进行选用</h3>
<p>通过调用applyToEither()
函数比较两个线程之间哪一个线程的执行所需要的时间更少，得到的返回结果就是那个用时比较少的线程所返回的结果。</p>
<h3 id="对计算结果进行合并">（5）对计算结果进行合并</h3>
<p>​
两个CompletionStage任务都完成后，最终能把两个任务的结果一起交给thenCombine进行处理，先完成等后完成，一起完成后再进行合并。</p>
<h2 id="completablefuture和线程池">5、CompletableFuture和线程池</h2>
<ol type="1">
<li><p>没有传入自定义线程池，都用默认线程池ForkJoinPool</p></li>
<li><p>传入了一个自定义线程池</p>
<p>如果执行第一个任务的时候，传入了一个自定义线程池</p>
<p>调用thenRun方法执行第二个任务时，则第二个任务和第一个任务是共同使用同一个线程池</p>
<p>调用thenRunAsync执行第二个任务时，则第一个任务使用的是自定义线程池，第二个任务使用的是ForkJoin线程池</p></li>
<li><p>备注</p>
<p>有可能处理太快，系统优化切换原则，直接使用main线程处理</p></li>
</ol>
<p>其他如：thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，他们之间的区别也是同理。</p>
<h1 id="三java的锁事">三、Java的“锁”事</h1>
<h2 id="乐观锁和悲观锁">1、 乐观锁和悲观锁</h2>
<h3 id="悲观锁">（1）悲观锁</h3>
<p>synchronized关键字和Lock的实现类都是悲观锁，认为当前线程在使用数据时，一定有别的线程来修改数据，因此在获取数据时会先加锁，确保数据不会被别的线程修改</p>
<p>应用：</p>
<ul>
<li>适合写操作多的场景，先加锁可以保证写操作时数据正确</li>
<li>显式的锁定之后再操作同步资源</li>
<li>狼性锁</li>
</ul>
<h3 id="悲观锁-1">（2）悲观锁</h3>
<p>认为当前线程在使用数据时不会有其他线程修改数据或资源，所以不加锁，Java是通过使用无锁编程来实现，只在更新时判断有没有别的线程更新过数据。若数据没有被更新，则直接写入；若数据被更新了，则根据不同的实现方式执行不同的操作，比如放弃修改和重试抢锁等</p>
<p>实现方法：</p>
<ol type="1">
<li>版本号机制Vision</li>
<li>最常采用的是CAS算法，Java原子类中的递增操作就是通过CAS自旋来实现的</li>
</ol>
<p>应用：</p>
<ul>
<li>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
<li>佛系锁</li>
</ul>
<h2 id="八种加锁情况">2、八种加锁情况</h2>
<p>（1）【1-2】一个类存在多个synchronized方法，多线程调用同一对象的不同synchronized方法</p>
<p>一个对象里面如果有多个synchronized方法，某一时刻内，只要一个线程去调用其中的一个synchronized方法了，其他线程都只能等待。简而言之，只能有唯一一个线程去访问这些synchronized方法。锁的是当前对象this，被锁定后，其他线程都不需要进入到当前对象的其他的synchronized方法。</p>
<p>（2）【3-4】一个类存在synchronized方法，也存在非synchronized方法</p>
<p>加个普通方法后发现同步锁失效；换成两个对象，不是同一把锁，情况立刻变化。</p>
<p>（3）【5-6】把synchronized方法都换成静态方法</p>
<p>三种synchronized锁的内容有一些差别：</p>
<ul>
<li>对象锁：对于普通同步方法，锁的是当前实例对象，通常指this，所有的普通同步方法用的都是同一把锁--》实例对象本身</li>
<li>类锁：对于静态同步方法，锁的是当前类的class对象，锁的是唯一模板</li>
<li>对于同步方法块，锁的是synchronized括号内的对象</li>
</ul>
<p>（4 ）【7-8】 静态锁和普通锁不会有竞争关系</p>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，正常退出或抛出异常时必须释放锁。</p>
<p>所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身，本类this。即如果一个实例对象的普通同步方法获得锁后，该实例对象的其他普通同步方法必须等待获得锁的方法释放锁后才能获得锁。</p>
<p>所有的静态同步方法用的也是同一把锁——类对象本身，即唯一模板class。具体实例对象this和唯一模板class，这两把锁时两个不同的对象，所有静态同步方法和普通同步方法之间不会有竞争关系。但是一旦一个静态同步方法获取锁后，其他静态同步方法都必须等待该方法释放锁后才能获得锁</p>
<h2 id="synchronized三种应用方式">3、synchronized三种应用方式</h2>
<h3
id="种锁的案例实际体现在3个地方">（1）8种锁的案例实际体现在3个地方</h3>
<ul>
<li>作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>作用于代码块，对括号里配置的对象加锁</li>
<li>作用于静态方法，当前类对象加锁，进去同步代码前要获得当前类对象的锁</li>
</ul>
<h3
id="字节码角度分析synchronized实现">（2）字节码角度分析synchronized实现</h3>
<ul>
<li><p>synchronized同步代码块</p>
<p>实现使用的时monitorenter和monitorexit指令</p></li>
<li><p>synchronized普通同步方法</p>
<p>调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会将先持有monitor锁，然后在执行方法，最后在方法完成（无论是否正常完成）时释放monitor</p></li>
<li><p>synchronized静态同步方法</p>
<p>ACC_STATIC，ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法</p></li>
</ul>
<h3 id="反编译synchronized锁">（3）反编译synchronized锁</h3>
<p>为什么任何一个对象都可以成为一个锁？每个对象在创建时都会初始化一个ObjectMonitor对象。ObjectMonitor里面可以记录占有锁的线程，阻塞队列，重入次数等信息</p>
<h2 id="公平锁和非公平锁">4、公平锁和非公平锁</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th>锁类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平锁</td>
<td>指多个线程按照申请锁的顺序来获取锁，Lock lock = new
ReentrantLock(true)</td>
</tr>
<tr>
<td>非公平锁</td>
<td>指多个线程获得锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获得锁，在高并发环境下造成优先级翻转或者饥饿的状态，Lock
lock = new ReentrantLock(false)</td>
</tr>
</tbody>
</table>
<p>非公平优点：</p>
<ul>
<li>非公平锁能更充分的利用时间片，尽量减少CPU空闲状态时间</li>
<li>当使用非公平锁时，1个线程请求锁获取同步状态，然后释放同步状态，刚释放锁的线程在此刻再次获取锁的概率会变得很大，这样可以减少线程的开销。</li>
</ul>
<p>应用：</p>
<p>为了更高吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁。</p>
<h2 id="可重入锁递归锁">5、可重入锁（递归锁）</h2>
<h3 id="概念-1">（1）概念</h3>
<p>​
是指在同一个线程在外层方法获取锁的时候，再进入线程的内层方法会自动获取锁（前提，锁对象是同一个对象），不会因为之前已经获取过还没释放而阻塞。简而言之，就是自己可以获取自己的内部锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203102.png" style="zoom:80%;" /></p>
<p>在Java中ReentrantLock和synchronized都是可重入锁，优点是可以一定程度上避免死锁。</p>
<h3 id="可重入锁种类">（2）可重入锁种类</h3>
<ul>
<li><p>隐式锁（即synchronized关键字修饰的锁）默认是可重入锁</p>
<p>一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</p></li>
<li><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是第一层！&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是第二层！&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;这是第三层！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是第一次进入！&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是第二次进入！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized的重入实现机制</p>
<p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。当执行monitorenter时，如果目标锁对象的计数器为0，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1</p>
<p>在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitorexit时，Java虚拟机则需要将锁对象的计数器减1.计数器为0代表锁已被释放。</p>
<h2 id="死锁及排查">6、死锁及排查</h2>
<h3 id="概念-2">（1）概念</h3>
<p>​
是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203113.png" style="zoom:67%;" /></p>
<p>死锁实现Demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lockA.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我线程A已经启动了，让我运行几秒钟&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">            lockB.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我需要B锁的支持！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lockB.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockA.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        lockB.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我线程B也启动了！让我运行几秒钟！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">3</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">            lockA.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我需要A锁的支持！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lockA.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockB.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    threadA.start();  threadB.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁产生原因">（2）死锁产生原因</h3>
<ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ul>
<h3 id="排查死锁">（3）排查死锁</h3>
<p>使用命令，显示当前所有Java进程pid的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">17540 </span><br><span class="line">1500 com.ych.lock.DeadLockDemo</span><br><span class="line">25180 jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line">26284 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure>
<p>得到我们想要查询的目标运行程序的pid之后，再使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jstack 1500</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
<p>即可排除出是哪个程序出现了死锁。</p>
<p>另外也可以使用 jconsole，调出Java性能分析器，分析是否存在死锁。</p>
<h1 id="四locksupport与线程中断">四、LockSupport与线程中断</h1>
<h2 id="线程中断">1、线程中断</h2>
<h3 id="概念-3">（1）概念</h3>
<p>线程中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现，若要中断一个线程，需要手动调用interrupt方法，该方法也仅仅是将该线程对象的中断标识设成true</p>
<h3 id="中断的三大api方法说明">（2）中断的三大API方法说明</h3>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr>
<th>中断函数</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void interrupt()</td>
<td>// Just to set the interrupt flag
仅仅设置线程中断状态为true，发起一个协商而不会停止线程</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断线程是否被中断，并清除当前中断状态。
返回当前线程的中断状态，并将当前线程的中断状态重新设置为false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被中断（通过检查中断标志位）</td>
</tr>
</tbody>
</table>
<h2 id="中断机制考点">2、中断机制考点</h2>
<h3 id="如何停止中断运行中的线程">（1）如何停止中断运行中的线程</h3>
<ul>
<li>通过一个volatile变量来实现</li>
<li>通过AtomicBoolean</li>
<li>通过Thread类自带的中断api实例方法实现
<ul>
<li>再需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。</li>
</ul></li>
</ul>
<p>实现demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3_interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是t1，我现在没有被中断~~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被中断了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是t2 我是来中断t1的&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2_atomicBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是t1，我现在没有被中断~~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(atomicBoolean.get())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被中断了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是t2 我是来中断t1的&quot;</span>);</span><br><span class="line">        atomicBoolean.set(<span class="literal">true</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1_volatile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我跳出来了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 ------------&gt; 我没有被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="关于interruptedexception异常处理方式">（2）关于InterruptedException异常处理方式</h3>
<p>​
我们需要注意的是，当当前线程处于阻塞状态时（如wait或sleep），如果有其他线程调用了当前线程的interrupt函数，尝试更改当前线程的中断标识，会导致当前线程抛出InterruptedException异常，然后设置自己的中断标识为false。简而言之：<strong>当阻塞方法收到中断请求的时候就会抛出InterruptedException异常</strong>。</p>
<p>结论：interrupt方法本质上不会进行线程的终止操作的，它不过是改变了线程的中断状态。而改变了此状态带来的影响是，部分可中断的线程方法（比如Object.wait,
Thread.sleep）会定期执行isInterrupted方法，检测到此变化，JVM会将线程的中断标志重新设置为false，随后会停止阻塞并抛出InterruptedException异常。总之，interrupt的作用就是需要用户自己去监视线程的状态位并做处理。但InterruptedException异常的抛出并不是意味着线程必须得终止，它只是提醒当前线程有中断操作发生了，接下来怎么处理完全取决于线程本身，一般有3种处理方式：</p>
<ol type="1">
<li><p>"吞并"异常，当做什么事都没发生过。</p></li>
<li><p>继续往外抛出异常。</p></li>
<li><p>其它方式处理异常(其它处理异常的方式就有很多种了，停止当前线程或者输出异常信息等等)。</p></li>
</ol>
<h3 id="静态方法-thread.interrupted">（3）静态方法
Thread.interrupted()</h3>
<p>方法实际功能：</p>
<ol type="1">
<li>返回当前线程的中断状态，测试当前线程是否被中断</li>
<li>将当前线程的中断状态清零并重置为false</li>
</ol>
<h2 id="locksupport">3、 LockSupport</h2>
<h3 id="概念-4">（1）概念</h3>
<p>是一个线程阻塞的工具类，所有方法都是静态方法，用于创建锁和其他同步类的基本线程阻塞原语。可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。</p>
<h3 id="线程等待唤醒机制">（2）线程等待唤醒机制</h3>
<h4 id="种让线程等待和唤醒的方法">【1】3种让线程等待和唤醒的方法</h4>
<ul>
<li>方法一：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li>
<li>方法二：使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程</li>
<li>方法三：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li>
</ul>
<h4
id="object类中的wait和notify方法实现线程等待和唤醒">【2】Object类中的wait和notify方法实现线程等待和唤醒</h4>
<ul>
<li><p>wait和notify方法必须要在同步块或者方法里面，且成对出现使用</p></li>
<li><p>先wait后notify，顺序不能颠倒</p></li>
</ul>
<h4
id="condition接口中的await和signal方法实现线程的等待和唤醒">【3】Condition接口中的await和signal方法实现线程的等待和唤醒</h4>
<ul>
<li>Condition中的线程等待和唤醒方法，需要先获取锁</li>
<li>一定要先await后signal，顺序不能颠倒</li>
</ul>
<p>​
其实上面两种情况都在说明一件事情，就是如果你想对一个线程进行阻塞操作，如wait操作，就必须先获得当前这个线程锁的权限，也就是Object的wait和notify都需要在同步块或同步方法中；Condition的await和signal也需要在lock.lock()和
lock.unlock()之间。另外等待和唤醒的顺序不能颠倒</p>
<h4
id="locksupport类中的park等待和unpark唤醒">【4】LockSupport类中的park等待和unpark唤醒</h4>
<ul>
<li>LockSupport类使用了一种名为Permit（许可证）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可(permit)，但与Semaphore不同的是，<strong>许可的累加上限是1</strong></li>
<li>LockSupport
和每个使用它的线程都有一个许可关联。每个线程都有一个相关的permit，permit最多只有一个，重复调用unpark也不会积累凭证</li>
</ul>
<h1 id="五java内存模型-jmm">五、Java内存模型 JMM</h1>
<h2 id="计算机硬件存储体系">1、计算机硬件存储体系</h2>
<p>硬盘 ---&gt; 内存 ----&gt; 高速缓存 ----&gt; CPU</p>
<h2 id="java的内存模型">2、Java的内存模型</h2>
<p>​
本身是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范，通过这组规范定义了程序中（尤其是多线程）每个变量的读写访问方式并决定一个线程对共享变量的写入合适以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</p>
<h2 id="jmm规范下的三大特性">3、JMM规范下的三大特性</h2>
<h3 id="可见性">（1）可见性</h3>
<p>​
指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有变量都存储在主内存中。</p>
<p>​
系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能够直接读写主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要通过主内存来完成。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203128.png" style="zoom:80%;" /></p>
<h3 id="原子性">（2）原子性</h3>
<p>指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰</p>
<h3 id="有序性">（3）有序性</h3>
<p>对于一个线程的执行代码而言，为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p>
<h2 id="多线程对变量的读写过程">4、多线程对变量的读写过程</h2>
<p>​
线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本的拷贝。</p>
<p>总结：</p>
<ul>
<li>定义的所有共享变量都储存在物理主内存中</li>
<li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li>
<li>线程对共享变量所有的操作都必须现在自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）</li>
<li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）</li>
</ul>
<h2 id="多线程先行发生原则-happens-before">5、多线程先行发生原则
happens-before</h2>
<h3 id="定义">（1）定义</h3>
<p>​
在JMM中，如果一个操作执行的结果需要对另一个操作可加性或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则。逻辑上的先后关系。本质上是一种可见性。</p>
<h3 id="总原则">（2）总原则</h3>
<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见。而且第一个操作的执行顺序排在第二个操作之前</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则指定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来<strong>执行的结果一致</strong>，那么这种重排序<strong>并不非法</strong>。</li>
</ul>
<h3 id="条原则">（3）8条原则</h3>
<h4 id="次序规则">【1】次序规则</h4>
<p>一个线程内，按照代码顺序，卸载前面的操作先行发生于写在后面的操作</p>
<h4 id="锁定规则">【2】锁定规则</h4>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作</p>
<h4 id="volatile变量规则">【3】volatile变量规则</h4>
<p>对一个volatile变量的写操作，先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样指时间上的先后。</p>
<h4 id="传递规则">【4】传递规则</h4>
<p>如果操作A先发生于操作B，操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
<h4 id="线程启动规则thread-start-rule">【5】线程启动规则（Thread Start
Rule）</h4>
<p>Thread对象的start() 方法先行发生于此线程的每一个动作。</p>
<h4 id="线程中断规则thread-interruption-rule">【6】线程中断规则（Thread
Interruption Rule）</h4>
<p>对于线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。简而言之，要先调用interrupt()方法设置过中断标志位，才能检测到中断发生</p>
<h4 id="线程终止规则thread-termination-rule">【7】线程终止规则（Thread
Termination Rule）</h4>
<p>线程中的所有操作都先行发生于对此线程的终止检测，可以通过调用isAlive()等手段检测线程是否已经终止执行。</p>
<h4 id="对象终结原则finalizer-rule">【8】对象终结原则（Finalizer
Rule）</h4>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</p>
<h1 id="六volatile与jmm">六、volatile与JMM</h1>
<h2
id="被volatile修饰的变量的两大特点">1、被volatile修饰的变量的两大特点</h2>
<h3 id="特点">（1）特点</h3>
<ul>
<li>可见性</li>
<li>有序性</li>
</ul>
<h3 id="volatile的内存语义">（2）volatile的内存语义</h3>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新回主内存</strong>中</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</li>
<li>所有volatile的写内存语义是直接刷新到主内存中，读内存的语义是直接从主内存中读取。</li>
</ul>
<h2 id="内存屏障">2、内存屏障</h2>
<h3 id="栗子">（1）栗子</h3>
<ul>
<li>可见：写完后立即刷新会主内存，并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见</li>
<li>有序性：存在数据依赖关系，禁止重排序</li>
</ul>
<h3 id="概念-5">（2）概念</h3>
<p>​
内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作）。避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成VM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性（禁重排），但<strong>volatile无法保证原子性</strong>。</p>
<ul>
<li>内存屏障<strong>之前</strong>的所有<strong>写操作</strong>都要会<strong>写到主内存</strong></li>
<li>内存屏障<strong>之后</strong>的所有<strong>读操作</strong>都能获得<strong>内存屏障之前的所有写操作的最新结果</strong>（实现可见性）</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203143.png" style="zoom:67%;" /></p>
<h4 id="写屏障store-memory-barrier">【1】写屏障（Store Memory
Barrier）</h4>
<p>告诉处理器在写屏障之前将所有存储在缓存（store
bufferes）中的数据同步到主内存。即看到Store屏障指令，必须把该指令之前所有写入指令执行完毕才能继续往下执行</p>
<h4 id="读屏障load-memory-barrier">【2】读屏障（Load Memory
Barrier）</h4>
<p>处理器在读屏障之后的读操作，都在读屏障之后执行，即在Load屏障指令之后就能保证后面的读取数据指令一定能够读取到最新的数据</p>
<h3 id="内存屏障的分类">（3）内存屏障的分类</h3>
<figure>
<img
src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250226100314936.png"
alt="image-20250226100314936" />
<figcaption aria-hidden="true">image-20250226100314936</figcaption>
</figure>
<h2
id="happens-before之volatile变量规则">3、happens-before之volatile变量规则</h2>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 27%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr>
<th>第一个操作</th>
<th>第二个操作：普通读写</th>
<th>第二个操作：volatile读</th>
<th>第二个操作：volatile写</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通读写</td>
<td>可以重排</td>
<td>可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile读</td>
<td>不可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile写</td>
<td>可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
</tbody>
</table>
<h2 id="内存屏障插入策略的4种规则">4、内存屏障插入策略的4种规则</h2>
<h3 id="读屏障">（1）读屏障</h3>
<ul>
<li>在每一个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每一个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203153.png" style="zoom:67%;" /></p>
<h3 id="写屏障">（2）写屏障</h3>
<ul>
<li>在每一个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每一个volatile写操作的后面插入一个StoreLoad屏障</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203204.png" style="zoom:80%;" /></p>
<h2 id="volatile特性">5、volatile特性</h2>
<h3 id="保证可见性">（1）保证可见性</h3>
<p>代码demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不加volatile会陷入死循环</span></span><br><span class="line"><span class="comment">// 需要注意的是while循环里面不要添加 print 语句， 因为Java的print语句加了synchronized，修改变量也会导致线程终止</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被终止了！&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 我终止了 &quot;</span> + thread.getName() + <span class="string">&quot; 的运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile变量读写过程</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203221.png" /></p>
<p>read：作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p>
<p>load：作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p>
<p>use：作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p>
<p>assign：作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作。</p>
<p>store：作用于工作内存，将赋值完毕的工作变量的值写回给主内存</p>
<p>write：作用于主内存，将store传输过来的变量赋值给主内存中的变量</p>
<p>由于上述6条只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以JVM提供了另外两个原子指令</p>
<p>lock：作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，只是锁了写变量的过程。</p>
<p>unlock：作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p>
<h3 id="没有原子性">（2）没有原子性</h3>
<p>对于volatile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅是数据加载时是最新的，但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，主内存volatile修饰变量发生修改，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即<strong>各线程私有内存和主内存公共内存中变量不同步</strong>，进而导致数据不一致，由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，<strong>对于多线程修改主内存共享变量的场景必须使用加锁同步。</strong></p>
<p>demo代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileNoAutomicDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; ++j) &#123;</span><br><span class="line">                    myNumber.plusOneToNum();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;  TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  &#125;</span><br><span class="line">        System.out.println(myNumber.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">plusOneToNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令禁重排">（3）指令禁重排</h3>
<p>volatile的底层实现是通过内存屏障</p>
<h3 id="结论">（4）结论</h3>
<p>​ volatile变量不适合参与到依赖当前值的运算，如 i = i+1; i++; 之类
。通常volatile用作保存某个状态的Boolean值或 int 值。</p>
<p>​
由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只能单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<h2 id="使用volatile">6、使用volatile</h2>
<ul>
<li>单一赋值可以使用volatile，含复合运算赋值不可以（i++之类）</li>
<li>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件</li>
<li>当读远多于写，结合使用内部锁和volatile变量减少同步的开销</li>
</ul>
<h1 id="七cascompare-and-swap">七、CAS（compare and swap）</h1>
<h2 id="概念-6">1、概念</h2>
<p>（有点像乐观锁，更新之前先比较一下是不是之前的那个值）</p>
<p>compare and swap
比较并交换，包含三个操作数——内存位置、预期原值及更新值</p>
<p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p>
<ul>
<li>如果相匹配，那么处理器会自动将该位置值更新为新值</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203233.png" /></p>
<p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。它是非阻塞的且自身具有原子性。CAS是一条CPU的原子指令（cmpxchg指令），执行cmpxchg指令时，会判断当前系统是否为多核系统，若为多核系统，则给总线加锁，只有一个线程会对总线加锁成功，加锁成功后会执行CAS操作，即CAS的原子性实际上是CPU实现独占，比起synchronized重量级锁，这里的排他事件要短很多，所以在多线程情况下性能会更好。</p>
<h2 id="cas底层原理">2、CAS底层原理</h2>
<h3 id="unsafe">（1）Unsafe</h3>
<p>是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe基于该类可以直接操作特定内存的数据。Unsafe类其内部方法操作可以像C的指针一样直接操作内存，因此Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p><strong>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong></p>
<h3 id="变量valueoffset">（2）变量valueOffset</h3>
<p>其实就是内存偏移地址，因为Unsafe是根据内存偏移地址来获取数据的</p>
<h3 id="使用volatile修饰变量value">（3）使用volatile修饰变量value</h3>
<p>变量value用volatile修饰，保证了多线程之间的内存可见性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JUC</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>实习坑点</title>
    <url>/2025/01/04/Java/%E5%AE%9E%E4%B9%A0%E5%9D%91%E7%82%B9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="39f6fc65c56b885e0fadb17bc2a8eeb1a64c28db461f500933fdcec77f7e0e02">1f6bb8509d126916afe1b073331b8b303e8fc819b81490765ad837df7dc1353814a72d845b5617ce1fc01ae8d2343ee9e00ca198754762b83bc34dc85adcadb9565ade93116558bad147e024d233f6fd50676540c5cfc12ef02bdb9408ec77a9cd0fd45cd751c067d00a32d02564a9ded5e79fab6af90cb1efe5602c3a23dbe85bc00b055b02a7731ad71244f3df0a0e4b22e405093904fdb426d271773c3cd945f10cef61240550fe1fc4511c9ce05e4299e86b95d3c2629b712259f3645574d5450c3915182a5b63f52fd1b9a987470d809318389bf47264abc009d75e63699fe01e548d0ccd5c5a5393bac04d96ba61630da33c84987a274094cae6c6fb00be8a457b5703d7bf2dc1e6825e0314e1bd96e928fc5384ab593e02b2028ac65117828b0a7171311817a002c4804b5e87d6b862a31cfee9328e8793a5763a6f7998bee9741e2163ad1fdc40b65842374a933ac726a26b96e1d1f09fa850a77136af875dadf227595bae3174aaead10bf6be33ad53fe0b55a65c627c7361b07e6b00e8e9b0c51cddcc2d99bb5247a33dea91e5f30f48ae20d72e65e22f909fe3ba4ed66a3344b608738ad3eab169b50d6fe0097944f2e1f4af6ef793a37a5cf3ab8c7d027451039abc4a88d9ce6ee052c506c77959dd1e471e137ff984b576d9011611a60632198f2bb59b7330544a51958a13b094b5a1b39cf8f1c817e57e0ba87f2ae06d347bd39c25953b40c518d8167f0beef5cc0e7982735fd0fffc1c699dd9923e1f4570d5255f0f985dabcc890e004b6fbc9faf80cd66cee28b03be73b0b2a3edf2da7fcaa9bf50059da89ae9be</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试</title>
    <url>/2025/01/04/Java/Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="一美团">一、美团</h1>
<h1 id="二字节">二、字节</h1>
<h1 id="三momenta">三、Momenta</h1>
<h2 id="一http请求报文解析的过程">一、HTTP请求报文解析的过程</h2>
<h3 id="http基本概念">1. HTTP基本概念</h3>
<p>HTTP是指超文本传输协议，全称HyperText Transfer
Protocol，它的名称由三部分组成</p>
<p>超文本：指的不仅仅限于文本的多样性，还包括视频、图片等</p>
<p>传输：表示数据的传输</p>
<p>协议：表示通信双方的在传输过程中约定俗成的规范</p>
<h3 id="http请求位于计算机网络的哪一层呢">2.
HTTP请求位于计算机网络的哪一层呢？</h3>
<p>应用层。
在网络通信中，应用层是最接近用户的一层，它负责为特定的网络应用提供服务和功能。应用层协议定义了数据交换的规则和格式，以便不同的应用程序能够相互通信和交换信息。</p>
<h3 id="http请求的整个流程">3. HTTP请求的整个流程</h3>
<h4 id="总体流程"><strong>（1）总体流程</strong></h4>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250104142003.png" /></p>
<h4 id="实际例子"><strong>（2）实际例子</strong></h4>
<p>以一个实际的案例，来深入探讨一下HTTP的请求响应过程，假设我们访问的网址是：https://baidu.com</p>
<p>当我们在浏览器地址栏输入该网址并按下回车键后，浏览器会进行如下操作：</p>
<ol type="1">
<li>首先浏览器会使用DNS域名解析协议，解析输入的网站域名，然后获取实际服务器的ip地址返回给浏览器。</li>
<li>浏览器接收到实际的服务器ip地址后，会随机选择一个可用的客户端端口，与服务器默认的80端口建立TCP连接（3次握手）。在客户端和服务器之间会建立一个套接字用于通信。</li>
<li>接着浏览器会通过套接字向服务器发送一个HTTP请求，该请求会携带客户端想要的对象的相关信息。</li>
<li>服务器通过套接字接收到这个请求报文后，会对请求进行解析，并从存储器(RAM或磁盘)中检索出请求的对象。然后，服务器会将检索到的对象封装到HTTP响应报文中，并通过套接字发送给客户端。</li>
<li>客户端会从响应报文中提取出响应的文件，并对HTML文件进行检查。然后，客户端会循环检查报文中的其他内部对象。在检查完成后，HTTP客户端会将相应的资源通过显示器呈现给用户。</li>
<li>当服务器响应完客户端请求后，会主动通知TCP断开连接，跟浏览器进行4次挥手最终断开TCP连接。</li>
</ol>
<h3 id="双向连接">4. 双向连接</h3>
<p>​ 从上面的流程描述可以看到，HTTP
协议是一种单向无状态协议，这意味着只有客户端向服务器端发送请求时，服务器才会响应并返回数据给客户端。然而，服务器并不会主动发送HTTP请求返回给客户端。因此，单向通信有对应的双向通信方式，通过某些技术和扩展，HTTP协议也可以实现类似于双向通信的效果。例如，通过长轮询（Long
Polling），客户端可以发送一个请求并保持连接打开，直到服务器有新的数据可用时才返回响应。这种方式使得服务器能够向客户端推送数据，从而实现了类似于双向通信的效果。</p>
<p>​
WebSockets是一种全双工通信协议，它允许客户端和服务器之间进行双向通信。通过建立持久的连接，WebSockets实现了更实时的双向通信。</p>
<h2 id="二redis">二、Redis</h2>
<h3 id="基本数据类型">1. 基本数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">String</td>
<td style="text-align: center;">hello world</td>
</tr>
<tr>
<td style="text-align: center;">Hash</td>
<td style="text-align: center;">{name:"jack", age:21}</td>
</tr>
<tr>
<td style="text-align: center;">List</td>
<td style="text-align: center;">[A-&gt;B-&gt;B-&gt;C]</td>
</tr>
<tr>
<td style="text-align: center;">Set</td>
<td style="text-align: center;">{A,C,B}</td>
</tr>
<tr>
<td style="text-align: center;">SortSet</td>
<td style="text-align: center;">{A:1,B:2,C:3}</td>
</tr>
</tbody>
</table>
<h3 id="特殊数据类型">2. 特殊数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">GEO</td>
<td style="text-align: center;">{A:(120.3, 30.5)}</td>
</tr>
<tr>
<td style="text-align: center;">BitMap</td>
<td style="text-align: center;">0111001000101010101</td>
</tr>
<tr>
<td style="text-align: center;">HyperLog</td>
<td style="text-align: center;">101001010110101</td>
</tr>
</tbody>
</table>
<h3 id="redis和mysql保持数据一致性">3. Redis和MySQL保持数据一致性</h3>
<h4 id="一缓存先后删除问题"><strong>（一）缓存先后删除问题</strong></h4>
<blockquote>
<p>不管是先写<a
href="https://cloud.tencent.com/product/cdb?from_column=20065&amp;from=20065">MySQL数据库</a>，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。</p>
</blockquote>
<h5 id="先删除缓存">1.1 先删除缓存</h5>
<ul>
<li>如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取</li>
<li>这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据。</li>
<li>然后数据库更新后发现Redis和Mysql出现了数据不一致的问题</li>
</ul>
<h5 id="后删除缓存">1.2 后删除缓存</h5>
<ul>
<li>如果先写了库，然后再删除缓存，不幸的写库的线程挂了，导致了缓存没有删除</li>
<li>这个时候就会直接读取旧缓存，最终也导致了数据不一致情况</li>
<li>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题</li>
</ul>
<h4 id="二解决办法">（二）解决办法</h4>
<h5 id="延时双删策略">2.1 延时双删策略</h5>
<ul>
<li>1.先删除缓存</li>
<li>2.再写数据库</li>
<li>3.休眠500毫秒</li>
<li>4.再次删除缓存</li>
</ul>
<h5 id="异步更新缓存基于mysql-binlog的同步机制">2.2
异步更新缓存（基于Mysql binlog的同步机制）</h5>
<ul>
<li>1.涉及到更新的数据操作，利用Mysql binlog 进行增量订阅消费</li>
<li>2.将消息发送到消息队列</li>
<li>3.通过消息队列消费将增量数据更新到Redis上</li>
<li>4.操作情况</li>
<li>读取Redis缓存：热数据都在Redis上</li>
<li>写Mysql：增删改都是在Mysql进行操作</li>
<li>更新Redis数据：Mysql的数据操作都记录到binlog，通过消息队列及时更新到Redis上</li>
</ul>
<h3 id="缓存穿透">4. 缓存穿透</h3>
<h4 id="概念">（1）概念</h4>
<p>指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会直接打到数据库</p>
<h4 id="解决方案">（2）解决方案</h4>
<ul>
<li>缓存空对象</li>
<li>布隆过滤器</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩">5. 缓存雪崩</h3>
<h4 id="概念-1">（1）概念</h4>
<p>指同一时段，大量的缓存key同时失效，或者Redis服务宕机，导致大量的请求直接打到数据库，带来巨大的压力</p>
<h4 id="解决方案-1">（2）解决方案</h4>
<ul>
<li>给不同key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿">6. 缓存击穿</h3>
<h4 id="概念-2">（1）概念</h4>
<p>也叫热点Key问题，就是被一个高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的压力。</p>
<h4 id="解决方案-2">（2）解决方案</h4>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<h3 id="redis持久化">7. Redis持久化</h3>
<h4 id="一rdb持久化">（一）RDB持久化</h4>
<h5 id="概念-3">1. 概念</h5>
<p>​ RDB全称Redis Database Backup
file（Redis数据备份文件），也被叫做Redis数据快照。（快照文件称为RDB文件，默认是保存在当前运行目录。）简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。Redis停机时会执行一次RDB。</p>
<h5 id="过程">2. 过程</h5>
<p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入
RDB 文件。 fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<h4 id="二aof持久化">（二）AOF持久化</h4>
<h5 id="概念-4">1. 概念</h5>
<p>AOF全称为Append Only
File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<h5 id="过程-1">2. 过程</h5>
<p>其实就是一个执行日志文件，每次进行操作都写入日志中。</p>
<h3 id="redis主从">8. Redis主从</h3>
<h4 id="一数据同步">（一）数据同步</h4>
<h5 id="全量同步">1. 全量同步</h5>
<ul>
<li>slave节点请求增量同步</li>
<li>master节点判断replid，发现不一致，拒绝增量同步</li>
<li>master将完整内存数据生成RDB，发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li>
<li>slave执行接收到的命令，保持与master之间的同步</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250104163740.png" style="zoom: 33%;" /></p>
<h5 id="增量同步">2. 增量同步</h5>
<h2 id="java性能优化">Java性能优化</h2>
<h2 id="transactional-注解失效"><span class="citation"
data-cites="Transactional">@Transactional</span> 注解失效</h2>
]]></content>
      <tags>
        <tag>后端面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>生活心得</title>
    <url>/2024/12/17/Life/%E7%94%9F%E6%B4%BB%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="39a3e91f4c5d7c1cb6483996f53257fe2795255f840c0cc7179afd0fb8315f2c">1f6bb8509d126916afe1b073331b8b3022b18b79a6847b5197580c9561aefcdb7ef0d420fd891ef5503bc83738620ef4a03ae5124c312909ce9f60dd3706ecabbc0cd5634cd8567a22be1e022bf0beac66afc389469082db29e3c78737e66c4869d462d61098a196d97f1fb073e9db885418219d96e4bc9e2f913f689beea7090dea7ab83fc87afe9d2ff383fe1e248dbbaf05ac0c1ec0500b944ded297209fe18aff9a11d46d9a4fc6ab496725c433095de62d152a9162636a045a2cdc03161295105e4916ee87e6cc7b11d01b9e3abe31b4547d444f892500e8ec573e8f69aa16e5b86d4b67b40d4ee4c250366d93855d964061885b29695c54d19dd8071a224b942c7c980457c01d379b1a8dddf4a5958e7751778e79b5630b8b05b918843</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing基础算法板子</title>
    <url>/2024/12/14/Algorithm/Acwing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="第一讲-基础算法">第一讲 基础算法</h1>
<h2 id="快速排序">1. 快速排序</h2>
<h3 id="快速排序-1">1.1 <a
href="https://www.acwing.com/problem/content/787/">快速排序</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">do</span> ++i; <span class="keyword">while</span> (arr[i] &lt; base);</span><br><span class="line">		<span class="keyword">do</span> --j; <span class="keyword">while</span> (arr[j] &gt; base);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, l, j);</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第k个数">1.2 <a
href="https://www.acwing.com/problem/content/788/">第K个数</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> arr[l];</span><br><span class="line">	<span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = arr[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">do</span> ++i; <span class="keyword">while</span> (arr[i] &lt; base);</span><br><span class="line">		<span class="keyword">do</span> --j; <span class="keyword">while</span> (arr[j] &gt; base);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= j) <span class="keyword">return</span> <span class="built_in">quickSort</span>(arr, l, j, k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickSort</span>(arr, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">2.归并排序</h2>
<h3 id="归并排序-1">2.1 <a
href="https://www.acwing.com/problem/content/789/">归并排序</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, temp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid<span class="number">+1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[j]) temp[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) temp[k++] = arr[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = l, m = <span class="number">0</span>; t &lt;= r; ++t, ++m) arr[t] = temp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆序对的数量">2.1 <a
href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, temp[N];</span><br><span class="line">ll res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, l, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			res += mid - i + <span class="number">1</span>;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) temp[k++] = arr[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = l, m = <span class="number">0</span>; t &lt;= r; ++t, ++m) arr[t] = temp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分">3. 二分</h2>
<h3 id="数的范围">3.1 <a
href="https://www.acwing.com/problem/content/791/">数的范围</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, q, num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &gt;= num) r = mid;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (num != arr[l]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, l);</span><br><span class="line">		l = <span class="number">0</span>;   r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &lt;= num) l = mid;</span><br><span class="line">			<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数的三次方根">3.2 <a
href="https://www.acwing.com/problem/content/792/">数的三次方根</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">	<span class="type">double</span> l = <span class="number">-100000</span>, r = <span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">while</span> (r-l&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">		<span class="type">double</span> num = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (num * num * num &gt; n) r = num;</span><br><span class="line">		<span class="keyword">else</span> l = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度">4.高精度</h2>
<h3 id="高精度加法">4.1 <a
href="https://www.acwing.com/problem/content/793/">高精度加法</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> A[N], B[N], C[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		t += A[i] + B[i];</span><br><span class="line">		C[++len] = t % <span class="number">10</span>;</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t) C[++len] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)A[++cnt1] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)B[++cnt2] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">add</span>(<span class="built_in">max</span>(cnt1, cnt2));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; --i)cout &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度减法">4.2 <a
href="https://www.acwing.com/problem/content/794/">高精度减法</a></h3>
<p>待补充~~~ ### 4.3 <a
href="https://www.acwing.com/problem/content/795/">高精度乘法</a>
待补充~~~ ### 4.4 <a
href="https://www.acwing.com/problem/content/796/">高精度除法</a>
待补充~~~</p>
<h2 id="前缀和与差分">5. 前缀和与差分</h2>
<h3 id="前缀和">5.1 <a
href="https://www.acwing.com/problem/content/797/">前缀和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);     arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[r] - arr[l - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子矩阵的和">5.2 <a
href="https://www.acwing.com/problem/content/798/">子矩阵的和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N], n, m, q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i][j]);</span><br><span class="line">			arr[i][j] = arr[i][j] + arr[i - <span class="number">1</span>][j] + arr[i][j - <span class="number">1</span>] - arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[x2][y2] - arr[x1 - <span class="number">1</span>][y2] - arr[x2][y1 - <span class="number">1</span>] + arr[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分">5.3 <a
href="https://www.acwing.com/problem/content/799/">差分</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, m, num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	arr[l] += c;</span><br><span class="line">	arr[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);   <span class="built_in">add</span>(i, i, num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		<span class="built_in">add</span>(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分矩阵">5.4 <a
href="https://www.acwing.com/problem/content/description/800/">差分矩阵</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N], n, m, q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	arr[x1][y1] += c;</span><br><span class="line">	arr[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">	arr[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">	arr[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num, x1, y1, x2, y2;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">			<span class="built_in">add</span>(i, j, i, j, num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;num);</span><br><span class="line">		<span class="built_in">add</span>(x1, y1, x2, y2, num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			arr[i][j] = arr[i][j] + arr[i - <span class="number">1</span>][j] + arr[i][j - <span class="number">1</span>] - arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针算法">6. 双指针算法</h2>
<h3 id="最长连续不重复子序列">6.1 <a
href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], n, s[N], res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">		s[arr[i]]++;</span><br><span class="line">		<span class="keyword">while</span> (s[arr[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			s[arr[j]]--;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的目标和">6.2 <a
href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, x, A[N], B[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[j]);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] + B[j] == x) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (A[i] + B[j] &gt; x) j--;</span><br><span class="line">		<span class="keyword">else</span> i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">6.3 <a
href="https://www.acwing.com/problem/content/2818/">判断子序列</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, A[N], B[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[j]);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] == B[j]) ++i;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == n) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位运算">7. 位运算</h2>
<h3 id="二进制中1的个数">7.1 二进制中1的个数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNumber</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num &amp; <span class="number">1</span>) res++;</span><br><span class="line">		num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">		<span class="type">int</span> ans = <span class="built_in">getNumber</span>(num);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化">8.离散化</h2>
<h3 id="区间和">8.1 <a
href="https://www.acwing.com/problem/content/804/">区间和</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m,s[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;</span><br><span class="line">vector&lt;PII&gt;add,query;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x)r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();++i)s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间合并">9.区间合并</h2>
<h3 id="区间合并-1">9.1 <a
href="https://www.acwing.com/problem/content/805/">区间合并</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt;segs;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp; segs)</span> </span>&#123;</span><br><span class="line">	vector&lt;PII&gt;res;</span><br><span class="line">	<span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item : segs) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ed &lt; item.first) &#123;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="number">-2e9</span>)res.<span class="built_in">push_back</span>(&#123; st,ed &#125;);</span><br><span class="line">			st = item.first;   ed = item.second;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, item.second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st != <span class="number">-2e9</span>)res.<span class="built_in">push_back</span>(&#123; st,ed &#125;);</span><br><span class="line">	segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		segs.<span class="built_in">push_back</span>(&#123; l,r &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge</span>(segs);</span><br><span class="line">	cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="第二讲-数据结构">第二讲 数据结构</h1>
<h2 id="单链表">1. 单链表</h2>
<h3 id="单链表-1">1.1 <a
href="https://www.acwing.com/problem/content/828/">单链表</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N], h = <span class="number">-1</span>, ne[N], idx = <span class="number">0</span>, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">headInsert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = h;</span><br><span class="line">	h = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNum</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	ne[k - <span class="number">1</span>] = ne[ne[k - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addk</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	e[idx] = num;  ne[idx] = ne[k - <span class="number">1</span>];</span><br><span class="line">	ne[k - <span class="number">1</span>] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="type">int</span> x, k;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;H&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">headInsert</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) h = ne[h];</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">deleteNum</span>(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			<span class="built_in">addk</span>(k, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = h; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双链表">2.双链表</h2>
<h3 id="双链表-1">2.1 <a
href="https://www.acwing.com/problem/content/829/">双链表</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> l[N], r[N], e[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	idx = <span class="number">2</span>;</span><br><span class="line">	l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert_right</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	r[idx] = r[k];</span><br><span class="line">	l[idx] = k;</span><br><span class="line">	l[r[k]] = idx;</span><br><span class="line">	r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	r[l[k]] = r[k];</span><br><span class="line">	l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Inite</span>();</span><br><span class="line">	string op;</span><br><span class="line">	<span class="type">int</span> m, k, x;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(<span class="number">0</span>, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(l[<span class="number">1</span>], x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			<span class="built_in">remove</span>(k<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">&quot;IL&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(l[k<span class="number">+1</span>], x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IR&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			<span class="built_in">Insert_right</span>(k<span class="number">+1</span>, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈">3. 栈</h2>
<h3 id="模拟栈">3.1 <a
href="https://www.acwing.com/problem/content/830/">模拟栈</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tt &lt; hh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	arr[++tt] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">	tt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m, num;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="built_in">push</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; arr[tt] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表达式求值">3.2 <a
href="https://www.acwing.com/problem/content/3305/">表达式求值</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = num.<span class="built_in">top</span>();  num.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="type">int</span> b = num.<span class="built_in">top</span>();  num.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="type">char</span> c = op.<span class="built_in">top</span>();   op.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)num.<span class="built_in">push</span>(a + b);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)num.<span class="built_in">push</span>(b - a);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)num.<span class="built_in">push</span>(b * a);</span><br><span class="line">	<span class="keyword">else</span> num.<span class="built_in">push</span>(b / a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123; &#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">auto</span> c = str[i];</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">			<span class="type">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j])) &#123;</span><br><span class="line">				x = x * <span class="number">10</span> + str[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i = j - <span class="number">1</span>;</span><br><span class="line">			num.<span class="built_in">push</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)<span class="built_in">eval</span>();</span><br><span class="line">			op.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c])<span class="built_in">eval</span>();</span><br><span class="line">			op.<span class="built_in">push</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (op.<span class="built_in">size</span>())<span class="built_in">eval</span>();</span><br><span class="line">	cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">4. 队列</h2>
<h3 id="模拟队列">4.1 <a
href="https://www.acwing.com/problem/content/831/">模拟队列</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hh &gt; tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	arr[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">	hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string op;   <span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="built_in">push</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; arr[hh] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈">5. 单调栈</h2>
<h3 id="单调栈-1">5.1 <a
href="https://www.acwing.com/problem/content/832/">单调栈</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, st[N], tt = <span class="number">-1</span>, num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		<span class="keyword">while</span> (tt &gt;= <span class="number">0</span> &amp;&amp; num &lt;= st[tt]) --tt;</span><br><span class="line">		<span class="keyword">if</span> (tt &gt;= <span class="number">0</span>) cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		st[++tt] = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列">6. 单调队列</h2>
<h3 id="滑动窗口">6.1 <a
href="https://www.acwing.com/problem/content/156/">滑动窗口</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], q[N], n, k, hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">		<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; arr[q[tt]] &gt;= arr[i]) tt--;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[q[hh]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	hh = <span class="number">0</span>;  tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; arr[q[tt]] &lt;= arr[i]) tt--;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[q[hh]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp">7. KMP</h2>
<h3 id="kmp字符串">7.1 <a
href="https://www.acwing.com/problem/content/833/">KMP字符串</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> n, m, ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d %s&quot;</span>, &amp;n, p + <span class="number">1</span>, &amp;m, s + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 求next 数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (p[j + <span class="number">1</span>] == p[i]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// KMP</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">		<span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">			j = ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="trie">8. Trie</h2>
<h3 id="trie字符串统计">8.1 Trie字符串统计</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], idx = <span class="number">0</span>, cnt[N], x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> s = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][s]) son[p][s] = ++idx;</span><br><span class="line">		p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> s = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][s]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	string str, op;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; str;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) <span class="built_in">Insert</span>(str);</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="built_in">Query</span>(str) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大异或对">8.2 <a
href="https://www.acwing.com/problem/content/145/">最大异或对</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], idx = <span class="number">0</span>, arr[N], res = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">		<span class="type">int</span> s = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][s]) son[p][s] = ++idx;</span><br><span class="line">		p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">		<span class="type">int</span> s = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (son[p][!s]) &#123;</span><br><span class="line">			ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">			p = son[p][!s];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p = son[p][s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">		<span class="built_in">Insert</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(arr[i]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集">9. 并查集</h2>
<h3 id="合并集合">9.1 <a
href="https://www.acwing.com/problem/content/838/">合并集合</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, a, b, path[N];</span><br><span class="line">string op;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> path[x] = <span class="built_in">find</span>(path[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tx = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> ty = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (tx != ty) path[tx] = ty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) path[i] = i;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;M&quot;</span>)<span class="built_in">merge</span>(a, b);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> ta = <span class="built_in">find</span>(a), tb = <span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span> (ta == tb) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连通块中点的数量">9.2 <a
href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> path[a] = <span class="built_in">find</span>(path[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ta = <span class="built_in">find</span>(a);</span><br><span class="line">	<span class="type">int</span> tb = <span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span> (ta == tb) <span class="keyword">return</span>;</span><br><span class="line">	path[ta] = tb;</span><br><span class="line">	cnt[tb] = cnt[ta] + cnt[tb];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		path[i] = i;   cnt[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="built_in">merge</span>(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Q1&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="type">int</span> ta = <span class="built_in">find</span>(a);</span><br><span class="line">			<span class="type">int</span> tb = <span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span> (ta == tb) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; a;</span><br><span class="line">			<span class="type">int</span> ta = <span class="built_in">find</span>(a);</span><br><span class="line">			cout &lt;&lt; cnt[ta] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="食物链">9.3 <a
href="https://www.acwing.com/problem/content/242/">食物链</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pre[N], dis[N], n, m, res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x != pre[x]) &#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">find</span>(pre[x]);</span><br><span class="line">		dis[x] += dis[pre[x]];</span><br><span class="line">		pre[x] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = i;</span><br><span class="line">	<span class="type">int</span> d, x, y;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;</span><br><span class="line">			res++;  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> tx = <span class="built_in">find</span>(x), ty = <span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tx == ty &amp;&amp; (dis[x] - dis[y]) % <span class="number">3</span>) res++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tx != ty) &#123;</span><br><span class="line">				pre[tx] = ty;</span><br><span class="line">				dis[tx] = dis[y] - dis[x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (tx == ty &amp;&amp; (dis[x] - dis[y] - <span class="number">1</span>) % <span class="number">3</span>) res++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tx != ty) &#123;</span><br><span class="line">				pre[tx] = ty;</span><br><span class="line">				dis[tx] = dis[y] - dis[x] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆">10. 堆</h2>
<h3 id="堆排序">10.1 <a
href="https://www.acwing.com/problem/content/840/">堆排序</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> h[N],len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=len&amp;&amp;h[t]&gt;h[u*<span class="number">2</span>])t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=len&amp;&amp;h[t]&gt;h[u*<span class="number">2</span><span class="number">+1</span>])t = u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t],h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    len = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i;--i)<span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[len];</span><br><span class="line">        len--;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟堆">10.2 <a
href="https://www.acwing.com/problem/content/841/">模拟堆</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> h[N];   <span class="comment">//堆</span></span><br><span class="line"><span class="type">int</span> ph[N];  <span class="comment">//存放第k个插入点的下标</span></span><br><span class="line"><span class="type">int</span> hp[N];  <span class="comment">//存放堆中点的插入次序</span></span><br><span class="line"><span class="type">int</span> cur_size;   <span class="comment">//size 记录的是堆当前的数据多少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个交换过程其实有那么些绕 但关键是理解 如果hp[u]=k 则ph[k]=u 的映射关系</span></span><br><span class="line"><span class="comment">//之所以要进行这样的操作是因为 经过一系列操作 堆中的元素并不会保持原有的插入顺序</span></span><br><span class="line"><span class="comment">//从而我们需要对应到原先第K个堆中元素</span></span><br><span class="line"><span class="comment">//如果理解这个原理 那么就能明白其实三步交换的顺序是可以互换 </span></span><br><span class="line"><span class="comment">//h,hp,ph之间两两存在映射关系 所以交换顺序的不同对结果并不会产生影响</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">swap</span>(h[u],h[v]); </span><br><span class="line">     <span class="built_in">swap</span>(hp[u],hp[v]);     </span><br><span class="line">     <span class="built_in">swap</span>(ph[hp[u]],ph[hp[v]]);            </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=cur_size&amp;&amp;h[t]&gt;h[u*<span class="number">2</span>]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=cur_size&amp;&amp;h[t]&gt;h[u*<span class="number">2</span><span class="number">+1</span>])  t=u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u/<span class="number">2</span>&gt;<span class="number">0</span>&amp;&amp;h[u]&lt;h[u/<span class="number">2</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,u/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">up</span>(u&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;      <span class="comment">//m用来记录插入的数的个数</span></span><br><span class="line">                <span class="comment">//注意m的意义与cur_size是不同的 cur_size是记录堆中当前数据的多少</span></span><br><span class="line">                <span class="comment">//对应上文 m即是hp中应该存的值</span></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            m++;</span><br><span class="line">            h[++cur_size]=x;</span><br><span class="line">            ph[m]=cur_size;</span><br><span class="line">            hp[cur_size]=m;</span><br><span class="line">            <span class="comment">//down(size);</span></span><br><span class="line">            <span class="built_in">up</span>(cur_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;PM&quot;</span>)    cout&lt;&lt;h[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;DM&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cur_size);</span><br><span class="line">            cur_size--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="type">int</span> u=ph[k];                <span class="comment">//这里一定要用u=ph[k]保存第k个插入点的下标</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(u,cur_size);          <span class="comment">//因为在此处heap_swap操作后ph[k]的值已经发生 </span></span><br><span class="line">            cur_size--;                    <span class="comment">//如果在up,down操作中仍然使用ph[k]作为参数就会发生错误</span></span><br><span class="line">            <span class="built_in">up</span>(u);</span><br><span class="line">           <span class="built_in">down</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            h[ph[k]]=x;                 <span class="comment">//此处由于未涉及heap_swap操作且下面的up、down操作只会发生一个所以</span></span><br><span class="line">            <span class="built_in">down</span>(ph[k]);                <span class="comment">//所以可直接传入ph[k]作为参数</span></span><br><span class="line">            <span class="built_in">up</span>(ph[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表">11. 哈希表</h2>
<h3 id="模拟散列表">11.1 <a
href="https://www.acwing.com/problem/content/842/">模拟散列表</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+3</span>;</span><br><span class="line"><span class="type">int</span> e[N],idx = <span class="number">0</span>,ne[N],h[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N+N)%N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k];i!=<span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> x, n;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>( n-- )&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;I&#x27;</span>)<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(x))cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串哈希">11.2 <a
href="https://www.acwing.com/problem/content/843/">字符串哈希</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ull h[N],p[N];</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,str<span class="number">+1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">        h[i] = h[i<span class="number">-1</span>]*P+str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2))<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>C++</tag>
        <tag>算法板子</tag>
      </tags>
  </entry>
  <entry>
    <title>英文单词</title>
    <url>/2024/12/04/Life/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语单词3000个</tag>
        <tag>积累</tag>
      </tags>
  </entry>
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <url>/2024/12/03/Hexo/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>❗本文针对hexo的Next主题的设置有效，其他主题可以看看有没有相同字段
Next默认是会在首页显示全文的，看起来冗长不简洁。要想首页仅展示文章标题或者摘要，请按照以下步骤进行：</p>
<h3 id="修改配置">修改配置</h3>
<p>首先需要在Next主题的<code>_config.yml</code>中把设置打开(默认安装时就打开了):
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="设置展示的内容">设置展示的内容</h3>
<h4 id="方法一写概述">方法一：写概述</h4>
<p>在文章的<code>front-matter</code>中添加<code>description</code>，其中<code>descriptio</code>n中的内容就会被显示在首页上，其余一律不显示。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/Snipaste_2024-12-04_00-04-00.png" /></p>
<p>PS:
这种方法主要是要自己对文章内容进行简单总结，有时候不喜欢写总结介绍的话，可以用下面第二种方法</p>
<h4 id="方法二文章截断">方法二：文章截断</h4>
<p>在需要截断的地方加入： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>
首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p>
<p>这个明显会方便很多，但当然有利有弊，我一般喜欢用方法一，也希望自己写的<code>description</code>能够给读者快速了解文章内容的效果</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>碎碎念</title>
    <url>/2024/12/01/Life/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p><font size=4>🚩
真正的自由意味着控制你整个生活，学会计划、承诺和决定，为你自己的行为负责！</font>
<br></p>
<blockquote>
<p><font face="楷体">
原来，让内心强大，我只需要看到自己，接纳我还不能做的，欣赏我已经做到的
——《当我真的足够强大》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
没有一种批判比自我批判更强烈，也没有一种法官比我们自己更严苛。
——《蛤蟆先生去看心理医生》</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
对抗消极的不是积极，而是专注。积极的情绪是无法击退消极情绪的，只有把自己沉浸在某件事件上才能从消极情绪中走出来。
——若林正恭 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 生活的不确定性正是我们希望的来源。 ——阿德勒
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
那些看起来比你勇敢的人也像你一样害怕，他们只是在黑暗中把口哨吹得响亮一些罢了。
——《为什么长大》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
那晚，我点了一把篝火，大地在月亮眼中亮起了一颗星星。 ——弱智吧
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 这乱糟糟的世上还有人拿着花四处走走。
——李沧东《火与灰》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 好在，别人如何分析我，跟我本身是一点关系都没有的。
——三毛《撒哈拉的故事》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 你极目远望，其余的由心去完成。 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 一个人变好的前提是，允许自己不好。 ——武志红
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
纯粹，就是不要一心要成为高贵或者强大的人，而是成为自己。
——佩索阿《惶然录》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
人人都有天赋，但可贵的是，你是否有勇气追随你的天赋到黑暗之地。
——艾丽卡·琼 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
随着年龄的增长，你越来越不在意别人怎么看你，只有那时你才能愈加自由。
——《失踪树木的岛屿》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
人脑虽然可以努力什么都试图记住，但写下来就可以安心忘记了。 ——《告白》
</font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
后来我知道了，人生在世，临到每一个紧要关头，你都是孤军衰兵。
——《关山夺路》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
我们本能地把错误归咎于他人，但最重要的是，坏事情发生时，应该寻找原因，而不是寻找坏人。
——《事实》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
勇气，并不是闪闪发光的英雄主义，勇敢中也包含怯懦，就像爱中也有不爱的时刻。这来回摇摆的踱步，斑驳的杂质，才是真相。
——《茫然尘世的珍宝》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 我独自度过了太多时光，沉默已成一种习惯。
——《夜航西飞》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
幸福的关键，并不在于你是否结婚、是否有孩子等，而是无论你处于什么样的状态都有不停追求幸福的行动力，以及无论多小的一件事，你都能感到幸福的能力。可以说，幸福的关键是一种心态。
——《超单身社会》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
因为有了仪式，某一天才有别于其他任何一天，某一个小时才有别于其他任何一个时刻。
——圣·埃克絮佩里 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
时间不是一条直线，而是一个循环，我们在其中不断重复着相似的故事，直到我们学会从中解脱。
——《悉达多》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
你不能在赢的时候才自信，那不是自信，是对结果的复读。 ——冯骥 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
出路只有一条：在别人头脑发热大声喧闹的时候，退回到自己的内心并保持沉默
——《昨日的世界》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
无论风暴将我带到什么样的岸边，我都将以主人的身份上岸
——昆图斯·贺拉斯·弗拉库斯 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 而我，还是那个身披霞光的人
<br>雨水流过山岚，孤独如杜鹃开放 ——余秀华 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体">
能够用干净利落、毫不妥协的态度看待事情，本身就是一种成就。
——《永不停步》 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 我一定会幸福，为此，我现在要做必须做的事。
——上野千鹤子 </font></p>
</blockquote>
<p><br></p>
<blockquote>
<p><font face="楷体"> 我一定会幸福，为此，我现在要做必须做的事。
——上野千鹤子 </font></p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>名言积累</tag>
      </tags>
  </entry>
</search>
