<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ych1016.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":300,"width_dual_column":200,"display":"always","padding":20,"offset":200},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/./public/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":7,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录旺仔学习 Redis 应用 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis应用">
<meta property="og:url" content="https://ych1016.github.io/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="攻城狮-旺仔">
<meta property="og:description" content="记录旺仔学习 Redis 应用 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309103254.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309110729.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203618.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135734.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135630.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203643.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309181748.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309190713.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203658.png">
<meta property="og:image" content="c:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311141509633.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311144321.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311201538.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310094729.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310095101.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310134922.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141541.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141854.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310142616.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143057.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143251.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143500.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144256.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144414.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310145407.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310151049.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311140348.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310165123.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163322.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163403.png">
<meta property="og:image" content="c:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311092621147.png">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105501.png">
<meta property="article:published_time" content="2025-03-09T00:58:55.000Z">
<meta property="article:modified_time" content="2025-03-11T13:20:12.410Z">
<meta property="article:author" content="旺仔">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309103254.png">


<link rel="canonical" href="https://ych1016.github.io/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ych1016.github.io/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/","path":"2025/03/09/Java/Redis实战/","title":"Redis应用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis应用 | 攻城狮-旺仔</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">攻城狮-旺仔</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本站为攻城狮旺仔个人博客，仅记录日常编程笔记使用，欢迎各位大佬共同交流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-日程"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程</a></li><li class="menu-item menu-item-成就"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>成就</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><span class="nav-text">一、使用Redis实现登录校验</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BC%93%E5%AD%98"><span class="nav-text">二、缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">1、 缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">（1）什么是缓存雪崩？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-text">（2）问题分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">（3）解决方案：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%89%8D"><span class="nav-text">&lt;1&gt; 事前：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%B8%AD"><span class="nav-text">&lt;2&gt; 事中：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%90%8E"><span class="nav-text">&lt;3&gt; 事后：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">2、缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">（1）什么是缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="nav-text">（2）问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-text">（3）解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E6%88%96%E8%80%85%E9%98%9F%E5%88%97"><span class="nav-text">&lt;1&gt; 互斥锁或者队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">3、缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">（1）什么是缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2"><span class="nav-text">（2）问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-text">（3）解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">&lt;1&gt; 非法请求的限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%97%A0%E6%95%88key%E5%AD%98%E6%94%BE%E5%9C%A8redis%E4%B8%AD"><span class="nav-text">&lt;2&gt; 将无效key存放在Redis中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">&lt;3&gt; 使用布隆过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E6%80%BB"><span class="nav-text">汇总</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-text">4、缓存预热</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-text">（1）什么是缓存预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-text">（2）缓存预热实现方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="nav-text">5、缓存降级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">三、数据库缓存保持一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="nav-text">1、先更新数据库还是先更新缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cache-aside%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-text">2、 Cache Aside（旁路缓存）策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-text">（1）写策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E7%AD%96%E7%95%A5"><span class="nav-text">（2）读策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E7%BC%93%E5%AD%98"><span class="nav-text">2.1 先更新数据库还是先删缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readwrite-through%E8%AF%BB%E7%A9%BF-%E5%86%99%E7%A9%BF%E7%AD%96%E7%95%A5"><span class="nav-text">3、 Read&#x2F;Write Through（读穿 &#x2F;
写穿）策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#read-through"><span class="nav-text">（1）Read Through</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-through"><span class="nav-text">（2）Write Through</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#write-back%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-text">4、Write Back（写回）策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">5、小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">（1）使用【先删除缓存，再更新数据库】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E6%88%90%E5%8A%9F"><span class="nav-text">（2）保证【先更新数据库，再删除缓存】成功</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9Bredis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-text">四、Redis持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rdb%E5%BF%AB%E7%85%A7"><span class="nav-text">1、 RDB快照</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">【1】相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E5%90%AF%E7%94%A8"><span class="nav-text">（1）概念和启用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）使用指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E6%97%B6%E6%95%B0%E6%8D%AE%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97"><span class="nav-text">【2】执行快照时，数据能被修改吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8B%A5%E6%9C%89%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC"><span class="nav-text">【3】子线程如何拥有主线程相同的数据副本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E5%90%A6%E4%BF%9D%E8%AF%81%E5%BF%AB%E7%85%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">【4】能否保证快照和数据库数据一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aof%E6%97%A5%E5%BF%97"><span class="nav-text">2、AOF日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-1"><span class="nav-text">【1】相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E5%90%AF%E7%94%A8-1"><span class="nav-text">（1）概念和启用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E5%86%99%E5%90%8E%E8%AE%B0%E5%BD%95"><span class="nav-text">（2）先写后记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BD%9C%E5%9C%A8%E9%A3%8E%E9%99%A9"><span class="nav-text">（3）潜在风险</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-text">【2】三种写回策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aof%E5%86%99%E5%9B%9E"><span class="nav-text">（1）AOF写回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5-1"><span class="nav-text">（2）三种写回策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%B1%80%E9%99%90"><span class="nav-text">（3）优化局限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">（4）实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="nav-text">【3】AOF重写机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof-%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99"><span class="nav-text">【4】AOF 后台重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8E%E5%8F%B0%E5%AE%8C%E6%88%90%E9%87%8D%E5%86%99"><span class="nav-text">（1）为什么是后台完成重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">（2）为什么是子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8B%A5%E6%9C%89%E4%B8%BB%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC"><span class="nav-text">（3）子进程如何拥有主进程相同的数据副本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rdb%E5%92%8Caof%E5%90%88%E4%BD%93"><span class="nav-text">3、RDB和AOF合体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-2"><span class="nav-text">【1】相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-text">【2】过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94redis%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80"><span class="nav-text">五、Redis实现秒杀</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id"><span class="nav-text">1、 全局唯一id</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">（1）需要具备的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-text">2、超卖问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-text">（1）问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-text">（2）产生原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="nav-text">（3） 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-text">【1】 悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-text">【2】 乐观锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8D%E7%94%9F%E6%94%B9%E8%89%AF"><span class="nav-text">（4）衍生改良</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">【1】问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-text">【2】解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="nav-text">3、一人一单</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="nav-text">（1）问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0-1"><span class="nav-text">（2）产生原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="nav-text">（3）解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-text">（4）分布式问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">4、分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">（1）基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-text">（2）基本方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-text">（3）实现代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="nav-text">（4）存在问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0"><span class="nav-text">【1】Redis分布式锁误删</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">【2】分布式锁原子性问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81--redission"><span class="nav-text">5、分布式锁--Redission</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-text">（1）引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFredission"><span class="nav-text">（2）什么是Redission</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson---%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-text">（3）分布式锁Redisson--
可重入锁原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81ression-%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8Cwatchdog%E6%9C%BA%E5%88%B6"><span class="nav-text">（4）分布式锁Ression ——
锁重试和WatchDog机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">【1】原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">【2】源码解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redission-mutilock%E5%8E%9F%E7%90%86"><span class="nav-text">（5）分布式锁Redission ——
MutiLock原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-text">【1】原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="nav-text">【2】源码解析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%ADredis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">六、Redis消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">1、 认识消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Elist%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">2、 基于List实现消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="nav-text">（1）实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">（2）优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Epubsub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">3、基于PubSub的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2"><span class="nav-text">（1）实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-text">（2）优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Estream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">4、基于Stream的消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Estream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="nav-text">5、基于Stream的消息队列—消费者组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-text">6、对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E7%82%B9%E8%B5%9E%E6%94%B6%E8%97%8F%E5%92%8C%E5%85%B3%E6%B3%A8"><span class="nav-text">七、点赞、收藏和关注</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%ABgeo%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB"><span class="nav-text">八、GEO数据结构计算距离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#geo%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">1、 GEO数据结构基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%85%A5redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2、存入Redis中的数据结构定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9Dredis%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="nav-text">九、Redis实现签到功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bitmap%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">1、BitMap数据机构基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-3"><span class="nav-text">2、实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0"><span class="nav-text">3、功能点实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8bitmap%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-text">4、关于使用BitMap来解决缓存穿透的方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81uv%E7%BB%9F%E8%AE%A1"><span class="nav-text">十、UV统计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#uv%E5%92%8Cpv"><span class="nav-text">1、UV和PV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hyperloglog-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-text">2、HyperLogLog 算法原理</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="旺仔"
      src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/11zon_cropped.png">
  <p class="site-author-name" itemprop="name">旺仔</p>
  <div class="site-description" itemprop="description"><font color="#FFFFFF"; size=5px> 允许一切发生！</font></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ych1016" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ych1016" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2877816340@qq.com" title="E-Mail → mailto:2877816340@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ych1016.github.io/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/11zon_cropped.png">
      <meta itemprop="name" content="旺仔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="攻城狮-旺仔">
      <meta itemprop="description" content="<font color="#FFFFFF"; size=5px> 允许一切发生！</font>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis应用 | 攻城狮-旺仔">
      <meta itemprop="description" content="记录旺仔学习 Redis 应用 笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis应用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-09 08:58:55" itemprop="dateCreated datePublished" datetime="2025-03-09T08:58:55+08:00">2025-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-11 21:20:12" itemprop="dateModified" datetime="2025-03-11T21:20:12+08:00">2025-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>56 分钟</span>
    </span>
</div>

            <div class="post-description">记录旺仔学习 Redis 应用 笔记</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一使用redis实现登录校验">一、使用Redis实现登录校验</h1>
<p> 
主要验证是校验码验证和密码验证，我觉得可以这样设计，把验证码存入到Redis中，用户信息使用JWT生成对应的token，然后将JWT生成的token存入到Redis中（替代直接将用户信息存入Redis中），这样可以减少Redis的内存负担。具体流程图如下方所示，<br />
 
下图的具体做法是将用户的信息采用JWT进行加密保存了，出于安全考虑，我觉得对于前端页面上用户的基本信息可以使用JWT存储，这样在解析的时候也会比去Redis中再获取一次要快。但是对于用户一些常用的敏感信息，我觉得还是有必要放在Redis中的。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309103254.png" style="zoom:50%;" /></p>
<h1 id="二缓存">二、缓存</h1>
<p>使用缓存主要会存在几种问题：缓存雪崩，缓存击穿，缓存穿透。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309110729.png" style="zoom:50%;" /></p>
<h2 id="缓存雪崩">1、 缓存雪崩</h2>
<h3 id="什么是缓存雪崩">（1）什么是缓存雪崩？</h3>
<p>如果缓存在某一个时刻出现大规模key失效，那么就会导致大量的请求打在数据库上面，导致数据库压力巨大，如果高并发的情况下，可能瞬间就会导师数据库宕机。这时如果运维马上又重启数据库，马上又会有新的流量把数据库打死，这就是缓存雪崩。
<img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203618.png" style="zoom:70%;" /></p>
<h3 id="问题分析">（2）问题分析：</h3>
<p>存在这种情况的问题所在：</p>
<ul>
<li>Redis宕机</li>
<li>大量缓存采用了相同的过期时间</li>
</ul>
<h3 id="解决方案">（3）解决方案：</h3>
<h4 id="事前">&lt;1&gt; 事前：</h4>
<ol type="1">
<li><p>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问</p></li>
<li><p>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不相同</p></li>
<li><p>热点数据永远不过期</p>
<blockquote>
永不过期实际包含两层意思：
<ul>
<li>物理不过期：针对热点key不设置过期时间</li>
<li>逻辑过期：把过期时间存在key对应的value中，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</li>
</ul>
</blockquote></li>
<li><p>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用
主从 + 哨兵，Redis集群来避免Redis全盘崩溃的情况</p></li>
</ol>
<h4 id="事中">&lt;2&gt; 事中：</h4>
<ol type="1">
<li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读写数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他线程，此时系统的吞吐量会下降</li>
<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果</li>
</ol>
<h4 id="事后">&lt;3&gt; 事后：</h4>
<p> 
开启Redis持久化机制，尽快回复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p>
<h2 id="缓存击穿">2、缓存击穿</h2>
<h3 id="什么是缓存击穿">（1）什么是缓存击穿</h3>
<p> 
缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿则是某个热点key失效，大规模并发对其进行请求，就会导致大量请求读缓存读取不到数据，从而导致大规模请求直接打到数据库，引起数据库压力剧增，这就是缓存击穿。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135734.png" style="zoom:70%;" /></p>
<h3 id="问题分析-1">（2）问题分析</h3>
<p> 
关键在于某个热点key失效了，导致大并发集中打在数据库上。所以要从两个方面解决。第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量</p>
<h3 id="解决方案-1">（3）解决方案</h3>
<h4 id="互斥锁或者队列">&lt;1&gt; 互斥锁或者队列</h4>
<p> 
在缓存失效后，通过<strong>互斥锁或者队列</strong>来控制读数据写缓存的线程数量
#### &lt;2&gt; 永不过期   热点数据缓存<strong>永不过期</strong></p>
<h2 id="缓存穿透">3、缓存穿透</h2>
<h3 id="什么是缓存穿透">（1）什么是缓存穿透</h3>
<p> 
缓存穿透是指用户请求的数据在<strong>缓存中不存在</strong>，即读请求时没有命中缓存，同时<strong>数据库也不存在该数据</strong>。导致用户每次请求该数据都要去数据库查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间内大量请求直接打在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309135630.png" style="zoom:70%;" /></p>
<h3 id="问题分析-2">（2）问题分析</h3>
<p> 
缓存穿透的关键在于在Redis中查不到key值。一般导致缓存穿透主要有两种情况：一个是业务误操作，删除了数据库和redis中的缓存；另外一个是黑客恶意攻击。假如有黑客传进大量的不存在key，那么大量的请求打在数据库上是很致命的问题。所以在日常开发中要对参数做好校验，一些非法参数，不可能存在的key就直接返回错误提示。</p>
<h3 id="解决方案-2">（3）解决方案</h3>
<h4 id="非法请求的限制">&lt;1&gt; 非法请求的限制</h4>
<p> 
在API入口处判断请求参数是否合理，请求参数是否含有非法值，请求字段是否存在，如果判断出是恶意请求则直接返回错误，避免进一步访问缓存和数据库</p>
<h4 id="将无效key存放在redis中">&lt;2&gt; 将无效key存放在Redis中</h4>
<p> 
当出现Redis查不到数据，数据库也查不到数据的情况，则把这个key保存到Redis中，这是value=“null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，不再需要查询数据库。但该方法存在一定的问题，假如传进来的不存在的key每次都是随机的，那存入Redis也没有意义</p>
<h4 id="使用布隆过滤器">&lt;3&gt; 使用布隆过滤器</h4>
<p> 
在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询key是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<blockquote>
<p>什么是布隆过滤器？</p>
<p>布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好得多，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<p>布隆过滤器原理：</p>
<ul>
<li>第一步，使用N个哈希函数分贝对数据做哈希计算，得到N个哈希值；</li>
<li>第二步，将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为1。</li>
</ul>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203643.png" style="zoom:80%;" /></p>
<blockquote>
<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机的，若采用缓存空对象方案会缓存大量不存在key的数据，并不合适。所以需要采用布隆过滤器方案，布隆过滤器先过滤掉不存在的key。针对key异常多、请求重复率比较低的数据，优先使用布隆过滤器方案。对于空数据的key有限，重复率比较高的，则优先采用缓存空对象方案</p>
</blockquote>
<h2 id="汇总">汇总</h2>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309181748.png" style="zoom:80%;" /></p>
<h2 id="缓存预热">4、缓存预热</h2>
<h3 id="什么是缓存预热">（1）什么是缓存预热</h3>
<p> 
缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，再将数据缓存的问题，用户可以直接查询事先被预热的缓存数据。若不进行预热，则Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。</p>
<h3 id="缓存预热实现方案">（2）缓存预热实现方案</h3>
<ul>
<li>数据量不大时，工程启动的时候进行加载缓存动作</li>
<li>数据量大时，设置一个定时任务脚本，进行缓存的刷新</li>
<li>数据量非常大时，优先保证热点数据进行提前加载到缓存</li>
</ul>
<h2 id="缓存降级">5、缓存降级</h2>
<p> 
缓存降级指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般时有损的操作，所以尽量减少降级对业务的影响程度。
在项目实战中，通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p>
<h1 id="三数据库缓存保持一致性">三、数据库缓存保持一致性</h1>
<blockquote>
<p>先说结论：大多数业务采用的都是<strong>【先更新数据库，再删除缓存】</strong>的
Cache
Aside（旁路缓存）策略，同时给缓存设定过期时间，防止在第二步，删除缓存数据失败导致数据不一致的问题。</p>
<p>若业务对缓存命中率有很高的要求，则可以采用【先更新数据库，再更新缓存】的方案，因为主动更新缓存可以减少缓存未命中的情况</p>
</blockquote>
<h2 id="先更新数据库还是先更新缓存">1、先更新数据库还是先更新缓存</h2>
<p> 
<strong>都不可行。</strong>无论是【先更新数据库，再更新缓存】，还是【先更新缓存，再更新数据库】，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能出现数据库和缓存中的数据不一致的情况。常见的缓存更新策略主要有三种：Cache
Aside（旁路缓存）策略；Read/Write Through（读穿 / 写穿）策略；Write
Back（写回）策略；</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309190713.png" style="zoom:50%;" /></p>
<p>但在实际开发中，Redis和MySQL的更新策略用的是Cache
Aside策略，另外两种主要是用在操作系统中。</p>
<h2 id="cache-aside旁路缓存策略">2、 Cache Aside（旁路缓存）策略</h2>
<p> 
先更新数据库数据，然后不更新缓存，直接删除缓存中的数据。等客户端要读取数据时，发现缓存中没有，再从数据库中读取数据放到缓存中。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309203658.png" style="zoom:50%;" /></p>
<h3 id="写策略">（1）写策略</h3>
<ul>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ul>
<h3 id="读策略">（2）读策略</h3>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据</li>
<li>如果读取的数据未命中缓存，则直接读取数据库中的数据，再将数据放入缓存。</li>
</ul>
<h2 id="先更新数据库还是先删缓存">2.1 先更新数据库还是先删缓存</h2>
<p> 
先说结论，<strong>先更新数据库，再删缓存</strong>。理论上来说，无论是【先更新数据库，再删除缓存】，还是【先删除缓存，再更新数据库】都会导致数据库与缓存数据不一致的问题。但为什么还是推崇【先更新数据库，再删除缓存】呢？
 
主要原因还是在【先更新数据库，再更新缓存】出现数据库与缓存数据不一致的情况较少。因为缓存的写入通常要远远快于数据库的写入。具体例子参考：<a
target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98">小林coding</a></p>
<h2 id="readwrite-through读穿-写穿策略">3、 Read/Write Through（读穿 /
写穿）策略</h2>
<p>  Read / Write
Through（读穿/写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是有缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p>
<h3 id="read-through">（1）Read Through</h3>
<p> 
先查询缓存中数据是否存在，如果存在则直接返回；如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用</p>
<h3 id="write-through">（2）Write Through</h3>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul>
<li>如果缓存中数据已存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li>
<li>如果缓存中数据不存在，则直接更新数据库，然后返回。</li>
</ul>
<h2 id="write-back写回策略">4、Write Back（写回）策略</h2>
<p>  Write
Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。【主要用于操作系统】</p>
<h2 id="小结">5、小结</h2>
<h3
id="使用先删除缓存再更新数据库">（1）使用【先删除缓存，再更新数据库】</h3>
<p>  针对【先删除缓存，再更新数据库】方案在【读 +
写】并发请求而造成缓存不一致的解决办法是<strong>【延迟双删】</strong>。就是等更新数据库的线程更新完数据库之后先睡眠一段时间，然后再删一次缓存，可以避免由于高并发使缓存中放入脏数据。但是这个睡眠时间需要大于另外一个读取数据的时间（查数据库
+ 将数据放入缓存）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br><span class="line"><span class="comment"># 更新数据库		</span></span><br><span class="line">db.update(X)</span><br><span class="line"><span class="comment"># 睡眠一段时间</span></span><br><span class="line">thread.sleep(N)</span><br><span class="line"><span class="comment"># 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure>
<h3
id="保证先更新数据库再删除缓存成功">（2）保证【先更新数据库，再删除缓存】成功</h3>
<p>为了保证【先更新数据库，再删除缓存】的第二个步骤，也就是删除缓存能成功，可以使用：</p>
<ul>
<li>消息队列重试缓存的删除，优点是保证缓存一致性问题，缺点是对业务代码入侵</li>
<li>订阅MySQL binlog + 消息队列 +
重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题。缺点是引入的组件较多，对团队的运维能力有比较高要求。</li>
</ul>
<h1 id="四redis持久化机制">四、Redis持久化机制</h1>
<p>Redis持久化数据的主要方式有两个，分别是：RDB快照和AOF日志。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250309112643.png" /></p>
<h2 id="rdb快照">1、 RDB快照</h2>
<h3 id="相关概念">【1】相关概念</h3>
<h4 id="概念和启用">（1）概念和启用</h4>
<p>记录某一瞬间的内存数据【全量快照】，记录的是实际全部数据。所以相比于AOF文件记录命令操作日志，RDB恢复数据的效率要高很多，因为直接将RDB文件读入内存即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bgsave指令</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span>     <span class="comment"># 900秒之内，对数据库进行了至少1次修改</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>		<span class="comment"># 300秒之内，对数据库进行了至少10次修改</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>	<span class="comment"># 60秒之内，对数据库进行了至少10000次修改</span></span><br></pre></td></tr></table></figure>
<p>只要满足上面条件的任意一个，就会执行bgsave。</p>
<h4 id="使用指令">（2）使用指令</h4>
<ul>
<li><code>save</code>指令，使用主线程。若写入RDB文件的时间太长，会阻塞主线程</li>
<li><code>bgsave</code>指令，使用子线程。可以避免主线程的阻塞</li>
</ul>
<h3 id="执行快照时数据能被修改吗">【2】执行快照时，数据能被修改吗</h3>
<p>（1）save指令。不行，当执行save指令时，使用的是主线程生成快照，所以此时的主线程会被阻塞，然后去执行快照操作</p>
<p>（2）bgsave指令。
可以，bgsave使用的是子线程，主线程基本不会被阻塞。</p>
<h3
id="子线程如何拥有主线程相同的数据副本">【3】子线程如何拥有主线程相同的数据副本</h3>
<p><strong>写时复制。</strong>主进程通过<code>fork</code>系统调用生成子进程。同时，操作系统会把主进程的【页表】复制一份给子进程，这个页面记录着虚拟地址和物理地址的映射关系，而不会复制物理内存，即两者的虚拟空间不同，但指向的都是同一块物理空间。当父进程或子进程在向这块物理内存发起写操作时，由于这块内存父子进程只有只读共享权限，所以CPU会触发写保护中断，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制（需要注意的是这里只会复制主进程修改的物理内存数据，没修改的物理内存数据还是和子进程共享的）</p>
<h3
id="能否保证快照和数据库数据一致性">【4】能否保证快照和数据库数据一致性</h3>
<p><strong>不能</strong>，快照只能保存快照执行那一刻的Redis所有数据。</p>
<h2 id="aof日志">2、AOF日志</h2>
<h3 id="相关概念-1">【1】相关概念</h3>
<h4 id="概念和启用-1">（1）概念和启用</h4>
<p>对于Redis的每一次<strong>写操作</strong>，都会将这次写操作追加到一个文件里。在Redis中AOF持久化功能默认是不开启的，需要我们修改
redis.conf 配置文件中的以下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// redis.conf</span><br><span class="line">appendonly       yes   // 表示是否开启AOF持久化（默认no，关闭）</span><br><span class="line">appendfilename   &quot;appendonly.aof&quot;   // AOF持久化文件的名称</span><br></pre></td></tr></table></figure>
<h4 id="先写后记录">（2）先写后记录</h4>
<p>Redis只先执行了相关的写操作指令后，才将该指令写入到aof文件中的，这样子有多个好处：</p>
<ul>
<li><p>避免额外的检查开销</p>
<p>先执行，再写。执行不通过就不写。语法有问题，或者逻辑有问题，在运行的时候就能检测出来，减少了写进aof文件前的检查时间</p></li>
<li><p>不会阻塞当前写操作命令的执行</p>
<p>当前写操作指令执行成功后，才会将命令记录到AOF日志中。</p></li>
</ul>
<h4 id="潜在风险">（3）潜在风险</h4>
<ul>
<li><p>丢失风险</p>
<p>执行写操作命令和记录日志是两个过程，并不是原子操作。若Redis在还没来得及将命令写入硬盘时，服务器宕机，这个数据就会有丢失的风险</p></li>
<li><p>可能会给【下一个】命令带来阻塞风险</p>
<p>由于Redis在写AOF文件时，是以串行的方式进行，所以对当前的写Redis的执行不会阻塞，但是后面在写AOF文件的时候一旦发生阻塞，那下一个写Redis的命令就会有阻塞风险。</p></li>
</ul>
<h3 id="三种写回策略">【2】三种写回策略</h3>
<h4 id="aof写回">（1）AOF写回</h4>
<p>在介绍AOF写回策略之前，需要先介绍一下Redis将命令写入AOF的过程。如下图所示：</p>
<p>① Redis执行完写操作命令后，会将命令追加到
<code>server.aof_buf</code>缓冲区；<br>②
通过write()系统调用，将<code>aof_buf</code>
缓冲区的数据写入到AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区<code>page cache</code>，等待内核将数据写入硬盘;
<br>③ 具体内核缓冲区的数据什么时候写入到硬盘。由内核决定。</p>
<p><img src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311141509633.png" alt="image-20250311141509633" style="zoom:50%;" /></p>
<h4 id="三种写回策略-1">（2）三种写回策略</h4>
<p>Redis主要有三种写回策略，如下图思维导图所示：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311135343.png" /></p>
<h4 id="优化局限">（3）优化局限</h4>
<p>这3种写回策略都无法完美解决【主进程阻塞】和【减少数据丢失】的问题，因为两个问题对立，就像算法题优化时间和空间一样，有得有失。具体原因如下：</p>
<ul>
<li>Always
策略，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将
AOF 内容写回硬盘，所以是不可避免会影响主进程的性能; 【适合高可靠】</li>
<li>No 策略，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于
Always 策略性能较好但是操作系统写回硬盘的时机是不可预知的，如果 AOF
日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。【适合高性能】</li>
<li>Everysec 策略的话，是折中的一种方式，避免了 Always
策略的性能开销，也比 No
策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。【折中选择】</li>
</ul>
<h4 id="实现原理">（4）实现原理</h4>
<p>在查看源码时，会发现三种策略的实现都是建立在控制<code>fsync()</code>函数的调用时机。若想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用<code>fsync()</code>函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回</p>
<ul>
<li>Always策略：每次写入AOF文件数据，都会调用<code>fsync</code>函数</li>
<li>Everysec策略：创建一个异步任务调用<code>fsync</code>函数</li>
<li>No策略：永不调用<code>fsync</code>函数</li>
</ul>
<h3 id="aof重写机制">【3】AOF重写机制</h3>
<p> 其实就是压缩AOF文件，减少AOF文件中的执行代码。AOF重写机制在重写时，会读取当前Redis中的所有键值对，然后对每一个键值s生成一条命令记录到【新的AOF文件】，等全部记录完成，将新的AOF文件替换掉现在的AOF文件。</p>
<p> 举个栗子：假如现在王五要在redis种记录自己的名字，最开始记录名字为<code>zs</code>，发现记录错了，又改成<code>lisi</code>，结果发现还是错的，又改成<code>wangwu</code>，几番折腾，此时的AOF就需要记录3条写语句，这样很多写操作都是荣冗余的。在经过AOF重写后，AOF文件只需要保存最后一条写操作就可以。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311144321.png" style="zoom:67%;" /></p>
<h3 id="aof-后台重写">【4】AOF 后台重写</h3>
<h4 id="为什么是后台完成重写">（1）为什么是后台完成重写</h4>
<p> 为什么是后台重写呢？在上文我们可以看到，Redis在写AOF的时候，都是使用了主进程，（即写Redis操作和写AOF操作都是主进程在执行）。那为什么AOF的重写需要后台执行呢？因为AOF重写，是需要从Redis中读取所有键值对，然后对再为每一个键值对生成对应的Redis写指令，写进新的AOF文件中，再替换原来的AOF文件，这个过程非常耗时，所以需要系统在后台进行，不然很容易就阻塞了实际的写Redis操作。所以Redis在进行重写的时候是<strong>由后台子进程bgrewriteaof来完成</strong>。</p>
<h4 id="为什么是子进程">（2）为什么是子进程</h4>
<p> 进程才是操作系统的资源分配最小单位。如果使用线程，那么多线程之间会共享内存，那么在修改共享内存数据时，需要通过加锁来保证数据的安全，这样会降低性能。而使用子进程，创建子进程时，父子进程是以<strong>只读</strong>的方式共享内存数据的。当父子进程任意一方修改了该共享内存，就会发生【写时复制】（复制的也只是要写入或者修改的部分），于是父子进程就有了独立的数据副本，而不用加锁来保证数据安全。</p>
<h4
id="子进程如何拥有主进程相同的数据副本">（3）子进程如何拥有主进程相同的数据副本</h4>
<p><strong>整个过程：</strong></p>
<p>① 主进程通过<code>fork</code>系统调用生成bgrewriteaof子进程。</p>
<p>②
同时，操作系统会把主进程的【页表】复制一份给子进程，这个页面记录着虚拟地址和物理地址的映射关系，而不会复制物理内存，即两者的虚拟空间不同，但指向的都是同一块物理空间。</p>
<p>③
当父进程或子进程在向这块物理内存发起写操作时，由于这块内存父子进程只有只读共享权限，所以CPU会触发写保护中断，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制（需要注意的是这里只会复制主进程修改的物理内存数据，没修改的物理内存数据还是和子进程共享的）<br>
同时，由于此时子进程还处于重写AOF状态，读取的是还是之前的Redis中的数据，所以当主进程完成写操作时，会导致子进程读取的Redis数据与最新的数据不一致，也就是有“脏读”的现象。对于这种现象，Redis也有应对措施。那就是将AOF重写期间，主进程执行的所有写指令，都写进<strong>AOF重写缓冲区</strong>。另外，Redi也会写一份在<strong>AOF缓冲区</strong>（这个是为了防止子进程宕机，原来的AOF也不会少在AOF重写时候的写指令）</p>
<p>④ 等子进程重写完成时，主进程会将 AOF
重写缓冲区的指令，追加到新的AOF文件中，然后用新的AOF文件替换原来的AOF文件，这样也就保证了AOF文件和Redis的数据一致性。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311201538.png" style="zoom:60%;" /></p>
<p><strong>问题：</strong></p>
<p>整个过程会有风险吗？有。整个过程期间会有两个阶段会导致阻塞父进程：</p>
<ul>
<li>创建子进程期间，由于要复制父今晨更多页表等数据结构，阻塞时间跟页表的大小有关，页表越大，阻塞时间越长</li>
<li>创建子进程后，若子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，若内存越大（会有大Key问题），自然阻塞的时间越长。</li>
</ul>
<h2 id="rdb和aof合体">3、RDB和AOF合体</h2>
<h3 id="相关概念-2">【1】相关概念</h3>
<p>即将RDB和AOF合体使用，该方法也叫做<strong>混合使用AOF日志和内存快照</strong>，也叫<strong>混合持久化</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes	</span><br></pre></td></tr></table></figure>
<h3 id="过程">【2】过程</h3>
<p>缓和持久化工作在<strong>AOF日志重写过程</strong>。<br>当开启了混合持久化，在AOF重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，然后主线程的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以AOF方式写入到AOF文件，写入完成后通知主进程将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。</p>
<p>换句话说，使用了混合持久化，AOF文件的前半部分时RDB格式的全量数据，后半部分时AOF格式的增量数据。</p>
<h1 id="五redis实现秒杀">五、Redis实现秒杀</h1>
<h2 id="全局唯一id">1、 全局唯一id</h2>
<p>在分布式系统中，生成全局唯一id是一个常见且重要的需求，唯一ID的生成需要满足高并发、全局唯一性和高可用性。</p>
<h3 id="需要具备的特点">（1）需要具备的特点</h3>
<ul>
<li>全局唯一性：生成的ID在整个系统中必须是唯一的，避免冲突。</li>
<li>高可用性：生成ID的服务必须具备高可用性，确保在高并发场景下不出现性能瓶颈</li>
<li>有序性：在某些场景下，需要生成的ID有一定的顺序性，以便进行排序和分析</li>
<li>高性能：生成ID的过程需要高效，能够支持高并发请求</li>
<li>安全性：生成ID要不容易被摸索出规律，防止网络攻击</li>
</ul>
<p>Redis生成全局唯一id，这是用Redis自增的方法，我们还需要拼接上其他东西，比如时间戳之类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);	</span><br></pre></td></tr></table></figure>
<h2 id="超卖问题">2、超卖问题</h2>
<h3 id="问题描述">（1）问题描述</h3>
<p> 
一般电子商务网站都会遇到如团购、秒杀、特价之类的活动，而这样的活动有一个共同的特点就是访问量激增、上千甚至上万人抢购一个商品。然而，作为活动商品，库存肯定是很有限的，如何控制库存不让出现超买，以防止造成不必要的损失是最基本的问题。</p>
<h3 id="产生原因">（2）产生原因</h3>
<p> 
在多个用户同时发起对同一个商品的下单请求时，先查询商品库存，再修改商品库存，会出现资源竞争问题，导致库存的最终结果出现异常。问题：
当商品A一共有库存15件，用户甲先下单10件，用户乙下单8件，这时候库存只能满足一个人下单成功，如果两个人同时提交，就出现了超卖的问题。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310094729.png" style="zoom:67%;" /></p>
<h3 id="解决方案-3">（3） 解决方案</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310095101.png" style="zoom: 60%;"></p>
<h4 id="悲观锁">【1】 悲观锁</h4>
<p> 
悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁</p>
<h4 id="乐观锁">【2】 乐观锁</h4>
<p> 会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1
，如果大1
，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1
，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas.</p>
<p> 乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5
是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 ==
内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值。 其中do
while
是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CAS一般是Java虚拟机在实现JUC的时候使用的，Java在UnSafe文件中编写了很多直接调用系统底层函数的功能方法，该类中就实现了CAS。</p>
<p>对于一般的超卖问题，主流方法还是使用乐观锁或者基于Redis的lua脚本进行解决</p>
</blockquote>
<h3 id="衍生改良">（4）衍生改良</h3>
<h4 id="问题">【1】问题</h4>
<p> 对于电商的超卖问题，如果只是简单让程序在扣减库存时，判断库存与操作前的数值是否一致，会导致其他大量并发操作失败。比如现在有100个进程打进来，查询到剩余的库存都是1000个，经过一顿操作后，现在要执行扣减库存的操作。此时我们采用了乐观锁进行更新，如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set 库存 = 库存 - 1 where id = 1 and 库存 = 1000</span><br></pre></td></tr></table></figure>
<p> 如果更新方式如上所述，那么程序在运行时，因为我们的程序并没有像CAS那样子实现自旋操作，所以这打进来的100个进程就只有一个会成功。这对用户的使用体验是非常不好的。</p>
<h4 id="解决">【2】解决</h4>
<p>我们需要改良一下数据库的执行操作，对于库存而言，只要库存大于0，我们就能卖。所以，没必要每个线程更新时都要确保当前库存跟操作前的库存一样，于是可以调整代码成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set 库存 = 库存 - 1 where id = 1 and 库存 &gt; 0</span><br></pre></td></tr></table></figure>
<h2 id="一人一单">3、一人一单</h2>
<h3 id="问题描述-1">（1）问题描述</h3>
<p>  很多时候有些商家要拿出一部分好用且贵重的产品来做促销引流，而将该物品进行低价售出，此时为了防止有人恶意低买高卖以及保证引流的效果，我们要保证一个用户只能买一次，也就一人一单.</p>
<h3 id="产生原因-1">（2）产生原因</h3>
<p> 一人一单的实现步骤是在原来下单逻辑的判断库存是否足够之后去查询数据库看是否该用户的是否已经存在订单，如果存在则不能下单成功，如果不存在则继续下单。</p>
<p> 由于该物品的特殊性，当开始秒杀时的并发量是极高的，这就会产生这样的问题，多个线程查询库存后判断该用户是否存已经存在订单时，此时这些线程都没有查询到订单信息说明该用户未下过单，让这些线程进行后续下单操作，但是在查询后有线程下单成功了，但是其他线程已经判断为未下过单，还在进行后续的下单操作，这就导致一个用户下单好几次</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310134922.png" style="zoom:50%;" /></p>
<h3 id="解决方案-4">（3）解决方案</h3>
<p>【1】解决一</p>
<p> 可以将上述的<strong>查询是否下过单与后续的库存扣减操作进行加锁</strong>。但在加锁时需要控制好锁的粒度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="comment">// 查询是否已经下单</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【2】问题一</p>
<p> 如果给方法加锁，对于每一个用户进程，进入程序时都需要进行锁竞争，这样对导致同一时间只有一个用户的进程可以执行操作，直接把并发执行变成了用户排队执行（串行执行）</p>
<p>【3】解决二</p>
<p> 一人一单的线程安全问题，其实是单个用户在同一时间触发了多个线程访问的问题，所以我们加锁的粒度可以针对单个用户进行加锁，那么，我们可以获取用户id，对用户id进行加锁。需要注意的时，用户id是一个String的字符串变量，如果我们直接使用userId.toString()
他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法。我们的代码就可以修改成如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactionl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 查询是否已经下单</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 扣减库存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【4】问题二</p>
<p>  上述加锁在很大程度上保证了一人一单的线程安全问题，但是还有一种情况，就是上述我们提到的线程1进行操作后把锁释放了，但是事务还没提交也就是数据库中已下单还没有订单信息，此时线程2获取到了锁，查询数据库中是否存在订单信息时没有查询到，于是又去进行了扣减库存操作，此时该用户一个人又下了多单。</p>
<p>【5】解决三</p>
<p>  上述问题产生的原因是，锁释放在事务提交之前。我们需要做的就是保证锁释放在事务提交之后，我们可以将加锁的位置进行修改，在调用该方法的地方进行加锁。修改后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询库存判断是否足够</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 查询是否已下单与扣减库存</span></span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        createVoucherOrder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Transactionl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询是否已经下单</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 扣减库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式问题">（4）分布式问题</h3>
<p> 上述悲观锁解决思路可以解决单机环境下的线程安全问题，但是在集群模式下就不行了，在不同的服务器进行部署该服务时，由于不同服务器有着不同的JVM，其线程锁的监视器也不同，所以加锁不能解决集群环境下的安全问题</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141541.png" style="zoom:50%;" /></p>
<h2 id="分布式锁">4、分布式锁</h2>
<h3 id="基本原理">（1）基本原理</h3>
<p> 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁需要具备多进程可见、互斥、高可用、高性能、安全性等特点。分布式锁的核心思想是让各个服务器使用同一把锁，只要使用的都是同一把锁，就能锁住线程，不让线程执行。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310141854.png" style="zoom:50%;" /></p>
<h3 id="基本方法">（2）基本方法</h3>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310142616.png" style="zoom:67%;" /></p>
<h3 id="实现代码">（3）实现代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁，并设置超时时间，防止死锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在问题">（4）存在问题</h3>
<h4 id="redis分布式锁误删">【1】Redis分布式锁误删</h4>
<p><strong>问题：</strong>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143057.png" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143251.png" style="zoom:50%;" /></p>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分布式锁原子性问题">【2】分布式锁原子性问题</h4>
<p><strong>问题：</strong>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310143500.png" style="zoom:50%;" /></p>
<p><strong>解决方案：</strong>那就是使用Redis提供的Lua脚本，把<strong>判断锁和释放锁变成一个原子操作</strong></p>
<p>实现代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &lt; unlick.lua &gt;</span></span><br><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分布式锁--redission">5、分布式锁--Redission</h2>
<h3 id="引言">（1）引言</h3>
<p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指
获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong>
如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144256.png" style="zoom:50%;" /></p>
<h3 id="什么是redission">（2）什么是Redission</h3>
<p> Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory
Data
Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310144414.png" style="zoom: 80%;" /></p>
<h3 id="分布式锁redisson---可重入锁原理">（3）分布式锁Redisson--
可重入锁原理</h3>
<blockquote>
<p>ReentrantLock实现可重入锁原理：借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1
。</p>
<p>如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1
，直到减少成0 时，表示当前这把锁没有被人持有。</p>
</blockquote>
<p> 其实实现的原理跟ReentrantLock是一样的，都是借助计数变量，记录重入次数，实现可重入。实现原理大致是这样的：采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，最终的value记录的就是重入次数。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310145407.png" style="zoom:50%;" /></p>
<p><strong>代码实现：</strong>Redission底层实现可重入锁，也是借助了Lua脚本实现的，这样可以保证其执行的原子性。</p>
<p>——加锁实现代码：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310151049.png" style="zoom: 67%;" /></p>
<p>——释放锁实现代码：</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311140348.png" style="zoom:67%;" /></p>
<h3 id="分布式锁ression-锁重试和watchdog机制">（4）分布式锁Ression ——
锁重试和WatchDog机制</h3>
<blockquote>
<p>获取锁失败，就会启动【锁重试】机制，不断询问锁是否释放。
获取锁成功，就会启动【WatchDog机制】，保证当前线程的任务执行完成。</p>
</blockquote>
<h4 id="原理">【1】原理</h4>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310165123.png" style="zoom:67%;" /></p>
<h4 id="源码解析">【2】源码解析</h4>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span></span><br></pre></td></tr></table></figure>
<p>waitTime –
获取锁的最大等待时间，<strong>不设置就只尝试获取锁一次，不会重试</strong>
leaseTime –
租约时间，约定使用锁时间，到期锁自动释放。不设定则会自动采用看门狗机制，自动续费
unit – 时间单位</p>
</blockquote>
<p>①
抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这线程已经抢锁完毕，或者可重入完毕。但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，可以发现有个while(
true) 再次进行tryAcquire进行抢锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② tryAcquire中有条件分支，如果 leaseTime 为
-1，则表示不设定租锁时间，也就是这把锁得借到当前进程执行完成后才能释放。那Redission是怎么实现的呢？Redission也是照常会去获取锁，有所区别的是，如果不设定租锁时间(leaseTime)，那么Redission
会启动看门狗机制，自动延长租锁时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设定了租锁时间，那就将其设置为借锁的时间，到期锁自动释放</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不设置，就启用看门狗机制</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                                         commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                                         TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 看门狗机制刷新租锁时间</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③
看门狗逻辑：因为【看门狗机制】锁的失效时间是30s，当10s之后，此时这个timeTask
就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约。那么假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式锁redission-mutilock原理">（5）分布式锁Redission ——
MutiLock原理</h3>
<blockquote>
<p>解决主从一致性问题！</p>
</blockquote>
<h4 id="原理-1">【1】原理</h4>
<p> 为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例。此时我们去写命令，写在主机上，
主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163322.png" style="zoom:50%;" /></p>
<p> 为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的，
这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310163403.png" style="zoom:40%;" /></p>
<h4 id="源码解析-1">【2】源码解析</h4>
<p>① 创建联锁 multilock，就是将传入的lock用一个数组去存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;RLock&gt; locks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedissonMultiLock</span><span class="params">(RLock... locks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (locks.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Lock objects are not defined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.locks.addAll(Arrays.asList(locks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 获取锁时，会挨个访问每个节点，对每个节点，都获取一遍锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">// 若获取锁失败，则会释放掉已经获取的那些节点的锁</span></span><br><span class="line">    <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">        time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            unlockInner(acquiredLocks);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置了重试机制</span></span><br><span class="line">    <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        unlockInner(acquiredLocks);</span><br><span class="line">        <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有设置等待获取锁时间，表示只想获取一次，则获取失败的话直接退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是了等待时间</span></span><br><span class="line">        failedLocksLimit = failedLocksLimit();</span><br><span class="line">        acquiredLocks.clear();</span><br><span class="line">        <span class="comment">// reset iterator</span></span><br><span class="line">        <span class="comment">// 重试的时候重新开始</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">            iterator.previous();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        failedLocksLimit--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取锁成功</span></span><br><span class="line"><span class="comment">// 若设置了租锁时间，会对每一个节点上的锁，设置一个锁的有效时间</span></span><br><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(acquiredLocks.size());</span><br><span class="line">    <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span><br><span class="line">        RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">        futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class="line">        rFuture.syncUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="六redis消息队列">六、Redis消息队列</h1>
<h2 id="认识消息队列">1、 认识消息队列</h2>
<p>即存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310172219.png" /></p>
<p>使用队列的好处在于<strong>解耦</strong>：所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message
Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<h2 id="基于list实现消息队列">2、 基于List实现消息队列</h2>
<h3 id="实现原理-1">（1）实现原理</h3>
<p>消息队列（Message
Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者
RPUSH 结合
LPOP来实现。不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310213814.png" /></p>
<h3 id="优缺点">（2）优缺点</h3>
<p>优点：① 利用Redis存储，不受限于JVM内存上限； ②
基于Redis的持久化机制，数据安全性有保证； ③ 可以满足消息有序性</p>
<p>缺点：① 无法避免消息丢失； ②只支持单消费者</p>
<h2 id="基于pubsub的消息队列">3、基于PubSub的消息队列</h2>
<h3 id="实现原理-2">（1）实现原理</h3>
<p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p>SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg
：向一个频道发送消息 PSUBSCRIBE pattern[pattern]
：订阅与pattern格式匹配的所有频道</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250310213954.png" /></p>
<h3 id="优缺点-1">（2）优缺点</h3>
<p>优点：采用发布订阅模型，支持多生产、多消费</p>
<p>缺点：① 不支持数据持久化； ② 无法避免消息丢失； ③
消息堆积有上限，超出时数据丢失</p>
<h2 id="基于stream的消息队列">4、基于Stream的消息队列</h2>
<p>Stream 是 Redis 5.0
引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311084806.png" /></p>
<p>例如</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085207.png" /></p>
<p>读取消息的方式之一：XREAD</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085146.png" /></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085241.png" /></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311085304.png" /></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<figure>
<img
src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311085324492.png"
alt="image-20250311085324492" />
<figcaption aria-hidden="true">image-20250311085324492</figcaption>
</figure>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h2
id="基于stream的消息队列消费者组">5、基于Stream的消息队列—消费者组</h2>
<p>消费者组（Consumer
Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311091741.png" /></p>
<p>创建消费者组：</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311091835.png" /></p>
<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其他命令：</p>
<p><strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>
<p><strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>
<p><strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>
<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：
<ul>
<li>"&gt;"：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul></li>
</ul>
<p>消费者监听消息的基本思路：</p>
<p><img src="C:\Users\28778\AppData\Roaming\Typora\typora-user-images\image-20250311092621147.png" alt="image-20250311092621147" style="zoom:50%;" /></p>
<p>列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<h2 id="对比">6、对比</h2>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311092658.png" /></p>
<h1 id="七点赞收藏和关注">七、点赞、收藏和关注</h1>
<p>实现方式比较简单，都是通过利用Redis的set集合判断是否已经点赞、或者已经收藏、或者已经关注</p>
<p>这里贴一个demo代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关注实现</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">followUser</span><span class="params">(FollowAddVO addVO)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">channel</span> <span class="operator">=</span> addVO.getChannel();</span><br><span class="line">    <span class="comment">// 构造redis的key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">currentId</span> <span class="operator">=</span> ThreadLocalUtil.getCurrentId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FollowConstant.followKey + addVO.getUid();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">zScore</span> <span class="operator">=</span> redisUtils.zScore(key, currentId);</span><br><span class="line">    <span class="comment">// 先判断能不能关注</span></span><br><span class="line">    <span class="keyword">if</span> ((Objects.nonNull(zScore) &amp;&amp; CollectionConstant.OperateEnum.ON_COLL.getCode().equals(channel))</span><br><span class="line">        || (Objects.isNull(zScore) &amp;&amp; CollectionConstant.OperateEnum.DOWN_COLL.getCode().equals(addVO.getChannel()))) &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CollectionConstant.OperateEnum.ON_COLL.getCode().equals(channel)) &#123;</span><br><span class="line">        <span class="comment">// 实现关注逻辑，并将关注的关系加入到redis中</span></span><br><span class="line">        <span class="keyword">return</span> redisUtils.zAdd(key, currentId, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消关注</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionConstant.OperateEnum.DOWN_COLL.getCode().equals(addVO.getChannel())) &#123;</span><br><span class="line">        <span class="comment">// 实现取消关注的数据库逻辑，并将redis中的关注关系删除</span></span><br><span class="line">        <span class="keyword">return</span> redisUtils.zRemove(key, currentId) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八geo数据结构计算距离">八、GEO数据结构计算距离</h1>
<blockquote>
<p>使用Redis的GEO数据机构进行统计</p>
</blockquote>
<h2 id="geo数据结构基本用法">1、 GEO数据结构基本用法</h2>
<p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。
6.2.新功能</li>
</ul>
<h2 id="存入redis中的数据结构定义">2、存入Redis中的数据结构定义</h2>
<p> GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p> 但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105501.png" style="zoom:50%;" /></p>
<h1 id="九redis实现签到功能">九、Redis实现签到功能</h1>
<blockquote>
<p>使用Redis的BitMap实现</p>
</blockquote>
<h2 id="bitmap数据机构基本用法">1、BitMap数据机构基本用法</h2>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD
：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h2 id="实现原理-3">2、实现原理</h2>
<p> 我们按月来统计用户签到信息，签到记录为1，未签到则记录为0。把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示。Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是
2^32个bit位。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311105928.png" /></p>
<h2 id="功能点实现">3、功能点实现</h2>
<p><strong>问题1：</strong>什么叫做连续签到天数？
从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20250311110039.png" /></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1
才是1，其他数字都是0
，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<h2
id="关于使用bitmap来解决缓存穿透的方案">4、关于使用BitMap来解决缓存穿透的方案</h2>
<p>实现原理跟布隆过滤器是基本一样的，都是通过Hash，将物料的主键id映射成位图能够记录的idx，然后在位图中标识出来。等要判断是当前查询主键id是否存在时，再将当前主键id进行Hash，看是否在位图中被标注。若被标注，则可以访问，若没有，则拒绝访问。布隆过滤器的区别主要是，可能布隆过滤器会多用几个Hash函数。</p>
<h1 id="十uv统计">十、UV统计</h1>
<h2 id="uv和pv">1、UV和PV</h2>
<ul>
<li>UV：全称Unique
Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page
View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<h2 id="hyperloglog-算法原理">2、HyperLogLog 算法原理</h2>
<p><a
target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">参考文章</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>旺仔
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ych1016.github.io/2025/03/09/Java/Redis%E5%AE%9E%E6%88%98/" title="Redis应用">https://ych1016.github.io/2025/03/09/Java/Redis实战/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/username">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/channel_name">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
      </div>

      <div class="social-item">
          <span class="social-link">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </span>

          <img class="social-item-img" src="/images/wechat_channel.png">
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"># 中间件</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/03/02/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E7%83%AD%E9%A2%98100/" rel="prev" title="【力扣】热题100">
                  <i class="fa fa-angle-left"></i> 【力扣】热题100
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/03/12/Hexo/hexo%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/" rel="next" title="hexo基本指令">
                  hexo基本指令 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">旺仔</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">74k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:28</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
