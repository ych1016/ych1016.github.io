<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ych1016.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":300,"width_dual_column":200,"display":"always","padding":20,"offset":200},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/./public/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":7,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="主要记录旺仔的一些刷题思路，以及相关的代码实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="【力扣】面试经典150题">
<meta property="og:url" content="https://ych1016.github.io/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/index.html">
<meta property="og:site_name" content="攻城狮-旺仔">
<meta property="og:description" content="主要记录旺仔的一些刷题思路，以及相关的代码实现。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/1.png">
<meta property="article:published_time" content="2024-12-01T15:53:25.000Z">
<meta property="article:modified_time" content="2025-03-09T12:54:19.454Z">
<meta property="article:author" content="旺仔">
<meta property="article:tag" content="力扣">
<meta property="article:tag" content="面试经典150题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/1.png">


<link rel="canonical" href="https://ych1016.github.io/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ych1016.github.io/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/","path":"2024/12/01/Algorithm/【力扣】面试经典150题/","title":"【力扣】面试经典150题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【力扣】面试经典150题 | 攻城狮-旺仔</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">攻城狮-旺仔</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本站为攻城狮旺仔个人博客，仅记录日常编程笔记使用，欢迎各位大佬共同交流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-日程"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程</a></li><li class="menu-item menu-item-成就"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>成就</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8-150-%E9%A2%98"><span class="nav-text">一、力扣面试经典 150 题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">1. 数组&#x2F;字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">1.1 合并两个有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%E2%85%B1"><span class="nav-text">1.4 删除有序数组中的重复项
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-text">1.5 多数元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#h-%E6%8C%87%E6%95%B0"><span class="nav-text">1.11 H
指数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#o1%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="nav-text">1.12 O(1)时间插入、删除和获取随机元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-text">1.13 除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-text">1.14 加油站</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-text">1.15 分发糖果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-text">1.16 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-text">1.17 罗马数字转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="nav-text">1.18 整数转罗马数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">1.19 最后一个单词的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-text">1.20 最长公共前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-text">1.21 反转字符串中的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="nav-text">1.22 Z
字形变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="nav-text">1.23 找出字符串中第一个匹配项的下标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">2. 双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-text">2.1 验证回文串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">2.2 判断子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E2%85%B1---%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">2.3 两数之和
Ⅱ - 输入有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">2.4 盛最多水的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">2.5 三数之和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">3. 滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">3.1 长度最小的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-text">3.2 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">3.3 最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">3.4 回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text">3.5 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="nav-text">3.6 串联所有单词的子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-text">4. 矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC"><span class="nav-text">4.1 有效数独</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-text">4.2 螺旋矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-text">4.3 旋转图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="nav-text">4.4 矩阵置零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F"><span class="nav-text">4.5 生命游戏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">5. 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="nav-text">5.1 赎金信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.2 同构字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B"><span class="nav-text">5.3 单词规律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E7%9A%84%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text">5.4 有效字母的异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-text">5.5 字母异位词分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">5.6 两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-text">5.7 快乐数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">5.8 存在重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-%E2%85%B1"><span class="nav-text">5.9 存在重复元素
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-text">5.10 最长连续序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4"><span class="nav-text">6. 区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4"><span class="nav-text">6.1 汇总区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-text">6.2 合并区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4"><span class="nav-text">6.3 插入区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="nav-text">6.4 用最少数量的箭引爆气球</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">7. 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-text">7.1 有效括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="nav-text">7.2 简化路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-text">7.3 最小栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">7.4 逆波兰表达式求值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-text">7.5 基本计算器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">8. 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">8.1 环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-text">8.2 两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">8.3 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">8.4 随机链表的复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">8.5 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E2%85%B1"><span class="nav-text">8.6 反转链表
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k-%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">8.7 K
个一组反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">8.8 删除链表的倒数第
N 个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">8.9 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-%E2%85%B1"><span class="nav-text">8.10 删除排序链表中的重复元素
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">8.11 旋转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-text">8.12 分隔链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru-%E7%BC%93%E5%AD%98"><span class="nav-text">8.13 LRU
缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9. 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">9.1 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-text">9.2 相同的树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9.3 翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9.4 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9.5 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9.6 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-%E2%85%B1"><span class="nav-text">9.7 填充每个节点的下一个右侧节点指针
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-text">9.8 二叉树展开为链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-text">9.9 路径总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-text">9.10 求根节点到叶节点数字之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-text">9.11 二叉树的直径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-text">9.12 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">9.13 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3"><span class="nav-text">9.14 二叉搜索树迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0"><span class="nav-text">9.15 完全二叉树的节点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">9.16 二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-text">10. 二叉树层次遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-text">10.1 二叉树的右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-text">10.2 二叉树的层平均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">10.3 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-text">10.4 二叉树的锯齿形层次遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">11. 二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-text">11.1 二叉搜索树的最小绝对差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">11.2 验证二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">11.3 二叉搜索树中第
k 小的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">12. 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-text">12.1 岛屿的最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-text">12.2 岛屿数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="nav-text">12.3 岛屿的周长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">12.4 所有可能的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="nav-text">12.5 被围绕的区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E5%9B%BE"><span class="nav-text">12.6 克隆图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="nav-text">12.7 除法求值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-text">12.8 课程表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8-%E2%85%B1"><span class="nav-text">12.9 课程表
Ⅱ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">13. 图的广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9B%87%E6%A2%AF%E6%A3%8B"><span class="nav-text">13.1 蛇梯棋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96"><span class="nav-text">13.2 最小基因变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="nav-text">13.3 单词接龙</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="nav-text">14. 字典树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-trie%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-text">14.1 实现
Trie（前缀树）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D---%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">14.2 添加与搜索单词
- 数据结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E2%85%B1"><span class="nav-text">14.3 单词搜索
Ⅱ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-text">15. 回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-text">15.1 电话号码的字母组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-text">15.2 组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">15.3 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-text">15.4 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-%E7%9A%87%E5%90%8E-%E2%85%B1"><span class="nav-text">15.5 N
皇后 Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E"><span class="nav-text">15.6 八皇后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-text">15.7 单词搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-text">15.8 括号生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB"><span class="nav-text">16. 分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">16.1 将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">16.2 排序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91"><span class="nav-text">16.3 建立四叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kadane%E7%AE%97%E6%B3%95"><span class="nav-text">17. Kadane算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text">17.1 最大子数组和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">17.2 环形子数组的最大和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">18. 二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-text">18.1 搜索插入位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-text">18.2 搜索二维矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-text">18.3 寻找峰值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">18.4 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-text">18.5 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">18.6 寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">18.7 寻找两个正序数组的中位数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">19. 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-text">19.1 数组中的第
K 个最大元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipo"><span class="nav-text">19.2 IPO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E5%AF%B9%E6%95%B0%E5%AD%97"><span class="nav-text">19.3 查找和最小的
K 对数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">19.4 数据流的中位数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">20. 位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="nav-text">20.1 二进制求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="nav-text">20.2 颠倒二进制数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">20.3 位
1 的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">20.4 只出现一次的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-%E2%85%B1"><span class="nav-text">20.5 只出现一次的数字
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="nav-text">20.6 数字范围按位与</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-text">21. 数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-text">21.1 回文数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E4%B8%80"><span class="nav-text">21.2 加一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="nav-text">21.3 阶乘后的零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-text">21.4 x
的平方根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#powxn"><span class="nav-text">21.5 Pow(x,n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-text">21.6 直线上最多的点数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">22.动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-text">22.1 爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-text">22.2 打家劫舍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text">22.3 单词拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-text">22.4 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">22.5 最长递增子序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">23. 多维动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-text">23.1 三角形最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-text">23.2 最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E2%85%B1"><span class="nav-text">23.3 不同路径
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">23.4 交错字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-text">23.5 编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E2%85%B1"><span class="nav-text">23.6 买卖股票的最佳时机
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E2%85%B2"><span class="nav-text">23.7 买卖股票的最佳时机
Ⅲ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E2%85%B3"><span class="nav-text">23.8 买卖股票的最佳时机
Ⅳ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA-1-%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-text">23.9 统计全为
1 的正方形子矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-text">23.10 最大正方形</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="旺仔"
      src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/11zon_cropped.png">
  <p class="site-author-name" itemprop="name">旺仔</p>
  <div class="site-description" itemprop="description"><font color="#FFFFFF"; size=5px> 允许一切发生！</font></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ych1016" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ych1016" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2877816340@qq.com" title="E-Mail → mailto:2877816340@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ych1016.github.io/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/11zon_cropped.png">
      <meta itemprop="name" content="旺仔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="攻城狮-旺仔">
      <meta itemprop="description" content="<font color="#FFFFFF"; size=5px> 允许一切发生！</font>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【力扣】面试经典150题 | 攻城狮-旺仔">
      <meta itemprop="description" content="主要记录旺仔的一些刷题思路，以及相关的代码实现。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【力扣】面试经典150题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-01 23:53:25" itemprop="dateCreated datePublished" datetime="2024-12-01T23:53:25+08:00">2024-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-09 20:54:19" itemprop="dateModified" datetime="2025-03-09T20:54:19+08:00">2025-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:46</span>
    </span>
</div>

            <div class="post-description">主要记录旺仔的一些刷题思路，以及相关的代码实现。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>🚩 学如逆水行舟，不进则退。 —— 《增广贤文》</p>
</blockquote>
<h1 id="一力扣面试经典-150-题">一、力扣面试经典 150 题</h1>
<h2 id="数组字符串">1. 数组/字符串</h2>
<h3 id="合并两个有序数组">1.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">合并两个有序数组</a></h3>
<p>这道题目主要是利用到归并排序的思路，定义两个数组下标，比较数组对应的值，选择小的值插进新数组。需要注意的是，while
循环后还需要把剩下的数组遍历下去。这里还有一个点需要注意，就是 Java
的函数传参和数组赋值问题，Java
函数传递数组时，传进来的是数组地址，所以如果只是简单的给数组赋值新的数组，实际的数组并不会发生改变
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) res[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> res[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) res[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) res[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (m + n &gt;= <span class="number">0</span>) System.arraycopy(res, <span class="number">0</span>, nums1, <span class="number">0</span>, m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">移除元素</a></p>
<p>这个就是一个简单的双指针问题，我们只需要记录不等于给定值的下标，然后遍历数组，只要数值不等于给定值的数字，我们就使用初始定义的下标记录下来
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除有序数组中的重复元素</a></p>
<p>这道题目跟上面的题目一样，相当于上面是要记录不等于指定值，也就是重复值为
0。这道题目则是允许重复值为 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!record.contains(nums[i])) &#123;</span><br><span class="line">            record.add(nums[i]);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除有序数组中的重复项-ⅱ">1.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除有序数组中的重复项
Ⅱ</a></h3>
<p>这道题目也是跟上面题目一样的思路。上一道题目是允许重复值为
1，这道题目是允许重复值为 2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!record.containsKey(nums[i])) &#123;</span><br><span class="line">            record.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(record.get(nums[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">            record.put(nums[i], <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多数元素">1.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">多数元素</a></h3>
<p>多数元素是出现次数超过数组长度一半的数。这道题目可以用相互抵消的思路来理解。因为它出现的次数多于总体一半，所以它与其他数出现次数相互抵消后，就一定还会存在这个数
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num) cnt++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                num = nums[i];   cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&amp;envId=top-interview-150">轮转数组</a></p>
<p>这道题目的主要思路是利用到数组反转的原理。其实原理很简单，要将数组中的元素整体向右移
k 个单位，只需要将整个数组，整体反转，然后分别反转前 k 位和后 k 位
<strong>eg：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    reverArray(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;  end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机</a>
这道题目因为给了全部的天数数据，所以具有预知性，所以，我们可以从后开始遍历数组，记录后面哪一天是出价最高的
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length, maxNum = prices[n-<span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res = Math.max(res, maxNum - prices[i]);</span><br><span class="line">        maxNum = Math.max(maxNum, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅱ</a>
因为可以多次购买，多次出售。这道题目跟前面的题目就不一样了。我们并不需要考虑什么时候出售，我们只需要在有差价，能挣钱的时候出售就可以
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>]) res += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.9 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&amp;envId=top-interview-150">跳跃游戏</a>
初看题目像是要遍历很多次，其实不用。我们只需要维护一个距离变量。表示从当前所在下标能到达的最远距离即可。若当前下标比最远距离还要大，说明前面的点，没办法到达当前下标的位置，也就是不可能完成这个跳跃任务，我们直接返回
false 即可 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 1.10 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">跳跃游戏
Ⅱ</a> 这一道题目的主要思路就是看当前所在位置能到达多远的距离，end
暂存下来，相当于从当前位置跳到 end
只需要一步，然后逐步更新能到达的最远距离。当当前位置到达 end
时，说明这一步能到达的最远距离已经更新完了，也就是需要再跳一次了，这样就能记录下所需要的最少跳数
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        k = Math.max(k, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            res++;   end = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="h-指数">1.11 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/h-index/?envType=study-plan-v2&amp;envId=top-interview-150">H
指数</a></h3>
<p>这道题目其实用的是一个桶计数思路，但是这里有一个需要注意的是，当一篇文章的被引用次数超过实际数组长度时，我们只需要把它看成引用次数是数组长度就可以，这样可以减少很大的内存空间。然后桶主要记录的是引用次数对应出现的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> citation : citations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citation &gt; n) cnt[n]++;</span><br><span class="line">        <span class="keyword">else</span> cnt[citation]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        total += cnt[i];</span><br><span class="line">        <span class="keyword">if</span>(total &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="o1时间插入删除和获取随机元素">1.12 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&amp;envId=top-interview-150">O(1)时间插入、删除和获取随机元素</a></h3>
<p>这道题目主要用到一个 Hash 映射，通过可变数数组进行实现。但是这里用到
HashMap 集合，会让人感觉不是在 O(1)的时间内完成的操作。其实是 O(1)，因为
HashMap 的插入和删除，都是围绕下标进行，而 hash
获取下标只需要一个函数的映射操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(val);</span><br><span class="line">        map.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.set(map.get(val), nums.get(nums.size() - <span class="number">1</span>));</span><br><span class="line">        map.put(nums.get(nums.size() - <span class="number">1</span>), map.get(val));</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get(random.nextInt(nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除自身以外数组的乘积">1.13 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&amp;envId=top-interview-150">除自身以外数组的乘积</a></h3>
<p>这道题目本来可以用前缀积做，但是题目要求不能使用除法，所以这道题目需要在前缀积的基础上稍加改变一下。我们只需要定义一个中间变量，先将最终答案置为这个中间变量再进行前缀积，实现在当前位置赋值时，是前面变量的乘积。同时由于题目要求，是除当前位置的其他所有变量的乘积，所以需要从左向右走一遍，然后再从右向左走一遍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res[i] = left;</span><br><span class="line">        left = left * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        res[i] *= right;</span><br><span class="line">        right = right * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加油站">1.14 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&amp;envId=top-interview-150">加油站</a></h3>
<p>这道题目其实并不需要去每一个点进行探索，只需要计算 gas 和 cost
的差值的前缀和就能解决这个问题。<strong>因为只要差值
&gt;=0，就一定能绕圈走。</strong>所以我们的解题的最终目标变成了，探索从哪一个点开始出发。探索从哪个点开始出发也比较简单，我们看前缀和在哪里
&lt;0
了，说明在它前面的点出发是走不到当前的点的，所以出发点肯定需要从这个点的下一个点开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length, run = <span class="number">0</span>, sum = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        run += gas[i] - cost[i];</span><br><span class="line">        sum += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span> (run &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            run = <span class="number">0</span>;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= <span class="number">0</span> ? start : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分发糖果">1.15 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&amp;envId=top-interview-150">分发糖果</a></h3>
<p>两者兼顾很容易顾此失彼。如果想用一次遍历就解决问题，就必须时刻注意当前数左右两边的数，并且如果从左到右遍历，没发预测右边还未遍历的数字是否还会受到奖励。所以我们需要分开考虑，先走一遍从左到右，考虑左边数字对右边数字的影响，然后再走一遍从右到左，考虑右边数字对左边数字的影响。然后需要满足左边走得通，右边也得走得通，怎么办呢，各个位置上的数取从左到右，从右到左的最大值，就能实现两边都满足。</p>
<table>
<tr>
<td>
[1 0 2]<br/>[1 1 1] <br/>[1 1 2]<br/>[2 1 1]<br/>[2 1 2] 2+1+2 = 5<br/>
</td>
</tr>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">    <span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        num1[i] = num2[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num1[i] = num1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            num2[i] = num2[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res += Math._max_(num1[i], num2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接雨水">1.16 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h3>
<p>这道题目的求解思路主要是，遍历数组，我们需要当前遍历位置，左边和右边最高的数值，然后对于这两个数值，去它们当中更小的那个数值（木桶效应），取出来之后需要减去当前位置的高度，算出差值。按照这种思路，我们需要多定义两个数组，分别记录当前位置左边的最大高度
leftMax[n]，和当前位置右边最大的高度
rightMax[n]，这样在遍历到当前位置时，当前位置的蓄水值为
min{rightMax[i],leftMax[i]} -
heigh[i]。然后我们会发现这种思路其实有一种更简洁的做法，我们不需要多定义两个额外的数组，只需要定义两个变量即可，分别记录
0...i 左边的最大高度 leftMax，和 i+1 ... n-1 的最大高度 rightMax，这样当
leftMax &lt; rightMax 时，我们更新左边；当 leftMax &gt; rightMax
时，我们更新右边；当 leftMax = rightMax
时，我们两边都更新。因为每次计算蓄水值时，我们都是拿 leftMax 和 rightMax
更小的那个值去更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, res = <span class="number">0</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">        rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightMax &lt; leftMax)&#123;</span><br><span class="line">            res += rightMax - height[right--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 两边都更新</span></span><br><span class="line">            res += leftMax - height[left++];</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right) &#123;</span><br><span class="line">                res += rightMax - height[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="罗马数字转整数">1.17 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/roman-to-integer/submissions/521990974/?envType=study-plan-v2&amp;envId=top-interview-150">罗马数字转整数</a></h3>
<p>比较简单的模拟题目...</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(array[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; map.get(array[i]) &lt; map.get(array[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            temp = map.get(array[i+<span class="number">1</span>]) - map.get(array[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数转罗马数字">1.18 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-to-roman/?envType=study-plan-v2&amp;envId=top-interview-150">整数转罗马数字</a></h3>
<p>经典打表问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">            roman.append(symbols[i]);</span><br><span class="line">            num -= values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roman.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后一个单词的长度">1.19 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&amp;envId=top-interview-150">最后一个单词的长度</a></h3>
<p>模拟题，定义一个
StringBuilder，只需要从最后一个字符开始遍历，若不是空格，就开始记录下来，直到再遇到空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] == <span class="string">&#x27; &#x27;</span>) --i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; charArray[i] != <span class="string">&#x27; &#x27;</span>) res.append(charArray[i--]);</span><br><span class="line">    <span class="keyword">return</span> res.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共前缀">1.20 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&amp;envId=top-interview-150">最长公共前缀</a></h3>
<p>模拟问题，只需要算出字符串数组中最短的那个字符串长度，然后遍历这个长度，取出第一个字符串的字符，然后一一比对其他字符，如果一样就记录下来，如果不一样，就直接退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) len = Math.min(len, str.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strs.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != strs[j].charAt(i)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) res.append(ch);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转字符串中的单词">1.21 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">反转字符串中的单词</a></h3>
<p>这是一道简单的模拟题，我们只需要遍历一次给定的字符串，当遇到不是空格的字符时，把它记录下来，当再遇到空字符串时，我们把记录下来的这个字符串用列表记录下来。最后将整个列表反转一下，用
Collections 的 reverse 反转一下列表，就能实现反转单词的效果。然后再用
String 的 join 函数进行拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;String&gt; arr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s.charAt(i)!=<span class="string">&#x27; &#x27;</span> )&#123;</span><br><span class="line">                tmp.append(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections._reverse_(arr);</span><br><span class="line">    <span class="keyword">return</span> String._join_(<span class="string">&quot; &quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="z-字形变换">1.22 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/zigzag-conversion/description/?envType=study-plan-v2&amp;envId=top-interview-150">Z
字形变换</a></h3>
<p>这道题目看上去很复杂，其实我们只需要记录原字符串每一个字符应该放在哪一行就可以完成这个任务。比如</p>
<p><img src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/1.png" />
很明显，下标的规律就是先递增到指定 numRows - 1，然后再减少到
0。我们可以定义一个字符串数组，分别记录每一行需要记录的字符，最终将这些字符串数组拼接起来。这里有一个边界问题需要注意一下，就是当
numRows=1 时，实际上就是输出原来的字符串而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) index[i] = idx++;</span><br><span class="line">        <span class="keyword">else</span> index[i] = idx--;</span><br><span class="line">        <span class="keyword">if</span> (idx == numRows) &#123;</span><br><span class="line">            idx -= <span class="number">2</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            idx += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder[] arr = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>[numRows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) arr[i] = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[index[i]].append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) res.append(arr[i]);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出字符串中第一个匹配项的下标">1.23 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h3>
<p>这道题目是 KMP 的模板题目，抄模板即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> haystack.length(), n = needle.length();</span><br><span class="line">    <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>[] p = <span class="keyword">new</span> <span class="title class_">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) s[i + <span class="number">1</span>] = haystack.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) p[i + <span class="number">1</span>] = needle.charAt(i);</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 求Next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="双指针">2. 双指针</h2>
<h3 id="验证回文串">2.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=top-interview-150">验证回文串</a></h3>
<p>字符串处理的题目，这里可以直接用正则表达式完成。我们只需要定义需要保留字符的正则表达式，然后将不需要的字符替换成空字符串，然后将字符串整体转成小写，遍历一半字符串，看看另一半对应位置是否匹配即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = s.replaceAll(<span class="string">&quot;[^A-Za-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列">2.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&amp;envId=top-interview-150">判断子序列</a></h3>
<p>这个题目直接用双指针就能完成，一层 for
循环遍历给定串，再定义目标串下标，若字符相同，则目标串下标往后移动；若到达目标串最后一位，则直接输出。需要判断的边界是，当两个字符串存在是空字符串的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.charAt(i) == s.charAt(idx)) idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数之和-ⅱ---输入有序数组">2.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和
Ⅱ - 输入有序数组</a></h3>
<p>这个是经典的双指针问题，因为它是有序数组，所以只需要定义头和尾数组，然后往中间靠就能完成这道题目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] + numbers[j] == target) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] + numbers[j] &lt; target) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="盛最多水的容器">2.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-interview-150">盛最多水的容器</a></h3>
<p>木桶效应，我们最终能盛最多水的容器取决于两根柱子中最短的那一根，并且取决于两根柱子之间的距离。使用双指针，定义前后两根柱子的位置，然后通过贪心的方法，取出最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        res = Math.max(Math.min(height[i], height[j]) * (j - i), res);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三数之和">2.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-interview-150">三数之和</a></h3>
<p>这道题目我主要用到两数之和的思想，三数之和为
0，只要把第三个数确定了，实际问题就变成了两数之和问题。因为两数之和给的是有序数组，所以，我们在这里需要先进行一个排序操作。然后枚举第一个数，再用两数之和的方法求出第二三个数出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span> - nums[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) ++i;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) --j;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) ++i;</span><br><span class="line">            <span class="keyword">else</span> --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="滑动窗口">3. 滑动窗口</h2>
<h3 id="长度最小的子数组">3.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">长度最小的子数组</a></h3>
<p>这道题目用到了前后滑动指针和前缀和的原理，设定一个前后指针和一个记录前缀和的变量。前缀和的变量记录前后指针之间的前缀和，当前缀和
&gt;=target 时，我们就记录距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE, l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            res = Math.min(r - l, res);</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无重复字符的最长子串">3.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h3>
<p>有点像双指针的题目，记录一前一后两个指针，当前面的指针遍历到一个字符重复出现两次时，后面的指针往前移动，同时减少后面指针所指字符出现的次数，知道前面指针所指的字符重复出现次数
&lt;2 后，再移动前面的指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">    Arrays.fill(cnts,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i)]++;</span><br><span class="line">        <span class="keyword">while</span> (cnts[s.charAt(i)] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            cnts[s.charAt(j)]--;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子串">3.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h3>
<p>两种解题思路，一种是利用动态规划，另外一种是利用双指针。我们一一讲解</p>
<p>——动态规划（五部曲）</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/db927238-7243-42da-b265-cf3c5e695c92.png" />
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/82efdcc2-127a-476b-ba29-579c97b65486.png" /></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">10</span>][s.length() + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; ++j) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i) &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">                res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——双指针</p>
<p>从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extend(s, i, i);</span><br><span class="line">        extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extend</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; str.length() &amp;&amp; str.charAt(l) == str.charAt(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            len = r - l + <span class="number">1</span>;</span><br><span class="line">            left = l;</span><br><span class="line">            right = r;</span><br><span class="line">        &#125;</span><br><span class="line">        --l;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回文子串">3.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a></h3>
<p>双指针直接把题目秒了，从一个字符或者两个字符开始，分别向左右两边扩散，直到不再是回文字符串为止。扩散之后如果是回文，结果数就
+1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        extendStr(s, i, i);</span><br><span class="line">        extendStr(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendStr</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;str.length() &amp;&amp; str.charAt(l) == str.charAt(r))&#123;</span><br><span class="line">        res++;</span><br><span class="line">        --l;  ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找到字符串中所有字母异位词">3.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h3>
<p>滑动窗口题目，在原字符串 s 上进行滑动，滑动窗口的大小是给定字符串 p
的长度，然后设定一个数组，记录滑动窗口中字符出现的个数，再设定一个变量值记录滑动窗口内的字母和给定字符串
p 是否有差别，如果没有差别，则将对应的下标记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length(), differ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30000</span>];</span><br><span class="line">    Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pLen &gt; sLen) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        cnts[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnts[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnts[i] != <span class="number">0</span>) differ++;</span><br><span class="line">    <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnts[ch];</span><br><span class="line">        ch = s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnts[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnts[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnts[ch];</span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) res.add(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="串联所有单词的子串">3.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&amp;envId=top-interview-150">串联所有单词的子串</a></h3>
<p>这道题目跟上面那道题目很像，但又不太一样。上面那道题目是字母，这题目是单词。官方的题解属实没看懂，放一版最后一个样例会超时的版本的，后续再优化一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), listLen = words.length, wordLen = words[<span class="number">0</span>].length(), totalLen = wordLen * listLen;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - totalLen + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; tmpMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + totalLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; totalLen; k += wordLen) &#123;</span><br><span class="line">            tmpMap.put(tmp.substring(k, k + wordLen), tmpMap.getOrDefault(tmp.substring(k, k + wordLen), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmpMap.equals(map)) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="矩阵">4. 矩阵</h2>
<h3 id="有效数独">4.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-sudoku/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效数独</a></h3>
<p>这道题目有点像八皇后，与八皇后的区别是，现在是局限于一个 9<em>9
的矩阵中。所以我们可以定义一个 3</em>3<em>9 的矩阵，把原来 9</em>9
的矩阵分割成这样子，其中每个 9 代表记录一个 3<em>3
矩阵中的数出现的次数。现在问题在于，我们现在有数在 9</em>9 矩阵中的坐标
(i,j)， 怎么定位到自己独立 3*3 矩阵中？我们会发现
(i/3,j/3)，下面这些坐标 (0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1)
(2,2) 分别对应我们下面这 9 个矩阵的位置 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202532.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span>[][] cols = <span class="keyword">new</span> <span class="title class_">int</span>[n][n], rows = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span>[][][] nine = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">            cols[i][idx]++;</span><br><span class="line">            rows[j][idx]++;</span><br><span class="line">            nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx]++;</span><br><span class="line">            <span class="keyword">if</span> (cols[i][idx] &gt; <span class="number">1</span> || rows[j][idx] &gt; <span class="number">1</span> || nine[i / <span class="number">3</span>][j / <span class="number">3</span>][idx] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="螺旋矩阵">4.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-interview-150">螺旋矩阵</a></h3>
<p>这个就是一个模拟题，我们根据题目，先往右，再往下，再往左，再往上。需要先定义方向导致的坐标变更，然后定义走到的坐标，我们先将坐标对应位置上的数加入到结果中，然后再试探性的往下走一步，看会不会越界。这里有个问题需要注意一下，我们走过的点不能再走，所以我们需要定义一个访问的
boolean
数组，表示位置是否被访问。当我们试探性的往下走一步发现走不下去的时候，我们就需要变更方向了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="number">0</span>, colIdx = <span class="number">0</span>, rowIdx = <span class="number">0</span>, newCol = <span class="number">0</span>, newRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n * m; ++i) &#123;</span><br><span class="line">        res.add(matrix[colIdx][rowIdx]);</span><br><span class="line">        vis[colIdx][rowIdx] = <span class="literal">true</span>;</span><br><span class="line">        newCol = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        newRow = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newCol &lt; <span class="number">0</span> || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newRow &gt;= m || vis[newCol][newRow]) &#123;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colIdx = colIdx + direction[dir][<span class="number">0</span>];</span><br><span class="line">        rowIdx = rowIdx + direction[dir][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转图像">4.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&amp;envId=top-interview-150">旋转图像</a></h3>
<p>这个题目是数字位置变换的题目，我们通过观察可以发现，旋转后的数字位置，其实是原来矩阵先进行上下翻转，然后，再将下三角的数跟其坐标相反的数进行交换。比如
(i,j) 换到 (j,i)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 先上下反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - <span class="number">1</span> - i][j];</span><br><span class="line">            matrix[n - <span class="number">1</span> - i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后再将下三角的数，与横纵坐标相反的位置的数交换位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵置零">4.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&amp;envId=top-interview-150">矩阵置零</a></h3>
<p>直接记录原矩阵数值为 0
的位置，用列表存储对应的(i,j)，然后遍历记录的列表，就能实现题目要求的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; coordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) coordinates.add(Arrays.asList(i, j));</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; coordinate : coordinates) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> coordinate.get(<span class="number">0</span>), col = coordinate.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) matrix[row][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命游戏">4.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/game-of-life/?envType=study-plan-v2&amp;envId=top-interview-150">生命游戏</a></h3>
<p>模拟问题，新建一个新地图，然后根据规则在老地图遍历，并对新地图赋值。最后把新地图的数值复制给老地图即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] newBoard = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; direction.length; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[k][<span class="number">0</span>], col = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= n || col &lt; <span class="number">0</span> || col &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &lt; <span class="number">2</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (cnt == <span class="number">2</span> || cnt == <span class="number">3</span> )) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; cnt &gt; <span class="number">3</span>) newBoard[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第四种情况</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; cnt == <span class="number">3</span>) newBoard[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; n;++i) <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;m;++j) board[i][j] = newBoard[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="哈希表">5. 哈希表</h2>
<h3 id="赎金信">5.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&amp;envId=top-interview-150">赎金信</a></h3>
<p>这道题目只需要用桶的思路，记录 <code>magazine</code>
每个字符出现的次数，然后再遍历 <code>ransomNote</code>
看出现字符次数是否超过 <code>magazine</code> 字符出现的次数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] magazineCharCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(Character ch : magazine.toCharArray()) magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(Character ch: ransomNote.toCharArray()) &#123;</span><br><span class="line">        magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(magazineCharCnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同构字符串">5.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/isomorphic-strings/?envType=study-plan-v2&amp;envId=top-interview-150">同构字符串</a></h3>
<p>定义两个 Hash 映射就能解决问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Character&gt; lTor = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Character&gt; rTol = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lTor.get(s.charAt(i))!=<span class="literal">null</span> &amp;&amp; lTor.get(s.charAt(i)) != t.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rTol.get(t.charAt(i))!= <span class="literal">null</span> &amp;&amp; rTol.get(t.charAt(i)) != s.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lTor.put(s.charAt(i), t.charAt(i));</span><br><span class="line">        rTol.put(t.charAt(i), s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词规律">5.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-pattern/?envType=study-plan-v2&amp;envId=top-interview-150">单词规律</a></h3>
<p>与上一道题目是一样的，只需要将字符串按照空格切分成单词，再定义两个
Hash
映射就能解决问题。不过这里需要注意一下给定单词的长度应该和切分出来的单词列表的长度一致，不然会出现以下这种情况。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202615.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, String&gt; ltoR = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Character&gt; rtoL = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    String[] strList = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(strList.length != pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltoR.get(pattern.charAt(i))!=<span class="literal">null</span> &amp;&amp; !ltoR.get(pattern.charAt(i)).equals(strList[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rtoL.get(strList[i])!=<span class="literal">null</span> &amp;&amp; !rtoL.get(strList[i]).equals(pattern.charAt(i))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ltoR.put(pattern.charAt(i), strList[i]);</span><br><span class="line">        rtoL.put(strList[i], pattern.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有效字母的异位词">5.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效字母的异位词</a></h3>
<p>这个题目更简单，跟<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&amp;envId=top-interview-150">赎金信</a>是一样的，只需要把第一个单词中每个字母出现的次数记录下来，在第二个单词遍历的时候减去对应字母的次数，最后再遍历一下记录数组，看是否全为
0，即可判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (Character ch : t.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (Character ch : s.toCharArray()) cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字母异位词分组">5.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&amp;envId=top-interview-150">字母异位词分组</a></h3>
<p>这道题目按照以往的做法，需要判断各个字符串出现的字母次数是否一致，才能归为一类。但实际上我们可以将字符串中的字母先进行排序，将不通字母排序的字符串变成统一，然后再用
Hash 记录对应的组别。<strong><em>主要是排序</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);     <span class="comment">// 很关键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(sorted, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(sorted, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数之和">5.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;envId=top-interview-150">两数之和</a></h3>
<p>可以使用双指针做，也可以用 Hash
完成。双指针的话，需要先对给定的数组进行排序，然后指针从最左边和最右边开始移动。Hash
的话会比较快，记录目标值 - 当前值，映射当前值对应的下标，等遇到 目标值 -
当前值时，返回对应 Hash 映射和对应的下标即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">        map.put(target - nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快乐数">5.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/?envType=study-plan-v2&amp;envId=top-interview-150">快乐数</a></h3>
<p>打表 YYDS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isHappy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        tmp = n;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n += (tmp % <span class="number">10</span>) * (tmp % <span class="number">10</span>);</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>) &#123;</span><br><span class="line">            isHappy = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHappy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在重复元素">5.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate/">存在重复元素</a></h3>
<p>HashSet
去重，如果不能插入，说明有重复，重复直接返回存在重复元素，返回 True</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) <span class="keyword">if</span>(!set.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在重复元素-ⅱ">5.9 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">存在重复元素
Ⅱ</a></h3>
<p>用 Hash
记录数的下标，遇到重复的就看与之前存入的下标符不符合要求，不符合就更新下标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; i - map.get(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长连续序列">5.10 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-interview-150">最长连续序列</a></h3>
<p>排序 + 哈希。如果比当前数字小 1 的数字在 map
映射中存在的话，当前数字的长度就是比他小的数字的长度 +1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            map.put(num, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res, map.get(num - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> map.put(num, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="区间">6. 区间</h2>
<h3 id="汇总区间">6.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/summary-ranges/?envType=study-plan-v2&amp;envId=top-interview-150">汇总区间</a></h3>
<p>双指针，记录一个能到达最右边的指针，往右走到不再连续。然后判断与原指针是否相等，相等就只新增原来的数；不相等就插入箭头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[high] + <span class="number">1</span> == nums[high + <span class="number">1</span>]) high++;</span><br><span class="line">        <span class="keyword">if</span> (high == i) res.add(String.valueOf(nums[i]));</span><br><span class="line">        <span class="keyword">else</span> res.add(String.valueOf(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + String.valueOf(nums[high]));</span><br><span class="line">        i = high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并区间">6.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&amp;envId=top-interview-150">合并区间</a></h3>
<p>思路跟上面的题目一样，也是遍历给定的数组，然后设定一个最右边能到达的指针下标，然后等这个指针不能再往右边走时，就把对应的区间加入到最终的结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入区间">6.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/?envType=study-plan-v2&amp;envId=top-interview-150">插入区间</a></h3>
<p>这道题目是上面那道题目的扩展，思路很简单，先把要插入的区间插入到给定的数组中，然后再执行一遍上一道题目的那个函数就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="comment">// 使用ArrayList创建一个可以修改大小的列表</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intervals));</span><br><span class="line">    tmpList.add(newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将列表转换回数组，并进行排序</span></span><br><span class="line">    intervals = tmpList.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[tmpList.size()][]);</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ) &#123;</span><br><span class="line">        high = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; intervals.length &amp;&amp; intervals[right][<span class="number">0</span>] &lt;= high) &#123;</span><br><span class="line">            high = Math.max(high, intervals[right][<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">0</span>], high&#125;);</span><br><span class="line">        i = right == i ? i + <span class="number">1</span> : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用最少数量的箭引爆气球">6.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&amp;envId=top-interview-150">用最少数量的箭引爆气球</a></h3>
<p>这道题目也是边界判断延续问题，不同点是我们要尽量让区间右端点尽可能的包含更多的区间。所以我们需要按照区间右端点进行升序排序，然后看当前区间的右端点，能包含多少区间的左端点，被包含的区间直接跳过即可。这里会存在一个数的极限问题，就是一个整数减去一个负数，会爆
Integer 边界，所以在排序的时候应该使用 Integer._compare 比较函数_</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] != b[<span class="number">1</span>] ? Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]) : Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    <span class="type">long</span> <span class="variable">high</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        high = Math.max(high, points[i][<span class="number">1</span>]);</span><br><span class="line">        right = i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; high &gt;= points[right][<span class="number">0</span>]) right++;</span><br><span class="line">        res++;</span><br><span class="line">        i = right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="栈">7. 栈</h2>
<h3 id="有效括号">7.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-interview-150">有效括号</a></h3>
<p>存入当前括号对应的反括号，为什么呢？因为如果式子有效的话，当前括号的反括号在当前位置后面一定会出现，当我们比对不匹配时，我们便可以得出当前串存在问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.lastElement() != ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化路径">7.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplify-path/?envType=study-plan-v2&amp;envId=top-interview-150">简化路径</a></h3>
<p>用栈存放路径名称，不存放“/”，然后对于 ..
的路径，表示的是返回上一层的路径，所以我们可以把栈顶元素弹出，相当于回到了上一层。最后再用“/”将栈中元素进行拼接即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    String[] strList = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(str) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;.&quot;</span>.equals(str) &amp;&amp; !<span class="string">&quot;..&quot;</span>.equals(str)) stack.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        res.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        res.insert(<span class="number">0</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.isEmpty()) res.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小栈">7.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&amp;envId=top-interview-150">最小栈</a></h3>
<p>存一个普通栈和一个最小栈，当一个新的数来的时候，普通栈直接压入，最小栈则跟栈顶元素比较一下，压入更小的那个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; xstack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        xstack.push(val);</span><br><span class="line">        minStack.push(Math.min(val,minStack.lastElement()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xstack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆波兰表达式求值">7.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&amp;envId=top-interview-150">逆波兰表达式求值</a></h3>
<p>这个已经将表达式转成后缀表达式了，我们并不需要判断运算符的优先级问题。我们只需要定义一个数字栈，遇到数字入栈，遇到符号，取出栈顶的两个元素，根据运算符号进行计算，把计算结果压入栈中，最后栈顶便为最终计算结果，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;+&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;-&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;*&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">            nums.push(Integer.parseInt(token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums.pop(), num2 = nums.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token)) nums.push(num1 + num2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(token)) nums.push(num2 - num1);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(token)) nums.push(num1 * num2);</span><br><span class="line">            <span class="keyword">else</span> nums.push(num2 / num1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本计算器">7.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator/?envType=study-plan-v2&amp;envId=top-interview-150">基本计算器</a></h3>
<p>这道题目因为只有加减运算，所以可以把它同意看成是加法运算，对于减法运算，我们可以看成是加上减去的那个数的相反数。这样我们只需要定义一个存储符号的栈，遇到(压栈，遇到)弹栈，遇到加号，符号为
1，遇到减号，符号为 0 。遇到数字，加上数字与符号的乘积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length(), res = <span class="number">0</span>, sign = <span class="number">1</span>;   <span class="comment">// sign 为 1 表示是正数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            sign = stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -stack.peek();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(sign);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                tmp = tmp * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            res += sign * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="链表">8. 链表</h2>
<h3 id="环形链表">8.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&amp;envId=2cktkvj&amp;page=1">环形链表</a></h3>
<p>这是一道经典的问题，我们只需要定义一快一慢两个指针，快指针每次走两步，慢指针每次走一步。如果链表中存在环，那么快指针一定跟慢指针相遇。如果链表中不存在环，那么快指针一定会以最快的速度到达尾指针，也就是
null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head, high = head;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="literal">null</span>) &#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="keyword">if</span>(high.next!=<span class="literal">null</span> &amp;&amp; high.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                high = high.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(high == low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数相加">8.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">两数相加</a></h3>
<p>其实跟高精度计算是同一个思路。就是模拟数字笔算相加的过程，定义进位变量，存储最终链表头文件，在加上类似于归并排序的合并两个数组的思路，合并两个链表。最后由
add 是否大于 0，在决定是否添加新的结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> l1, n2 = l2, tmp = <span class="literal">null</span>, res = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span> ,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = (n1.val + n2.val + add);</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n1.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        num = n2.val + add;</span><br><span class="line">        add = num / <span class="number">10</span>;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num % <span class="number">10</span>);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(add &gt; <span class="number">0</span>) tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(add);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个有序链表">8.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&amp;envId=top-interview-150">合并两个有序链表</a></h3>
<p>跟归并排序同一个思路，分别记录两个链表的两个指针，哪个链表的指针指向的值小，就记录哪个值，并移动对应的指针。最后，当两个链表有一方遍历完成，则只需将另一方剩余的链表加入到结果链表中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>, tmp = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(list1) &amp;&amp; Objects.nonNull(list2)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(res)) res = tmp.next;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list1)) tmp.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(list2)) tmp.next = list2;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(res)? tmp.next : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机链表的复制">8.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&amp;envId=top-interview-150">随机链表的复制</a></h3>
<p>—— 回溯 + 哈希</p>
<p>本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p>
<p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p>
<p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Node, Node&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cacheMap.containsKey(head)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        cacheMap.put(head, newHead);</span><br><span class="line">        newHead.next = copyRandomList(head.next);</span><br><span class="line">        newHead.random = copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheMap.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表">8.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h3>
<p>——模拟</p>
<p>我们只需要定义一前一后两个指针，然后保留后一个指针的 next
地址【newNode】，将后一个指针的 next
指向前一个指针，前一个指针再移动到后一个指针的位置，后一个指针移动到
newNode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表-ⅱ">8.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">反转链表
Ⅱ</a></h3>
<p>——模拟</p>
<p>这道题目思路不复杂，就是根据函数参数提供的位置，把要反转的那部分链表切出来，同时记录要反转的那部分链表的前后节点（因为把反转后的链表放回原链表需要这两个节点）</p>
<p>具体实现需要注意定义虚拟头指针，因为这道题目的数据中，头指针很有可能也是要被反转的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-个一组反转链表">8.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&amp;envId=top-interview-150">K
个一组反转链表</a></h3>
<p>这道题目第一次看上去跟上面的题目是同个思路，基本就是上面题目加个 for
循环的变体。我们在这里只需要知道链表的长度，然后每 k
个单位长度，调用上一问的函数反转一下，然后把反转后的链表重新赋值给
head。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 获得链表总长度</span></span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        head = reverseBetween(head, i+<span class="number">1</span>, i + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，因为很有可能原列表中的头节点就是翻转位置</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="comment">// 从虚拟头节点走到 left-1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">    <span class="comment">// 从 left-1 的位置走到right的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切出要反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur)) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第-n-个结点">8.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">删除链表的倒数第
N 个结点</a></h3>
<p>——模拟</p>
<p>先计算链表总共有几个结点，然后遍历到链表的倒数第 N
个结点的前一个结点，然后将结点的 next 赋值为 next.next 就可以。</p>
<p>实现的时候需要注意一下定义虚拟头结点，因为头结点有可能就是要被删除的结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    tmp = dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - n; ++i) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = tmp.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素">8.9 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h3>
<p>——模拟</p>
<p>定义前后两个指针，若后指针的下一个指针的值等于当前指针的值，则将前指针的
next 指向后指针的 next。</p>
<p>实现的时候需要定义一个虚拟头结点，因为可能要删除的结点函数传入的
head。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(head)) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head, pre = dummyNode;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(curr.next))&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素-ⅱ">8.10 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?envType=study-plan-v2&amp;envId=top-interview-150">删除排序链表中的重复元素
Ⅱ</a></h3>
<p>这道题目跟上一道题目不太一样，这道题目是不保留如果存在重复的数值，所以我们要先让当前指针
cur 先跨越所有重复值的值，然后再更新前指针 prev 的 next
的值。需要注意的是，如果存在重复的情况的话，不要移动 prev
指针的位置，因为重复后的数字很肯定再次出现重复的情况，所以我们等真的没有重复再移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(cur) &amp;&amp; Objects.nonNull(cur.next)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(cur.next) &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev = cur; </span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转链表">8.11 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/?envType=study-plan-v2&amp;envId=top-interview-150">旋转链表</a></h3>
<p>这道题目考察的是一个链表移动的问题，首先进行链表旋转的本质是给链表新的起始点。我们可以先走到链表尾，同时记录下链表的长度，因为旋转如果是链表的倍数的话，其实可以不用旋转，所以我们应该拿旋转次数
k 对链表长度 len 取余。然后走到链表尾的指针需要再往前走 k = len - k%len
步，直到下一次起点的前一个指针，我们记录下当前起点的下一个指针，将当前起点的
next 赋值为
null，表示链表结尾，然后再将刚刚记录的值返回函数，即可实现效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(head) || Objects.isNull(head.next) || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(tmp.next)) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.next = head;</span><br><span class="line">    k = len - k % len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) tmp = tmp.next;</span><br><span class="line">    head = tmp.next;</span><br><span class="line">    tmp.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分隔链表">8.12 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&amp;envId=top-interview-150">分隔链表</a></h3>
<p>有点分治思想，但也不是分治，就是一个模拟。思路是这样的，新开两条新链，采用尾插的方式往链表中添加元素。对于小于指定值的节点，我们添加到链表一；对于大于等于指定值，我们添加到链表二。我们需要注意的是记录两条链表的起始位置，等遍历结束时，我们可以进行拼接。最后在返回时还需要注意，可能全部节点都加到了链表二中，所以我们不能直接返回链表一，只有当链表一不为空时，才返回链表一，否则应该返回链表二。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), l1Head = <span class="literal">null</span>, l2Head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">            l1.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l1Head)) l1Head = l1.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = head;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(l2Head)) l2Head = l2.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1.next = l2Head;</span><br><span class="line">    l2.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Objects.isNull(l1Head)? l2Head : l1Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lru-缓存">8.13 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&amp;envId=top-interview-150">LRU
缓存</a></h3>
<p>双向链表 + Hash</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/8200f0da-2159-41f1-9fe7-5eb367030884.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉树">9. 二叉树</h2>
<h3 id="二叉树的最大深度">9.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的最大深度</a></h3>
<p>递归，土到极致就是潮。求最大深度，当前节点不存在，则为递归出口，直接返回
0。当前节点存在，则返回当前节点左右子树中比较深的那个数，同时，考虑到当前节点也为一层，所以需要在求出左右子树比较深的那个数值后面
+ 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Math._max_(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相同的树">9.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&amp;envId=top-interview-150">相同的树</a></h3>
<p>——递归</p>
<p>比较两棵树，可以看作是比较当前的两个节点的递归实现，我们只需要把比较当前两个节点的逻辑处理通顺，比较两棵树就是递归的活。我们对于当前两个节点，两个节点都为
null，则返回 true。如果只有一方为空，则返回
false；如果都不为空，则比较节点的值，如果值不同，则返回
false；值相同，则需满足他们各自的左右子树都应该相同才能返回
true，此时就用上了递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p) &amp;&amp; Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(p)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.val == q.val) <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转二叉树">9.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">翻转二叉树</a></h3>
<p>——后递归原理</p>
<p>先翻转左右子树，再反转左右节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称二叉树">9.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&amp;envId=top-interview-150">对称二叉树</a></h3>
<p>——递归</p>
<p>单个节点作为函数参数很难解决这道题目，我们直接使用<strong>重载</strong>的方式，将使用传入两个参数的形式，按照上面题目的方法，进行判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode a, TreeNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a) &amp;&amp; Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.val == b.val) <span class="keyword">return</span> isSymmetric(a.left, b.right) &amp;&amp; isSymmetric(a.right, b.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从前序与中序遍历序列构造二叉树">9.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150">从前序与中序遍历序列构造二叉树</a></h3>
<p>由前序和中序构造二叉树有个特点，就是因为前序是最开始访问根节点的，所以前序遍历数组的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历，这样讲有点抽象，我们画个图会清晰点。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202727.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= preorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[idx++]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">    root.left = buildTree(preorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从中序与后序遍历序列构造二叉树">9.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">从中序与后序遍历序列构造二叉树</a></h3>
<p>由后序和中序构造二叉树有个特点，就是因为后序从右往左第一个是最开始访问根节点的，所以后序遍历数组从右往左的每一个值都可以把中序遍历数组分割成两部分数组，这两部分数组分别为以前序遍历数组中那个值所对应的左右子树的中序遍历。需要注意的是，由后序遍历进行构造的数组，我们需要先构造右子树，再构造左子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; inorder.length; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        root.left = buildTree(postorder, inorder, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[idx--]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= right; i++) <span class="keyword">if</span> (inorder[i] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        root.right = buildTree(postorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">        root.left = buildTree(postorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="填充每个节点的下一个右侧节点指针-ⅱ">9.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/?envType=study-plan-v2&amp;envId=top-interview-150">填充每个节点的下一个右侧节点指针
Ⅱ</a></h3>
<p>——层序遍历</p>
<p>考察的是二叉树的层序遍历。要使得每一行的二叉树节点的 next
指针都指向它的右边，我们需要对每一层单独做处理。我们通过队列 +
数组来完成。具体实现是先将根节点加入到队列中，然后我们以队列是否为空进行循环，每一次循环都遍历队列中所有元素，因为队列每一次循环弹出的是当前层的节点，每一次插入的是我们下一层的节点。对于当前层的节点，我们需要用一个数组将这些点记录下来，等我们把这一层的节点
next
指针连接完成，即遍历完这一层的节点后，我们再将这一层的孩子节点加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        temp.add(cur);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            cur.next = queue.poll();</span><br><span class="line">            temp.add(cur.next);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node node : temp) <span class="keyword">if</span>(Objects.nonNull(node))&#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.left))&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(node.right))&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树展开为链表">9.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树展开为链表</a></h3>
<p>第一次看到这道题目想用前序遍历做，但是前序遍历的空间复杂度比较高，就想着能不能边翻遍历边翻转。用递归实在想不出来，看了一下别人题解使用的遍历。大概思路我画个图讲一下。思路主要是下面这样
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202752.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (Objects.nonNull(root)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(root.left))&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(pre.right)) pre = pre.right;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 考虑下一个节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="路径总和">9.9 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">路径总和</a></h3>
<p>——递归</p>
<p>如果当前节点为空，则无论 targetSum 等不等于 0，都返回
false。如果当前节点左右子树都为空，则说明当前节点为叶子节点，则直接返回当前节点值是否等于
target。若当前节点值不满足，则看看当前节点的左右子树是否满足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right) ) <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求根节点到叶节点数字之和">9.10 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">求根节点到叶节点数字之和</a></h3>
<p>——递归</p>
<p>先记录一个临时变量 tmp = 上一个节点的值 num * 10 + 当前节点的值
val，如果当前节点为叶子节点，则直接返回临时变量
tmp，即已经到叶子，不用再拼接数字了。若不是叶子节点，则当前节点的左右子树递归结果相加，可作为最终的答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getResult(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right)) <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="keyword">return</span> getResult(root.left, temp) + getResult(root.right, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的直径">9.11 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a></h3>
<p>根据题目示例，我们可以知道一条路径的长度等于该路径上的节点数 -
1，所以我们的问题转换成了求路径经过的节点数最大值 - 1。</p>
<p>而路径经过的节点数最大值怎么求呢？递归的主要思路是这样的</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前节点所在的路径经过的节点数的最大值 = 当前节点左孩子的最大深度 + 当前节点右孩子的最大深度 + 1</span><br><span class="line">当前节点的最大深度 = max(当前节点左孩子的最大深度, 当前节点右孩子的最大深度)</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    maxNum = <span class="number">1</span>;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> maxNum - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    maxNum = Math.max(maxNum, L + R + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的最大路径和">9.12 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树中的最大路径和</a></h3>
<p>这道题目跟 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
这道题目很像，但是 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
这道题目是要算节点的个数的最大值，而这道题目是算节点的值的总和最大。所以在代码实现上还是有一点区别。
<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
的当前节点的最大值是左右子树的最大深度之和 +
1。这道题目当前节点的最大值，则需要考虑左右子树的最大值是不是为负数，负数的话其实会阻碍当前节点求最大值，我们不应该考虑在内。所以这道题目相比于
<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a>
，我们需要判断当前节点的左右子树的最大值是否大于 0
，只有左右子树的最大值 &gt;0 时，我们才把它们加入到当前节点的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    res = Integer.MIN_VALUE;</span><br><span class="line">    depthPathSum(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depthPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> Math.max(depthPathSum(root.left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.max(depthPathSum(root.right), <span class="number">0</span>);</span><br><span class="line">    res = Math.max(res, root.val + L + R);</span><br><span class="line">    <span class="keyword">return</span> Math.max(L, R) + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的中序遍历">9.13 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h3>
<p>按照中序遍历的规则，先遍历左子树，再遍历当前节点，再遍历右子树。由于需要记录节点，所以需要定义一个列表变量，按照顺序记录对应的节点返回即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    res.addAll(inorderTraversal(root.left));</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    res.addAll(inorderTraversal(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树迭代">9.14 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树迭代</a></h3>
<p>——递归</p>
<p>题目讲的有点抽象，不过样例比较清晰，直接看样例可以知道其实就是一个中序遍历的结果输出。我们最简单的做法就是拿一个列表存入中序遍历的结果，然后拿一个下标，随着
next()函数的调用，去访问列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; record;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        record = inorderTraversal(root);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> record.get(idx++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; record.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> res;</span><br><span class="line">        res.addAll(Objects._requireNonNull_(inorderTraversal(root.left)));</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        res.addAll(Objects._requireNonNull_(inorderTraversal(root.right)));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——迭代 其实还有迭代的版本，迭代就是用栈去存储节点，然后随着 next
函数的调用，实现一个将当前节点与对应的左子树入栈，入栈完成后，将栈顶元素弹出，并返回栈顶元素的值，同时返回栈顶节点的值。对于是否还有下一个节点的判定，需要同时存在栈为空且
cur 指针指向
null，才会出现没有下一个节点的情况(下图最有一个图)。讲起来比较抽象，画个图解释一下
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202818.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> TreeNode cur;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Objects.nonNull(cur))&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.nonNull(cur) || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完全二叉树的节点数">9.15 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&amp;envId=top-interview-150">完全二叉树的节点数</a></h3>
<p>——递归</p>
<p>具体的做法是返回左右子树的节点个数，由于当前节点也算一个节点，所以还需要
+ 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最近公共祖先">9.16 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的最近公共祖先</a></h3>
<p>最开始看到这道题目，想用并查集来做，也就是并查集压缩路径的方法，将所有节点指向同一个父节点，但是仔细一想，最后可能都指向了根节点，不可行。再仔细一想，感觉就是二叉树的<strong>后序遍历</strong>。左子树遍历一下，看一下左子树有没有节点与
p 或者 q 一样的，再右子树遍历一下，看看右子树有没有节点与 p 或 q
一样的；</p>
<ul>
<li>如果右子树与 p 或 q 节点相等的节点都不存在，说明什么？说明 p、q
两个节点都在左子树，直接返回左子树递归结果。</li>
<li>如果左子树与 p 或 q 节点相等的节点都不存在，说明什么？说明 p、q
两个节点都在右子树，直接返回右子树递归结果。</li>
<li>递归出口是什么，递归出口就是当前节点的值为 null 或者 = p 或者 =
q，直接返回当前节点。</li>
<li>最后实在找不到，直接返回根节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root) || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(right)) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(left)) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉树层次遍历">10. 二叉树层次遍历</h2>
<h3 id="二叉树的右视图">10.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的右视图</a></h3>
<p>——层序遍历</p>
<p>层序遍历，取每一层的最右边的节点，加入到返回的数组中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">            <span class="keyword">if</span> (i == len - <span class="number">1</span>) res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层平均值">10.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的层平均值</a></h3>
<p>——层序遍历</p>
<p>对于每一层，求出每一层的节点数和节点值的总和，然后每一层记录下这一层的平均值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> queue.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            sum += cur.val;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(cur.left)) queue.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(cur.right)) queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(sum * <span class="number">1.0</span> / len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层序遍历">10.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的层序遍历</a></h3>
<p>——层序遍历模板题，写模板，每一层用一个列表存储即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的锯齿形层次遍历">10.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/?envType=study-plan-v2&amp;envId=top-interview-150">二叉树的锯齿形层次遍历</a></h3>
<p>——层次遍历</p>
<p>跟上一题几乎一样的模板，只是多加了一个判断。当在遍历的层数为奇数层（根节点算第
0 层）时，我们需要翻转存储该层数的列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.left)) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(node.right)) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.reverse(level);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二叉搜索树">11. 二叉搜索树</h2>
<h3 id="二叉搜索树的最小绝对差">11.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树的最小绝对差</a></h3>
<p>首先，我们如何获取到一棵二叉搜索树的所有节点数值，并且按照升序排序？答案是中序遍历。对于这道题目，一棵二叉树中序遍历出来的结果，min(arr[i]
- arr[i+1])
的结果就是答案。怎么写代码呢？很明显这个公式是两个值，所以我们需要额外的一个变量
pre
记录前一个节点的值。然后呢？按照中序遍历的顺序，先遍历左子树；然后处理当前节点，取当前节点与上一个节点的值的差值；最后遍历右子树。
其实每一道题目讲起来都是抽象的，我画个图解释一下吧。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214202900.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    pre = -<span class="number">1</span>;</span><br><span class="line">    res = Integer.MAX_VALUE;</span><br><span class="line">    inorderPrint(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span>;</span><br><span class="line">    inorderPrint(root.left);</span><br><span class="line">    <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = Math.min(res, root.val - pre); <span class="comment">// 这里只需要用当前数 - 前一个数； 因为中序遍历的结果就是递增的，所以相减一定是正数</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderPrint(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="验证二叉搜索树">11.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">验证二叉搜索树</a></h3>
<p>跟上一道题目一样的模板。上一道题目是记录前后两个值的差的最小值，这道题目是判断上一个值是否大于等于当前值，如果是，说明不是二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long._MIN_VALUE_;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    inorderPrint(root);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(root)) <span class="keyword">return</span>;</span><br><span class="line">    inorderPrint(root.left);</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre == Long._MIN_VALUE_) &#123;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= root.val) flag = <span class="literal">false</span>;</span><br><span class="line">        pre = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderPrint(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树中第-k-小的元素">11.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&amp;envId=top-interview-150">二叉搜索树中第
k 小的元素</a></h3>
<p>——中序遍历</p>
<p>其实就是取二叉搜索树中序遍历的结果列表中的第 k 个小标的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        inorderPrint(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderPrint</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) <span class="keyword">return</span>;</span><br><span class="line">        inorderPrint(root.left);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) res = root.val;</span><br><span class="line">        inorderPrint(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="图">12. 图</h2>
<h3 id="岛屿的最大面积">12.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) res = Math.max(res, getAreaOfIsland(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getAreaOfIsland(grid, r + <span class="number">1</span>, c) + getAreaOfIsland(grid, r - <span class="number">1</span>, c) + getAreaOfIsland(grid, r, c - <span class="number">1</span>) + getAreaOfIsland(grid, r, c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿数量">12.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&amp;envId=top-interview-150">岛屿数量</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                traverseArea(grid, i, j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGrid(grid, r, c)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    traverseArea(grid,r,c+<span class="number">1</span>);</span><br><span class="line">    traverseArea(grid,r,c-<span class="number">1</span>);</span><br><span class="line">    traverseArea(grid,r-<span class="number">1</span>,c);</span><br><span class="line">    traverseArea(grid,r+<span class="number">1</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿的周长">12.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/island-perimeter/description/">岛屿的周长</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> traverseArea(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverseArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGrid(grid, r, c)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseArea(grid, r, c + <span class="number">1</span>) + traverseArea(grid, r, c - <span class="number">1</span>) + traverseArea(grid, r + <span class="number">1</span>, c) + traverseArea(grid, r - <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="所有可能的路径">12.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-paths-from-source-to-target/">所有可能的路径</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line">    Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">    stack.offerLast(<span class="number">0</span>);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dfs(graph, <span class="number">0</span>, graph.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> idx, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> target : graph[idx]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[target]) <span class="keyword">continue</span>;</span><br><span class="line">        stack.offerLast(target);</span><br><span class="line">        vis[target] = <span class="literal">true</span>;</span><br><span class="line">        dfs(graph, target, n);</span><br><span class="line">        stack.removeLast();</span><br><span class="line">        vis[target] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被围绕的区域">12.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&amp;envId=top-interview-150">被围绕的区域</a></h3>
<p>从边缘开始搜起，把边缘的‘O’先打上标记，然后再遍历一下数组，没有打上标记的‘O’则是我们需要进行替换的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(board) || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">edge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == n - <span class="number">1</span> || j == m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (edge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克隆图">12.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/clone-graph/description/?envType=study-plan-v2&amp;envId=top-interview-150">克隆图</a></h3>
<p>——DFS</p>
<p>还是用 DFS 进行爆搜。递归两个要点，一个是出口，一个是递归语句。</p>
<p>（1）出口：</p>
<ul>
<li>第一个出口：根据题目所给用例，我们可以很快找到一个递归出口，那就是当传入的结点为
null 时，返回 null。</li>
<li>第二个出口：我们会发现题目所给用例中是一个无向图，会有环的存在，如果这个不加以限制就会无线递归下去，无限创建节点。那怎么办呢？可以用一个
map 去接我们创建出来的节点，把节点值作为 key，节点本身作为
value。每一次创建节点前，都先看看之前是否已经创建过该节点，创建过了就不需要再创建了。</li>
</ul>
<p>（2）递归语句。我们需要明确的是，对于当前节点的邻居，我们应该在进入递归时加入还是递归返回时加入。答案很明显，需要在递归返回时加入。为什么因为对于当前节点的邻居，它们也有自己的邻居，先将当前节点的邻居用递归的方式创建，把它们的邻居也克隆好后，再将它们加入到当前节点的邻居位置。这个问题涉及递归前执行和递归后执行的问题，读者可以参考一下二叉树的前中后序遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(node)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(node.val)) <span class="keyword">return</span> map.get(node.val);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">    map.put(node.val, newNode);</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">        newNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除法求值">12.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/description/?envType=study-plan-v2&amp;envId=top-interview-150">除法求值</a></h3>
<p>两种做法：1. DFS； 2. 并查集</p>
<p>——DFS</p>
<p>这是我看到这道题目第一时间想到的做法。对于这道题目，第一时间想到的是建图，然后遍历给定的
queries，用 DFS 爆搜图。这种做法我们需要明确几个点：1.
图结构用什么存储？ 2. 怎么将数据存入图中 3. 递归出口是什么？4.
递归执行逻辑是什么？</p>
<p>接下来我们一一回答这个问题。</p>
<ol type="1">
<li>首先是图结构用什么存储，回答是 Map 或者结构体。我的代码用的是
Map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>怎么把数据存入图。</li>
</ol>
<p>我们先对题目所给的变量对以下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被除数 --&gt;   num1</span><br><span class="line">除数   --&gt;   num2</span><br></pre></td></tr></table></figure>
<p>回答是 被除数 num1 作为 key，除数 num2 和对应两个数的商构建 map 作为
value。然后需要再存入两个数位置相反的关系，也就是第二个数 num2
作为被除数，第一个数 num1 作为除数，对应值则为 1.0 /
value。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----&gt; Map&lt;num1, Map&lt;num2, value&gt;</span><br><span class="line">num1</span><br><span class="line">|</span><br><span class="line">---&gt; (num2,value)</span><br><span class="line"></span><br><span class="line">-----&gt; Map&lt;num2, Map&lt;num1, value&gt;</span><br><span class="line">num2</span><br><span class="line">|</span><br><span class="line">---&gt; (num1,<span class="number">1.0</span> / value)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>递归出口是什么？</li>
</ol>
<p>（1）当图中不存在查询数对的两个值时，需要返回 -1.0</p>
<p>（2）当图中存在查询数对，并且数对的两个值相等时，需要返回 1.0；因为
a/a = 1.0</p>
<p>（3）当图中存在查询数对，并且符合图结构，也就是 num1 下的 map 中含有
num2，则直接返回对应的数值</p>
<ol type="1">
<li>递归逻辑</li>
</ol>
<p>先找当前 num1 下的 map 的 key，如果能找到对应 num2，则直接返回对应的
value；若找不到，则递归 num1 下的 map 的 key，然后将当前 num1 下的 map
的 value 与 key 的递归结果相乘返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    <span class="type">double</span>[] res = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line">    <span class="comment">// 建图</span></span><br><span class="line">    createGraph(equations, values);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">        List&lt;String&gt; query = queries.get(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> query.get(<span class="number">0</span>), num2 = query.get(<span class="number">1</span>);</span><br><span class="line">        res[i] = dfs(num1, num2, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>), num2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">        graph.computeIfAbsent(num1, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()).put(num2, values[i]);</span><br><span class="line">        graph.computeIfAbsent(num2, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()).put(num1, <span class="number">1.0</span> / values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">dfs</span><span class="params">(String num1, String num2, Set&lt;String&gt; path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(num1) || !graph.containsKey(num2)) <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(num1, num2)) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    Map&lt;String, Double&gt; doubleMap = graph.get(num1);</span><br><span class="line">    <span class="keyword">if</span> (doubleMap.containsKey(num2)) <span class="keyword">return</span> doubleMap.get(num2);</span><br><span class="line">    path.add(num1);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; child : doubleMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.contains(child.getKey())) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> child.getValue();</span><br><span class="line">        <span class="type">double</span> <span class="variable">childValue</span> <span class="operator">=</span> dfs(child.getKey(), num2, path);</span><br><span class="line">        <span class="keyword">if</span>(childValue != -<span class="number">1.0</span>) <span class="keyword">return</span> tmp * childValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/?envType=study-plan-v2&amp;envId=top-interview-150">——并查集</a></p>
<p>这里贴一下官方题解吧，写的挺好的。官方题解采用路径压缩，会比 DFS
快一些。</p>
<h3 id="课程表">12.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-interview-150">课程表</a></h3>
<p>就是判断图中有没有环。</p>
<ol type="1">
<li>像什么？像拓扑排序。</li>
<li>怎么做？记录节点入度，用队列存储入度为 0 的节点。</li>
<li>出口在哪？如果图中没有环，则图中每个节点都会进入队列一次；如果图中有环，则环上的节点是不会进入队列的。</li>
<li>只有数组记录节点之间的关系怎么办？建图。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(prerequisites) || prerequisites.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] inSpend = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Arrays.fill(inSpend, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        inSpend[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        graph.computeIfAbsent(prerequisite[<span class="number">1</span>], k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) <span class="keyword">if</span> (inSpend[i] == <span class="number">0</span>) queue.addLast(i);</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(graph.get(it))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer target : graph.get(it)) &#123;</span><br><span class="line">            inSpend[target]--;</span><br><span class="line">            <span class="keyword">if</span> (inSpend[target] == <span class="number">0</span>) queue.addLast(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课程表-ⅱ">12.9 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">课程表
Ⅱ</a></h3>
<p>上一道题目的变体，存入拓扑图序列就可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] inSpend = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Arrays.fill(inSpend, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        inSpend[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        graph.computeIfAbsent(prerequisite[<span class="number">1</span>], k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) <span class="keyword">if</span> (inSpend[i] == <span class="number">0</span>) queue.addLast(i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">        numCourses--;   res[idx++] = it;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(graph.get(it))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer target : graph.get(it)) &#123;</span><br><span class="line">            inSpend[target]--;</span><br><span class="line">            <span class="keyword">if</span> (inSpend[target] == <span class="number">0</span>) queue.addLast(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>? res: <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="图的广度优先搜索">13. 图的广度优先搜索</h2>
<h3 id="蛇梯棋">13.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/snakes-and-ladders/description/?envType=study-plan-v2&amp;envId=top-interview-150">蛇梯棋</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] p = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nxt</span> <span class="operator">=</span> p[<span class="number">0</span>] + i;</span><br><span class="line">            <span class="keyword">if</span> (nxt &gt; n * n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span>[] rc = id2rc(nxt, n);</span><br><span class="line">            <span class="keyword">if</span> (board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nxt = board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt == n * n) &#123;</span><br><span class="line">                <span class="keyword">return</span> p[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[nxt]) &#123;</span><br><span class="line">                vis[nxt] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nxt, p[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> id, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (id - <span class="number">1</span>) / n, c = (id - <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        c = n - <span class="number">1</span> - c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n-<span class="number">1</span>-r, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小基因变化">13.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">最小基因变化</a></h3>
<p>有点像二叉树的层序遍历。哦不，BFS
就是多叉树的层序遍历版本。那么我们换种思想，把这道题目想象成多叉树，然后像二叉树的层序遍历那样，遍历这颗多叉树可以吗。答案是可以。继续往下看，我们需要解决以下几个问题。
1. 这颗多叉树是几叉？ 2. 题目要求的结果是遍历的什么结果？ 3.
层序遍历的队列应该存什么？</p>
<ol type="1">
<li>这颗多叉树是几叉？ 回答是 8*3 = 24。为什么？因为每一个基因序列都有 8
个字母，在一次变换中，每一个字母都有 3
种其他变化，所以，对于每一次变化，我们都需要考虑 24 种可能。</li>
<li>要求的结果是遍历的什么结果？
回答是树的深度，树的每一层代表每一次递进的变换，所以，当真的遇到最终序列时，树有几层，就应该对应几次变换。</li>
<li>层序遍历的队列应该存什么？
回答是，存基因库中的基因序列。显然，对于我们上述的 24
种变化，真正有效的变化只会出现在基因库中，所以，队列里面存的一定是基因库中的序列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">    <span class="type">char</span>[] keys = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (startGene.equals(endGene)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt.contains(endGene)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offer(startGene);</span><br><span class="line">    vis.add(startGene);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.charAt(i) != keys[j]) &#123;</span><br><span class="line">                        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(cur);</span><br><span class="line">                        sb.setCharAt(i, keys[j]);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                        <span class="keyword">if</span> (cnt.contains(target) &amp;&amp; !vis.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endGene.equals(target)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> step;</span><br><span class="line">                            &#125;</span><br><span class="line">                            queue.offer(target);</span><br><span class="line">                            vis.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词接龙">13.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词接龙</a></h3>
<p>跟上一道题目思路一模一样。把写死的长度换成可变长度就行。另外，题目的接龙中，第一个单词和最后一个单词也算进序列长度里面，所以我们需要给答案再加一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] keys = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>.toCharArray();</span><br><span class="line">    Set&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">    Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(!cnt.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    vis.add(beginWord);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; beginWord.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; keys.length; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.charAt(i) != keys[j]) &#123;</span><br><span class="line">                        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(cur);</span><br><span class="line">                        sb.setCharAt(i, keys[j]);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">nxt</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                        <span class="keyword">if</span> (cnt.contains(nxt) &amp;&amp; !vis.contains(nxt)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endWord.equals(nxt)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            queue.offer(nxt);</span><br><span class="line">                            vis.add(nxt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="字典树">14. 字典树</h2>
<h3 id="实现-trie前缀树">14.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">实现
Trie（前缀树）</a></h3>
<p>前缀树，也称字典树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                cur = cur.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加与搜索单词---数据结构设计">14.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&amp;envId=top-interview-150">添加与搜索单词
- 数据结构设计</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        maxLen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        maxLen = Math.max(maxLen, word.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.subNodes.containsKey(c)) &#123;</span><br><span class="line">                node = node.subNodes.get(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                node = node.subNodes.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(word,<span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word, <span class="type">int</span> index, Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(node.subNodes.containsKey(c)) &#123;</span><br><span class="line">            node = node.subNodes.get(c);</span><br><span class="line">            <span class="keyword">if</span>(search(word, index+<span class="number">1</span>, node)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Node&gt; characterNodeEntry : node.subNodes.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(search(word, index+<span class="number">1</span>, characterNodeEntry.getValue())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索-ⅱ">14.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索
Ⅱ</a></h3>
<p>一顿操作猛如虎，交上超时二百五。破防了</p>
<p>——
最有一个样例没过版本。这个版本是先造出单词，然后再通过前缀树查找是否在前缀树中。很慢。下面的版本的是参考了官方题解的。直接把前缀树的查找过程顺着原来地图的
dfs 进行，很快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Character, Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        Node root;</span><br><span class="line"></span><br><span class="line">        Trie() &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    cur = cur.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">                path.append(board[i][j]);</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(i, j, board, trie, visited);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j,<span class="type">char</span>[][] board, Trie trie, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length() &gt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (trie.search(path.toString())) &#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + direction[<span class="number">0</span>], col = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isGrap(row, col, board) &amp;&amp; !visited[row][col]) &#123;</span><br><span class="line">                path.append(board[row][col]);</span><br><span class="line">                visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">                dfs(row, col, board, trie, visited);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">                visited[row][col] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——题解版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, Trie&gt; subNodes;</span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line">        Trie() &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.subNodes.containsKey(c)) &#123;</span><br><span class="line">                    node = node.subNodes.get(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.subNodes.put(c, <span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">                    node = node.subNodes.get(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node.isEnd = <span class="literal">true</span>;</span><br><span class="line">            node.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(i, j, board, trie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, Trie trie)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!trie.subNodes.containsKey(board[i][j])) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        trie = trie.subNodes.get(c);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(trie.word)) &#123;</span><br><span class="line">            res.add(trie.word);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + direction[<span class="number">0</span>], y = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isGrap(x, y, board) &amp;&amp; board[x][y] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                dfs(x, y, board, trie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="回溯">15. 回溯</h2>
<h3 id="电话号码的字母组合">15.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">电话号码的字母组合</a></h3>
<p>——DFS</p>
<p>先打表，记录数字和字母组合的映射，然后再遍历数字序列 DFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    put(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">    put(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">    put(<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    put(<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">    put(<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">    put(<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">    put(<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(digits) || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dfs(<span class="number">0</span>, digits);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == digits.length()) &#123;</span><br><span class="line">        res.add(path.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">combines</span> <span class="operator">=</span> map.get(digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : combines.toCharArray()) &#123;</span><br><span class="line">        path.append(c);</span><br><span class="line">        dfs(i + <span class="number">1</span>, digits);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合">15.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&amp;envId=top-interview-150">组合</a></h3>
<p>——DFS</p>
<p>DFS 模板题，但是这道题目需要注意的是，对于这个
List&lt;List<Integer>&gt; 变量类型，要将 List<Integer>
加进这个变量时，要 new 一下！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        dfs(i + <span class="number">1</span>, n, k);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全排列">15.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-interview-150">全排列</a></h3>
<p>组合跟全排列是不一样的。按最浅显的理解，可以认为全排列能回头，但是得标记是否已访问；组合不能回头，只能往前走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    n = nums.length;</span><br><span class="line">    vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    dfs(<span class="number">0</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(start + <span class="number">1</span>, nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合总和">15.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">组合总和</a></h3>
<p>能重复，但是不能回头，那就把当前位置继续传入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>, candidates, target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> num, <span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        dfs(i, num + candidates[i], candidates, target);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n-皇后-ⅱ">15.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">N
皇后 Ⅱ</a></h3>
<p>——DFS</p>
<p>怎么理解呢？N 皇后是一个在边长为 n 的方阵上的问题，我们用 DFS
的时候一般都是把题目看成是树的解决方案来进行。【以后有时间一定开个 DFS
专题讲讲】。落实到这道题目，我们需要明确几个点，1. 树的深度是什么？ 2.
树的每个节点有几个孩子节点 3. 出口是什么？</p>
<ol type="1">
<li>树的深度？</li>
</ol>
<p>n。这道题目树的深度是矩阵的行，有几行就多深</p>
<ol type="1">
<li>树的每个节点有几个孩子节点？</li>
</ol>
<p>n。 有多少列，就有几个孩子节点。</p>
<ol type="1">
<li>出口是什么？</li>
</ol>
<p>到叶子节点</p>
<p>最后我们需要怎么满足彼此不攻击？
其实对于每一个位置的横竖撇捺方向，都可以转换成一个数组进行标记是否可行。怎么说呢？</p>
<ul>
<li>横——不用数组，因为我们 DFS
就是一行一行去试探，所以一定能保证行不会冲突。</li>
<li>竖——col 数组</li>
<li>撇——ueg 数组 当前位置[i,j]的撇怎么标记 ueg[i+j]</li>
<li>捺——eg 数组 当前位置[i,j]的撇怎么标记 eg[j-i+n]</li>
</ul>
<p>上图 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203004.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] col, eg, ueg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    eg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    ueg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    dfs(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="number">0</span> &amp;&amp; eg[i + u] == <span class="number">0</span> &amp;&amp; ueg[i - u + n] == <span class="number">0</span>) &#123;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>, n);</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八皇后">15.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/eight-queens-lcci/description/">八皇后</a></h3>
<p>与上面的题目一模一样，不过这道题需要先初始化一下地图，然后边 DFS
边改地图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] col, eg, ueg;</span><br><span class="line"><span class="type">char</span>[][] board;</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    eg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    ueg = <span class="keyword">new</span> <span class="title class_">int</span>[n + n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, n, board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        List&lt;String&gt; rowStr = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rowStr.add(String.valueOf(board[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(rowStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="number">0</span> &amp;&amp; eg[u + i] == <span class="number">0</span> &amp;&amp; ueg[i - u + n] == <span class="number">0</span> &amp;&amp; board[u][i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">            board[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>, n, board);</span><br><span class="line">            board[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            col[i] = eg[i + u] = ueg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词搜索">15.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索</a></h3>
<p>——DFS</p>
<p>只有跟单词一样开头的字母才开始爆搜，只要长度超过目标单词就退出，不然就字母四周继续搜。需要标记是否已经遍历过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                path.append(board[i][j]);</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">                board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, board, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = tmp;</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (word.contentEquals(path)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (path.length() &gt; word.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + direction[<span class="number">0</span>], newY = y + direction[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isGrap(newX, newY, board) &amp;&amp; board[newX][newY] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            path.append(board[newX][newY]);</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[newX][newY];</span><br><span class="line">            board[newX][newY] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(newX, newY, board, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            board[newX][newY] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号生成">15.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&amp;envId=top-interview-150">括号生成</a></h3>
<p>对于每一次添加，左括号剩余的个数一定要大于或等于右括号的个数，这样可以保证不会出现类似
<code>())</code>
这种情况存在。我们初始化左右括号个数为最大，每次加，都减掉对应的个数，当左右括号剩余个数都为
0 时，加入最终的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String str, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) res.add(str);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">0</span>) dfs(str + <span class="string">&quot;(&quot;</span>, l - <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>) dfs(str + <span class="string">&quot;)&quot;</span>, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="分治">16. 分治</h2>
<h3 id="将有序数组转换为二叉搜索树">16.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">将有序数组转换为二叉搜索树</a></h3>
<p>有序数组取出中间值，左边数组构建左子树，右边数组构建右子树。前序遍历版建树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> creatTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">creatTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">    root.left = creatTree(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = creatTree(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序链表">16.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">排序链表</a></h3>
<p>——迭代版归并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead, curr = dummyHead.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> curr.next;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> merge(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead, temp1 = head1, temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">null</span> &amp;&amp; temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">                temp.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建立四叉树">16.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-quad-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">建立四叉树</a></h3>
<p>先建树根，然后用递归填树的四个孩子，每次递归，都把矩阵用下标分割成对应的子矩阵。那递归出口是什么呢？是当左上角和右下角重合时，也就是当前矩阵只有一个数时，或者当矩阵中的树一样时，我们需要建立树的叶子节点返回。分割矩阵的下标填写可以参考下面的图
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203044.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> createTree(grid,<span class="number">0</span>,<span class="number">0</span>,n-<span class="number">1</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2 || isSameNumber(grid,x1,y1,x2,y2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(grid[x1][y1] == <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midX</span> <span class="operator">=</span> x1 + x2 &gt;&gt; <span class="number">1</span>, midY = y1 + y2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        root.topLeft = createTree(grid, x1, y1, midX, midY);</span><br><span class="line">        root.topRight = createTree(grid, x1, midY + <span class="number">1</span>, midX, y2);</span><br><span class="line">        root.bottomLeft = createTree(grid, midX + <span class="number">1</span>, y1, x2, midY);</span><br><span class="line">        root.bottomRight = createTree(grid, midX + <span class="number">1</span>, midY + <span class="number">1</span>, x2, y2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameNumber</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> grid[x1][y1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x1; i &lt;= x2; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> y1; j &lt;= y2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 16.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-interview-150">合并
K 个升序链表</a></p>
<p>——暴力版本</p>
<p>实践证明，暴力真的能过这道题目。只需要每一次都遍历一遍链表数组，把最小的那一个值取出来，插入到结果链表中即可。这也是我自己第一时间想到和写出来的结果。
还是看看下面用类似于归并排序的分治版本吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(lists) || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, maxNum = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(lists[i]) &amp;&amp; lists[i].val &lt; maxNum) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                maxNum = lists[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxNum == Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line">        cur.next = lists[idx];</span><br><span class="line">        lists[idx] = lists[idx].next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—— 分治版本</p>
<p>对于分治，给 up 的题感都跟 树的遍历或者归并排序的思路基本一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects._isNull_(l1) || Objects._isNull_(l2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects._isNull_(l1) ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy, l1Head = l1, l2Head = l2;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l1Head) &amp;&amp; Objects._nonNull_(l2Head)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1Head.val &lt; l2Head.val) &#123;</span><br><span class="line">            cur.next = l1Head;</span><br><span class="line">            l1Head = l1Head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2Head;</span><br><span class="line">            l2Head = l2Head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l1Head)) &#123;</span><br><span class="line">        cur.next = l1Head;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        l1Head = l1Head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Objects._nonNull_(l2Head)) &#123;</span><br><span class="line">        cur.next = l2Head;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        l2Head = l2Head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="kadane算法">17. Kadane算法</h2>
<h3 id="最大子数组和">17.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&amp;envId=top-interview-150">最大子数组和</a></h3>
<p>定义一个变量 maxNum
记录当前位置之前的子数组和，然后比较要不要从当前位置开始新的子数组，还是继续把当前位置纳入到子数组中，比较的方式就是，
Math.max(nums[i], nums[i] + maxNum) 。 也就是当前位置之前的子数组和 +
当前位置的数值，会不会比当前位置的数大。会的话就将当前位置纳入子数组，不会的话，就从当前位置开始。每次更新都要记录子数组和的最大值，所以最终求出来的结果就是最大子数组和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        maxNum = Math.max(nums[i], maxNum + nums[i]);</span><br><span class="line">        res = Math.max(res, maxNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环形子数组的最大和">17.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&amp;envId=top-interview-150">环形子数组的最大和</a></h3>
<p>题解参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minS</span> <span class="operator">=</span> Integer.MAX_VALUE, maxS = Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minF</span> <span class="operator">=</span> <span class="number">0</span>, maxF = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        minF = Math.min(minF,<span class="number">0</span>) + num;</span><br><span class="line">        maxF = Math.max(maxF,<span class="number">0</span>) + num;</span><br><span class="line">        minS = Math.min(minS, minF);</span><br><span class="line">        maxS = Math.max(maxS, maxF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minS == sum? maxS : Math.max(maxS, sum - minS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二分查找">18. 二分查找</h2>
<h3 id="搜索插入位置">18.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&amp;envId=top-interview-150">搜索插入位置</a></h3>
<p>二分查找经典题目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l] &gt;= target ? l : l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索二维矩阵">18.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-interview-150">搜索二维矩阵</a></h3>
<p>首先把二维矩阵拉成一维矩阵来看待，然后把对应一维的矩阵下标转换成二维矩阵对应的下标即可。画个图讲一下怎么转换.
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241214203141.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[mid / m][mid % m];</span><br><span class="line">        <span class="keyword">if</span> (tmp == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="寻找峰值">18.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/description/?envType=study-plan-v2&amp;envId=top-interview-150">寻找峰值</a></h3>
<p>由于题目说了，可以假设
<code>nums[-1] = nums[n] = -∞</code>，那么在数组中，只要有一个数比它相邻的元素大，那就顺着大的元素的方向继续往下找，就一定能找到峰值。因为极端情况边缘数字就是峰值。</p>
<ul>
<li>根据上述结论，我们就可以使用二分查找找到峰值。</li>
<li>查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件</li>
<li>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m
较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m +
1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索旋转排序数组">18.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">搜索旋转排序数组</a></h3>
<p>虽然数组旋转了，但还是会有有序的部分。数组中点一定会把数组分割成两部分，一部分一定是有序的，我们只需要在有序的部分继续使用二分查找，那就一定能找到目标值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在排序数组中查找元素的第一个和最后一个位置">18.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">在排序数组中查找元素的第一个和最后一个位置</a></h3>
<p>其实这道题目就是 acwing 的二分查找的模板题目，但是 up
当时看完视频还是不懂，知道看了这篇<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/?envType=study-plan-v2&amp;envId=top-interview-150">题解</a>，确实不需要去判断哪个地方得等于，哪个地方又得
+
1。我们只需要当找到目标值的时候，如果要找第一个出现的位置，我们就继续往左边找；如果要找最后一个出现的位置，我们就继续往右找就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    res[<span class="number">0</span>] = binarySearch(nums,target,<span class="literal">true</span>);</span><br><span class="line">    res[<span class="number">1</span>] = binarySearch(nums,target,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> isFirst)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>, tmp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            tmp = mid;</span><br><span class="line">            <span class="keyword">if</span>(!isFirst) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找旋转排序数组中的最小值">18.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&amp;envId=top-interview-150">寻找旋转排序数组中的最小值</a></h3>
<p>这道题目官方讲解讲的很好，可以看懂，这里就直接贴<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/698479/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/?envType=study-plan-v2&amp;envId=top-interview-150">官方讲解</a>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找两个正序数组的中位数">18.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-interview-150">寻找两个正序数组的中位数</a></h3>
<p>——暴力解法
其实就是将两个数组合并成一个数组，然后，求出新数组的中位数。但是没想到超过
100%</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length, i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) arr[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> arr[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) arr[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) arr[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (arr[n / <span class="number">2</span>] + arr[n / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[n / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——二分解法</p>
<p>寻求第 k 小数的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>, right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> start1, <span class="type">int</span> end1, <span class="type">int</span>[] nums2, <span class="type">int</span> start2, <span class="type">int</span> end2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="堆">19. 堆</h2>
<h3 id="数组中的第-k-个最大元素">19.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">数组中的第
K 个最大元素</a></h3>
<p><strong>——排序</strong></p>
<p>不符合题意要求，这里不贴代码了</p>
<p><strong>——快速排序</strong></p>
<p>回忆一下下面快速排序的代码，其实快速排序实现的是什么，是将一个数组分成两个部分，前半部分小于某个数
base，后半部分大于某个数 base。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = nums[i + j &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span> (nums[i] &lt; base);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span> (nums[j] &gt; base);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从这里入手</span></span><br><span class="line">    _quickSort_(nums, l, j);</span><br><span class="line">    _quickSort_(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在要找到第 K
大的数，怎么利用快速排序来找呢？我们可以从上面代码标记的位置入手。当代码运行到此处是，此时的数组前半部分全是小于
base 的数，后半部分全是大于 base 的数，我们要找第 k
大，只需要看看前半部分有没有 k
个数，有的话，在前半部分找；没有则到后半部分找。看看实现代码~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, base = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span> (nums[i] &lt; base);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span> (nums[j] &gt; base);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j) <span class="keyword">return</span> quickSort(nums, l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSort(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>——堆排序</strong></p>
<p>所谓的堆排序，就是用到一些在树状数组上进行的操作，建立大根堆，然后不断删除顶部节点。还是得画个图才比较明了
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214625.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        down(nums, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        down(nums, --len, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> len,  <span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">1</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[u * <span class="number">2</span> + <span class="number">2</span>] &gt; nums[t]) t = u * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != u) &#123;</span><br><span class="line">        swap(nums, t, u);</span><br><span class="line">        down(nums, len ,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ipo">19.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/ipo/description/?envType=study-plan-v2&amp;envId=top-interview-150">IPO</a></h3>
<p>——贪心算法
最开始看到这个题目感觉像背包，但是由于成本是随着收益的不断增加改变。所以应该用贪心的思路。具体是先将所有投资按照投资成本进行升序排序，然后根据现有资金决定是否投资对应的项目，将项目的收益按照降序排序存入堆中，每一次取出在当前投资资金所能支持的项目中收益最大的那一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> profits.length;</span><br><span class="line">    <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i][<span class="number">0</span>] = capital[i];</span><br><span class="line">        arr[i][<span class="number">1</span>] = profits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays._sort_(arr, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n &amp;&amp; w &gt;= arr[cur][<span class="number">0</span>]) &#123;</span><br><span class="line">            heap.add(arr[cur][<span class="number">1</span>]);</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            w += heap.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找和最小的-k-对数字">19.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&amp;envId=top-interview-150">查找和最小的
K 对数字</a></h3>
<p>使用最小堆存储两个数组的下标，使得对应下标值的和按照升序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; nums1[a[<span class="number">0</span>]] + nums2[a[<span class="number">1</span>]] - nums1[b[<span class="number">0</span>]] - nums2[b[<span class="number">1</span>]]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, k); ++i) &#123;</span><br><span class="line">        heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] idPairs = heap.poll();</span><br><span class="line">        res.add(Arrays.asList(nums1[idPairs[<span class="number">0</span>]], nums2[idPairs[<span class="number">1</span>]]));</span><br><span class="line">        <span class="keyword">if</span>(idPairs[<span class="number">1</span>] + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;idPairs[<span class="number">0</span>], idPairs[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流的中位数">19.4 数据流的中位数</h3>
<h2 id="位运算">20. 位运算</h2>
<h3 id="二进制求和">20.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-binary/description/?envType=study-plan-v2&amp;envId=top-interview-150">二进制求和</a></h3>
<p>其实就是高精度的模拟题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">aLen</span> <span class="operator">=</span> a.length(), bLen = b.length(), carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> aLen - <span class="number">1</span>, j = bLen - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">        carry += i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        carry += j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        res.append(carry % <span class="number">2</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(carry &gt; <span class="number">0</span> ? carry : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="颠倒二进制数">20.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">颠倒二进制数</a></h3>
<p>将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n
的每一位，将其倒序添加到翻转结果 res 中。</p>
<p>代码实现中，每枚举一位就将 n 右移一位，这样当前 n
的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。</p>
<p>需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n
的右移操作应使用逻辑右移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        res |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位-1-的个数">20.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">位
1 的个数</a></h3>
<p>每次将数右移一位，然后跟 1 做 &amp; 运算，如果存在 1，则计入次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) cnt++;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字">20.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/submissions/587464649/?envType=study-plan-v2&amp;envId=top-interview-150">只出现一次的数字</a></h3>
<p>——异或运算。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214718.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字-ⅱ">20.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">只出现一次的数字
Ⅱ</a></h3>
<p>模拟一下代码逻辑 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214740.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        a = (a ^ num) &amp; ~b;</span><br><span class="line">        b = (b ^ num) &amp; ~a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数字范围按位与">20.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&amp;envId=top-interview-150">数字范围按位与</a></h3>
<p>画个图就明白了，其实很简单。想一下，为什么会除了公共前缀之外，其他部分相与都为
0。无论多少个数相与，只要其中有一个数为 0，是不是所有数字相与都会为
0。那对于给定范围的左右两个数，除了公共前缀部分，后半部分是不是用来区分它们之间的不同，并且它们之前存在的是连续的不同，说明什么，说明不是公共前缀的部分，一定每一个位置上面都存在一个
0，所以相与一定为 0 . <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241217214801.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &lt;&lt; offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数学">21. 数学</h2>
<h3 id="回文数">21.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">回文数</a></h3>
<p>简单题，简单做。每次取出给定数字的最后一位，作为新的数新增的一位，最后判断新构造的数和原来的数一不一样就可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>, tmp = x;</span><br><span class="line">    <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        num = num * <span class="number">10</span> + tmp % <span class="number">10</span>;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加一">21.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&amp;envId=top-interview-150">加一</a></h3>
<p>——高精度加法模拟题</p>
<p>不想回忆，保研面试那会做了半个多小时，基础是太差了。现在 3
分钟就做出来了。不想回忆保研的日子~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">1</span>, n = digits.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        carry += digits[i];</span><br><span class="line">        res.add(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) res.add(carry);</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) ans[res.size() - i - <span class="number">1</span>] = res.get(i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘后的零">21.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&amp;envId=top-interview-150">阶乘后的零</a></h3>
<p>因为 2x5 = 10，所以，要有 0，因子中就必须要有 2 和 5。并且因子中的 2
一定会比 5 多。期间需要很多数学证明，这里有兴趣的话看<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/solutions/1360892/jie-cheng-hou-de-ling-by-leetcode-soluti-1egk/?envType=study-plan-v2&amp;envId=top-interview-150">题解</a>吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">        res += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="x-的平方根">21.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/?envType=study-plan-v2&amp;envId=top-interview-150">x
的平方根</a></h3>
<p>——二分查找</p>
<p>要找到一个整数的平方根，那么退出二分查找的条件则可以定为左右边界相差不能大于
1，这样就能把左右边界压缩到平方根的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x / mid == mid) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x / mid &lt; mid) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="powxn">21.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/powx-n/description/?envType=study-plan-v2&amp;envId=top-interview-150">Pow(x,n)</a></h3>
<p>——快速幂</p>
<p>快速幂的模板题，需要注意的是，当 n&lt;0 时，应该用除法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">long</span>) n;</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> t &gt; <span class="number">0</span>;</span><br><span class="line">    t = t &gt; <span class="number">0</span> ? t : -t;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) res *= x;</span><br><span class="line">            <span class="keyword">else</span> res /= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直线上最多的点数">21.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-points-on-a-line/description/?envType=study-plan-v2&amp;envId=top-interview-150">直线上最多的点数</a></h3>
<p>使用 Map
记录直线斜率，但是直线斜率算出来是浮点数，所以把直线斜率的分子和分母使用下划线拼接成字符串，然后作为键进行存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>], x2 = points[j][<span class="number">0</span>], y2 = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x1 - x2, b = y1 - y2;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> gcd(a, b);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (a / k) + <span class="string">&quot;_&quot;</span> + (b / k);</span><br><span class="line">            record.put(key, record.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, record.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">22.动态规划</h2>
<p>动态规划五部曲</p>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ol>
<h3 id="爬楼梯">22.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&amp;envId=top-interview-150">爬楼梯</a></h3>
<p>斐波那契数模板题目。 a[i] = a[i-1] + a[i-2]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍">22.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&amp;envId=top-interview-150">打家劫舍</a></h3>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义 <br> dp
数组表示能偷窃到当前房屋的最高金额。其中 dp[i]的下标 i 表示的是第 i+1
间房屋</li>
<li>确定递推公式 <br> 怎么推导递推公式呢？ 对于当前位置 i
来讲，要么就是前一个相邻位置 i-1 取得的收益高，我们此时就需要以 i-1
作为起点；要么就是再前面的一个位置 i - 2 取得的收益 +
当前房屋能取得的收益
的总和收益高。所以对于当前位置，我们的递推公式就是</li>
</ol>
<p><span class="math display">\[
\begin{equation}
max=\left\{
\begin{aligned}
nums[i] + dp[i-2] \\
dp[i-1]
\end{aligned}
\right.
\end{equation}
\]</span></p>
<ol type="1">
<li>dp 数组如何初始化 <br>
根据递推公式我们可以知道，我们需要初始化的值只有两个，dp[0],
dp[1]，dp[0]是什么，是打劫第一间房屋取得的收益，没得选，只有第一家能选。dp[1]是什么，dp[1]是打劫完第一和第二间房屋后，所取得的最大收益，那是什么，肯定是第一间和第二间房屋取得更大收益那个，所以我们的初始化就出来了
dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]);</li>
<li>确定遍历顺序 <br></li>
</ol>
<p>一维数组，基本都是从小到大，只有设计背包问题，两个条件才需要考虑遍历顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math._max_(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        dp[i] = Math._max_(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词拆分">22.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break?envType=study-plan-v2&amp;envId=top-interview-150">单词拆分</a></h3>
<p>——动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——前缀树</p>
<p>被样例整破防了，前缀树压根过不了，这里写一个没有完全通过的版本，题解竟然叫去写前缀树。看来还是我学不够。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node root;</span><br><span class="line">        Trie()&#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertWord</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.subNodes.containsKey(ch))&#123;</span><br><span class="line">                    cur = cur.subNodes.get(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.subNodes.put(ch,<span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">                    cur = cur.subNodes.get(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">            <span class="type">boolean</span> isEnd;</span><br><span class="line">            Map&lt;Character,Node&gt; subNodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordSet) &#123;</span><br><span class="line">            root.insertWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Trie.<span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> root.root;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.subNodes.containsKey(s.charAt(idx)))&#123;</span><br><span class="line">                tmp = tmp.subNodes.get(s.charAt(idx));</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.isEnd) tmp = root.root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换">22.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&amp;envId=top-interview-150">零钱兑换</a></h3>
<ol type="1">
<li>确定 dp 数组 (dp table) 以及下标的含义<br> dp[i]表示的是：当总金额为
i 时，所需的最少的硬币数。</li>
<li>确定递推公式<br> dp[i] = Math._min_(dp[i], dp[i - coins[j]] + 1)
对于总金额为 i 的情况，我们需要考虑第 j 个硬币到底取不取。取的话，应该由
i-coins[j] 的最少硬币数 + 1 来赋值；不取的话，就只能赋回原来的值。</li>
<li>dp 数组如何初始化<br> dp[0] = 0 当总金额为 0
时，我们需要的硬币数也为 0 .</li>
<li>确定遍历顺序<br>
其实，这道题目很像多重背包，但又存在很多不同。首先一个是这道题目想要求解的是计数问题，并不是最大化价值问题；其次是这道题目的遍历顺序跟多重背包的遍历顺序不太一样，多重背包是先遍历物品，再遍历背包。这道题目是先遍历的背包，再遍历物品。因为对于每一个总金额，我们都需要考虑所有的硬币所组成的搭配。并优化器</li>
<li>举例推导 dp 数组<br></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    Arrays._fill_(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                dp[i] = Math._min_(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长递增子序列">22.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150">最长递增子序列</a></h3>
<p>——动态规划 + 二分查找</p>
<p>还是画个图模拟一下代码的整个流程更好理解一点。如下图，二分查找插入的目的是什么？其实目的就是为了让我们的
dp
数组更好插入后面的数。二分查找为新到来的数在新数组中找到一个最合适的插入位置，使得新数组中的数保持递增并尽量小。
<img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111852.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[len] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; dp[len]) dp[++len] = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多维动态规划">23. 多维动态规划</h2>
<h3 id="三角形最小路径和">23.1 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/?envType=study-plan-v2&amp;envId=top-interview-150">三角形最小路径和</a></h3>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111914.png" />
从最下面往上面走，第 i 层 第 j 个数的最终结果是什么呢？</p>
<p><span class="math display">\[
dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j];
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">    <span class="comment">// 由底部到顶部</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) dp[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            dp[j] = Math._min_(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和">23.2 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/?envType=study-plan-v2&amp;envId=top-interview-150">最小路径和</a></h3>
<p>先处理边界格子（下图标绿色的格子），对于非边界的格子，可以由左边和上边推导得到。边缘只能从左边或者上面来，所以没得优化，所以我们对最上面的边和最左面的边，我们使用前缀和算出到每一个格子需要的路径。对于不是最左边和最上边的格子，我们的递推公式为：</p>
<p><span class="math display">\[
dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])
\]</span> 其中 dp[i-1][j] 表示从上面来，dp[i][j-1]表示从左边来 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111936.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="不同路径-ⅱ">23.3 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">不同路径
Ⅱ</a></h3>
<p>其实跟上一道题目思路差不多，都是先处理边界格子。但还是存在差别，本题我们是计算到达格子的路线有几条，不是求最小值，而是求和。另外在处理格子时，对于边界的格子，都只有从左边来或者从上边来一种路线，所以我们初始化为
1，但是，遇到障碍物后，后面的格子都没法到达，所以为 0
。对于非边界的格子，也同样需要对存在障碍物进行处理，存在障碍物不更新，不存在障碍物才更新</p>
<p>递推公式</p>
<p><span class="math display">\[
dp[i][j] = dp[i-1][j] + dp[i][j-1]
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交错字符串">23.4 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">交错字符串</a></h3>
<p>——动态规划</p>
<p>其实题目说了一堆交错组成的概念，真的需要考虑是否是交错组合吗？其实不用，设想一下，当
s3 已经有字符跟 s1 的字符匹配了，下一个字符无论是 s1 的还是 s2
的，都能保证交错组成。最极端的情况便是前半部分由 s1 组成，后半部分由 s2
组成，但这也是交错。所以我们可以大胆的以字符串匹配的想法来做。但是这里会存在一个疑问，为什么不能用双指针呢？如下图所示，当遍历到
s3 这个位置时，我们会发现此时用来遍历 s1 和 s2 的指针都满足与 s3
匹配的要求，所以此时如果走 s1，尚且能通过样例，一旦样例需要先走
s2，那就过不了了。 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221111959.png" />
再来讲一下动态规划的思路吧。</p>
<p><img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221112028.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line">    <span class="keyword">if</span> (n + m != t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = dp[i][j] || (s1.charAt(i - <span class="number">1</span>) == s3.charAt(q) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = dp[i][j] || (s2.charAt(j-<span class="number">1</span>) == s3.charAt(q) &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离">23.5 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&amp;envId=top-interview-150">编辑距离</a></h3>
<p>假设我们有两个字符串 word1 和 word2，我们的目标是将 word1 转换成
word2。设 dp[i][j] 表示的是将 word1 的前 i 个字符转换成 word2 的前 j
个字符所需的最小编辑操作数。</p>
<p>情况 1: 字符相等 如果 word1 的第 i 个字符（即 word1[i-1]）等于 word2
的第 j 个字符（即
word2[j-1]），那么这两个字符之间不需要任何编辑操作，因此 dp[i][j] =
dp[i-1][j-1]。</p>
<p>情况 2: 字符不等 如果 word1[i-1] !=
word2[j-1]，那么我们需要考虑三种编辑操作：</p>
<p>最终，dp[i][j]
应该取这三种情况中的最小值，因为我们要找的是最少编辑操作次数。所以可以得到最终的递推结果</p>
<p><span class="math display">\[
\begin{equation}
dp[i][j]=\left\{
\begin{aligned}
&amp;dp[i-1]&amp; word1[i-1] == word2[j-1] \\
&amp;min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1&amp; word1[i-1] !=
word2[j-1]
\end{aligned}
\right.
\end{equation}
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    word1 = <span class="string">&quot;0&quot;</span> + word1;</span><br><span class="line">    word2 = <span class="string">&quot;0&quot;</span> + word2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>][m + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅱ">23.6 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机
Ⅱ</a></h3>
<p>——投机取巧</p>
<p>题目说没有限制一天里只能买或者只能卖，并且也没有限制买卖的次数，我们只需要看有涨幅就进行买卖操作，就能获得最大收益。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[j] &gt; prices[j - <span class="number">1</span>]) res += prices[j] - prices[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——动态规划</p>
<ol type="1">
<li>定义状态</li>
</ol>
<p>dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i
天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p>
<ol start="2" type="1">
<li><p>考虑情况</p>
<ol type="1">
<li>情况一 考虑 dp[i][0]
的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即
dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即
dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i]
的收益。因此为了收益最大化，我们列出如下的转移方程：</li>
<li>再来考虑
dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即
dp[i−1][1]，或者前一天结束时还没有股票，即
dp[i−1][0]，这时候我们要将其买入，并减少 prices[i]
的收益。可以列出如下的转移方程：</li>
</ol>
<p><span class="math display">\[
p[i][1]=max(dp[i−1][1],dp[i−1][0]−prices[i])
\]</span></p></li>
<li><p>对于初始状态</p></li>
</ol>
<p>根据状态定义我们可以知道第 0 天交易结束的时候
dp[0][0]=0，dp[0][1]=−prices[0]。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候
dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为
dp[n−1][0]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅲ">23.7 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅲ</a></h3>
<p>——动态规划</p>
<ol type="1">
<li><p>定义状态</p>
<ol type="1">
<li>j=0 表示第 i 天结束时，未持有任何股票，且购买次数为
2。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][0]=dp[i-1][0];
\]</span></p>
<ol start="2" type="1">
<li>j=1 表示第 i 天结束时，持有股票，且购买次数为
1。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
p[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i-1])
\]</span></p>
<p>（prices[i-1]表示第 i 天的价格，下同）</p>
<ol start="3" type="1">
<li>j=2 表示第 i 天结束时，持有股票，且购买次数为
2。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
p[i][2]=max(dp[i-1][2],dp[i-1][3]-prices[i-1])
\]</span></p>
<ol start="4" type="1">
<li>j=3 表示第 i 天结束时，未持有股票，且购买次数为 1。
可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][3]=max(dp[i-1][3],dp[i-1][1]+prices[i-1])
\]</span></p>
<ol start="5" type="1">
<li>j=4 表示第 i 天结束时，未持有股票，且购买次数为 1
。可得到状态方程：</li>
</ol>
<p><span class="math display">\[
dp[i][4]=max(dp[i-1][4],dp[i-1][2]+prices[i-1])
\]</span></p></li>
<li><p>对于初始状态</p></li>
</ol>
<p>由于第 1 天卖出股票的情况都是当天买当天卖，因此 0、3、4 状态都为
0，讨论 1、2 状态</p>
<p>第一天第一次买入：</p>
<p><span class="math display">\[
dp[1][1]=-prices[0];
\]</span> 第一天第二次买入（第一次当天买当天卖）：</p>
<p><span class="math display">\[
dp[1][2]=-prices[0];
\]</span> ​ 3. 返回值</p>
<p>考虑到如果最后一天买入并不会使最大值的结果发生变化，因此，答案只会在
3、4 状态产生</p>
<p><span class="math display">\[
max（dp[n][3],dp[n][4]）;
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n][<span class="number">4</span>], dp[n][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机-ⅳ">23.8 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&amp;envId=top-interview-150">买卖股票的最佳时机
Ⅳ</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[][] matrix : dp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : matrix) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MIN_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; ++i) dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">0</span>] = Math.max(dp[i][j][<span class="number">0</span>], dp[i][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">1</span>] = Math.max(dp[i][j][<span class="number">1</span>], dp[i][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计全为-1-的正方形子矩阵">23.9 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/">统计全为
1 的正方形子矩阵</a></h3>
<p>贴一下官方题解吧，写的很清晰。不过我再解释一下为什么递推公式可以是下面这个</p>
<p><span class="math display">\[
\begin{equation}
dp[i][j]=\left\{
\begin{aligned}
min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1] &amp;  &amp; matrxi[i][j]==1 \\
0 &amp;  &amp; matrix[i][j] == 0 \\
\end{aligned}
\right.
\end{equation}
\]</span></p>
<p>我们画个图讲一下吧 <img
src="https://ych-blog.oss-cn-guangzhou.aliyuncs.com/20241221112105.png" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSquares</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(matrix) || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || matrix[i][j] == <span class="number">0</span>) dp[i][j] = matrix[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            res += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大正方形">23.10 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&amp;envId=top-interview-150">最大正方形</a></h3>
<p>这个题目的解法基本跟上面的题目思路一致。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(matrix) || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res = Math.max(dp[i][<span class="number">0</span>], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res = Math.max(dp[<span class="number">0</span>][j], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>旺仔
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ych1016.github.io/2024/12/01/Algorithm/%E3%80%90%E5%8A%9B%E6%89%A3%E3%80%91%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/" title="【力扣】面试经典150题">https://ych1016.github.io/2024/12/01/Algorithm/【力扣】面试经典150题/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/username">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/channel_name">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
      </div>

      <div class="social-item">
          <span class="social-link">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </span>

          <img class="social-item-img" src="/images/wechat_channel.png">
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%8A%9B%E6%89%A3/" rel="tag"># 力扣</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/" rel="tag"># 面试经典150题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/01/Life/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" rel="next" title="碎碎念">
                  碎碎念 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">旺仔</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">80k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:52</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
